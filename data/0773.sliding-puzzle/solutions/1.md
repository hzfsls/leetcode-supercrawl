## [773.æ»‘åŠ¨è°œé¢˜ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/sliding-puzzle/solutions/100000/gong-shui-san-xie-fa-hui-a-suan-fa-zui-d-3go8)

ä½œè€…ï¼š[AC_OIer](https://leetcode.cn/u/AC_OIer)

## åŸºæœ¬åˆ†æ

è¿™æ˜¯å…«æ•°ç é—®é¢˜çš„ç®€åŒ–ç‰ˆï¼šå°† $3 * 3$ å˜ä¸º $2 * 3$ï¼ŒåŒæ—¶å°†ã€Œè¾“å‡ºè·¯å¾„ã€å˜ä¸ºã€Œæ±‚æœ€å°æ­¥æ•°ã€ã€‚

é€šå¸¸æ­¤ç±»é—®é¢˜å¯ä»¥ä½¿ç”¨ã€ŒBFSã€ã€ã€ŒAStar ç®—æ³•ã€ã€ã€Œåº·æ‹“å±•å¼€ã€è¿›è¡Œæ±‚è§£ã€‚

ç”±äºé—®é¢˜ç®€åŒ–åˆ°äº† $2 * 3$ï¼Œæˆ‘ä»¬ä½¿ç”¨å‰ä¸¤ç§è§£æ³•å³å¯ã€‚

---

## BFS

ä¸ºäº†æ–¹ä¾¿ï¼Œå°†åŸæ¥çš„äºŒç»´çŸ©é˜µè½¬æˆå­—ç¬¦ä¸²ï¼ˆä¸€ç»´çŸ©é˜µï¼‰è¿›è¡Œå¤„ç†ã€‚

è¿™æ ·å¸¦æ¥çš„å¥½å¤„ç›´æ¥å¯ä»¥ä½œä¸ºå“ˆå¸Œ `Key` ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥å¾ˆæ–¹ä¾¿è¿›è¡Œã€ŒäºŒç»´åæ ‡ã€ä¸ã€Œä¸€ç»´ä¸‹æ ‡ã€çš„è½¬æ¢ã€‚

ç”±äºå›ºå®šæ˜¯ $2 * 3$ çš„æ ¼å­ï¼Œå› æ­¤ä»»æ„çš„åˆæ³•äºŒç»´åæ ‡ $(x, y)$ å’Œå¯¹åº”ä¸€ç»´ä¸‹æ ‡ $idx$ å¯é€šè¿‡ä»¥ä¸‹è½¬æ¢ï¼š

* $idx = x * 3 + y$
* $x = idx / 3,y = idx \% 3$

å…¶ä½™çš„å°±æ˜¯å¸¸è§„çš„ `BFS` è¿‡ç¨‹äº†ã€‚

ä»£ç ï¼š
```Java []
class Solution {
    class Node {
        String str;
        int x, y;
        Node(String _str, int _x, int _y) {
            str = _str; x = _x; y = _y;
        }
    }
    int n = 2, m = 3;
    String s, e;
    int x, y;
    public int slidingPuzzle(int[][] board) {
        s = "";
        e = "123450";
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                s += board[i][j];
                if (board[i][j] == 0) {
                    x = i; y = j;
                }
            }
        }
        int ans = bfs();
        return ans;
    }
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int bfs() {
        Deque<Node> d = new ArrayDeque<>();
        Map<String, Integer> map = new HashMap<>();
        Node root = new Node(s, x, y);
        d.addLast(root);
        map.put(s, 0);
        while (!d.isEmpty()) {
            Node poll = d.pollFirst();
            int step = map.get(poll.str);
            if (poll.str.equals(e)) return step;
            int dx = poll.x, dy = poll.y;
            for (int[] di : dirs) {
                int nx = dx + di[0], ny = dy + di[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                String nStr = update(poll.str, dx, dy, nx, ny);      
                if (map.containsKey(nStr)) continue;          
                Node next = new Node(nStr, nx, ny);
                d.addLast(next);
                map.put(nStr, step + 1);
            }
        }
        return -1;
    }
    String update(String cur, int i, int j, int p, int q) {
        char[] cs = cur.toCharArray();
        char tmp = cs[i * m + j];
        cs[i * m + j] = cs[p * m + q];
        cs[p * m + q] = tmp;
        return String.valueOf(cs);
    }
}
```

---

## A* ç®—æ³•

å¯ä»¥ç›´æ¥æ ¹æ®æœ¬é¢˜è§„åˆ™æ¥è®¾è®¡ A* çš„ã€Œå¯å‘å¼å‡½æ•°ã€ã€‚

æ¯”å¦‚å¯¹äºä¸¤ä¸ªçŠ¶æ€ `a` å’Œ `b` å¯ç›´æ¥è®¡ç®—å‡ºã€Œç†è®ºæœ€å°è½¬æ¢æ¬¡æ•°ã€ï¼š**æ‰€æœ‰ä½ç½®çš„æ•°å€¼ã€Œæ‰€åœ¨ä½ç½®ã€ä¸ã€Œç›®æ ‡ä½ç½®ã€çš„æ›¼å“ˆé¡¿è·ç¦»ä¹‹å’Œï¼ˆå³æ¨ªçºµåæ ‡ç»å¯¹å€¼ä¹‹å’Œï¼‰** ã€‚

æ³¨æ„ï¼Œæˆ‘ä»¬åªéœ€è¦è®¡ç®—ã€Œéç©ºæ ¼ã€ä½ç½®çš„æ›¼å“ˆé¡¿è·ç¦»å³å¯ï¼Œå› ä¸ºç©ºæ ¼çš„ä½ç½®ä¼šç”±å…¶ä½™æ•°å­—å æ‰å“ªäº›ä½ç½®è€Œå”¯ä¸€ç¡®å®šã€‚

**A\* æ±‚æœ€çŸ­è·¯çš„æ­£ç¡®æ€§é—®é¢˜ï¼šç”±äºæˆ‘ä»¬è¡¡é‡æŸä¸ªçŠ¶æ€ `str` çš„ä¼°å€¼æ˜¯ä»¥ç›®æ ‡å­—ç¬¦ä¸² `e=123450` ä¸ºåŸºå‡†ï¼Œå› æ­¤æˆ‘ä»¬åªèƒ½ç¡®ä¿ `e` å‡ºé˜Ÿæ—¶ä¸ºã€Œè·ç¦»æœ€çŸ­ã€ï¼Œè€Œä¸èƒ½ç¡®ä¿ä¸­é—´èŠ‚ç‚¹å‡ºé˜Ÿæ—¶ã€Œè·ç¦»æœ€çŸ­ã€ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½å•çº¯æ ¹æ®æŸä¸ªèŠ‚ç‚¹æ˜¯å¦ã€Œæ›¾ç»å…¥é˜Ÿã€è€Œå†³å®šæ˜¯å¦å…¥é˜Ÿï¼Œè¿˜è¦ç»“åˆå½“å‰èŠ‚ç‚¹çš„ã€Œæœ€å°è·ç¦»ã€æ˜¯å¦è¢«æ›´æ–°è€Œå†³å®šæ˜¯å¦å…¥é˜Ÿã€‚**

è¿™ä¸€ç‚¹ååˆ†å…³é”®ï¼Œåœ¨ä»£ç å±‚é¢ä¸Šä½“ç°åœ¨ `map.get(nStr) > step + 1` çš„åˆ¤æ–­ä¸Šã€‚

**æˆ‘ä»¬çŸ¥é“ï¼ŒA\* åœ¨æœ‰è§£çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šå‘æŒ¥ã€Œå¯å‘å¼æœç´¢ã€çš„æœ€å¤§ä»·å€¼ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿæå‰åˆ¤æ–­æ— è§£çš„æƒ…å†µï¼Œå¯¹ A\* ç®—æ³•æ¥è¯´ä¼šæ˜¯å·¨å¤§çš„æå‡ã€‚**

è€Œå¯¹äºé€šç”¨çš„ $N * N$ æ•°ç é—®é¢˜ï¼Œåˆ¤å®šæœ‰è§£çš„ä¸€ä¸ªå……è¦æ¡ä»¶æ˜¯ï¼š**ã€Œé€†åºå¯¹ã€æ•°é‡ä¸ºå¶æ•°ï¼Œå¦‚æœä¸æ»¡è¶³ï¼Œå¿…ç„¶æ— è§£ï¼Œç›´æ¥è¿”å› $-1$ å³å¯ã€‚**

å¯¹è¯¥ç»“è®ºçš„å……åˆ†æ€§è¯æ˜å’Œå¿…è¦æ€§è¯æ˜å®Œå…¨ä¸åœ¨ä¸€ä¸ªéš¾åº¦ä¸Šï¼Œæ‰€ä»¥å»ºè®®è®°ä½è¿™ä¸ªç»“è®ºå³å¯ã€‚

ä½†æœ¬é¢˜æ˜¯ $2 * 3$ çš„æ•°ç é—®é¢˜ï¼Œç»“è®ºæ˜¯å¦è¿˜æˆç«‹å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯æˆç«‹çš„ï¼Œå¯¹äºä»»æ„çš„ $N * M$ çš„æ•°ç é—®é¢˜ï¼Œåªè¦ç¡®ä¿ $M$ ä¸ºå¥‡æ•°ï¼Œé€†åºå¯¹æ•°é‡ä¸ºå¶æ•°ï¼Œå¿…ç„¶æœ‰è§£ï¼ˆå› ä¸ºæ­¤æ—¶å››è”é€šçš„æ“ä½œä¸ä¼šæ”¹å˜å¥‡å¶æ€§ï¼‰ã€‚

ä»£ç ï¼š
```Java []
class Solution {
    class Node {
        String str;
        int x, y;
        int val;
        Node(String _str, int _x, int _y, int _val) {
            str = _str; x = _x; y = _y; val = _val;
        }
    }
    int f(String str) {
        int ans = 0;
        char[] cs1 = str.toCharArray(), cs2 = e.toCharArray();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // è·³è¿‡ã€Œç©ºæ ¼ã€ï¼Œè®¡ç®—å…¶ä½™æ•°å€¼çš„æ›¼å“ˆé¡¿è·ç¦»
                if (cs1[i * m + j] == '0' || cs2[i * m + j] == '0') continue;
                int cur = cs1[i * m + j], next = cs2[i * m + j];
                int xd = Math.abs((cur - 1) / 3 - (next - 1) / 3);
                int yd = Math.abs((cur - 1) % 3 - (next - 1) % 3); 
                ans += (xd + yd);
            }
        }
        return ans;
    }
    int n = 2, m = 3;
    String s, e;
    int x, y;
    public int slidingPuzzle(int[][] board) {
        s = "";
        e = "123450";
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                s += board[i][j];
                if (board[i][j] == 0) {
                    x = i; y = j;
                }
            }
        }

        // æå‰åˆ¤æ–­æ— è§£æƒ…å†µ
        if (!check(s)) return -1;

        int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
        Node root = new Node(s, x, y, f(s));
        PriorityQueue<Node> q = new PriorityQueue<>((a,b)->a.val-b.val);
        Map<String, Integer> map = new HashMap<>();
        q.add(root);
        map.put(s, 0);
        while (!q.isEmpty()) {
            Node poll = q.poll();
            int step = map.get(poll.str);
            if (poll.str.equals(e)) return step;
            int dx = poll.x, dy = poll.y;
            for (int[] di : dirs) {
                int nx = dx + di[0], ny = dy + di[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                String nStr = update(poll.str, dx, dy, nx, ny);      
                if (!map.containsKey(nStr) || map.get(nStr) > step + 1) {
                    Node next = new Node(nStr, nx, ny, step + 1 + f(nStr));
                    q.add(next);
                    map.put(nStr, step + 1);
                }
            }
        }
        return 0x3f3f3f3f; // never
    }
    String update(String cur, int i, int j, int p, int q) {
        char[] cs = cur.toCharArray();
        char tmp = cs[i * m + j];
        cs[i * m + j] = cs[p * m + q];
        cs[p * m + q] = tmp;
        return String.valueOf(cs);
    }
    boolean check(String str) {
        char[] cs = str.toCharArray();
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n * m; i++) {
            if (cs[i] != '0') list.add(cs[i] - '0');
        }
        int cnt = 0;
        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i) > list.get(j)) cnt++;
            }
        }
        return cnt % 2 == 0;
    }
}
```

---

## å…¶ä»–ã€Œå¯å‘å¼æœç´¢ã€å†…å®¹

| é¢˜ç›®                                                         | é¢˜è§£                                                         | éš¾åº¦ | æ¨èæŒ‡æ•° |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | -------- |
| [127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/) | [LeetCode é¢˜è§£é“¾æ¥](https://leetcode-cn.com/problems/word-ladder/solution/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/) | å›°éš¾ | ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©    |
| [752. æ‰“å¼€è½¬ç›˜é”](https://leetcode-cn.com/problems/open-the-lock/) | [LeetCode é¢˜è§£é“¾æ¥](https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/) | ä¸­ç­‰ | ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©     |
| [1239. ä¸²è”å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/) | [LeetCode é¢˜è§£é“¾æ¥](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/gong-shui-san-xie-yi-ti-san-jie-jian-zhi-nfeb/) | ä¸­ç­‰ | ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©    |
| [1723. å®Œæˆæ‰€æœ‰å·¥ä½œçš„æœ€çŸ­æ—¶é—´](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/) | [LeetCode é¢˜è§£é“¾æ¥](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/) | å›°éš¾ | ğŸ¤©ğŸ¤©ğŸ¤©ğŸ¤©     |


---

## ã€è¡¥å……ã€‘åº·æ‹“å±•å¼€

**æ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—QAQ](/u/littletime_cc/) æä¾›çš„ã€Œåº·æ‹“å±•å¼€ã€è§£å†³æ–¹æ¡ˆï¼Œä¾›å‚è€ƒã€‚**

ä»£ç ï¼š
```C++ []
const int f[8] = {1,1,2,6,24,120,720};  //factorial table
bool vis[720 + 5];
int step[720 + 5];
const int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0} };
struct Node{
    string s;
    int x,y;
    Node(string _s,int _x,int _y):s(_s), x(_x), y(_y){}
};
class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        string s;
        for(const auto& b : board)
            for(auto x : b) s += x;
        memset(vis,false,sizeof vis);
        memset(step,-1,sizeof step);
        bfs();
        return step[Cantor(6,s)]; 
    }
    inline int getIndex(int x,int y) { return x * 3 + y; }
    void bfs(){
        Node now = {"123450",1,2};
        queue<Node> q;
        q.push(now);
        int cur = Cantor(6,now.s);
        vis[cur] = true; step[cur] = 0;
        while(q.size()){
            auto t = q.front(); q.pop();
            cur = Cantor(6,t.s);
            for(int i = 0; i < 4; i++){
                int t_x = t.x + dir[i][0], t_y = t.y + dir[i][1];
                if(t_x < 0 or t_x >= 2 or t_y < 0 or t_y >= 3) continue;
                Node next = t;
                swap(next.s[getIndex(t.x,t.y)],next.s[getIndex(t_x,t_y)]);
                next.x = t_x; next.y = t_y;
                int next_v = Cantor(6,next.s);
                if(!vis[next_v]){
                    vis[next_v] = true;
                    step[next_v] = step[cur] + 1;
                    q.push(next);
                }
            }
        }
    }
    int Cantor(int L,const string& s){
        int S = 0;
        for(int i = 0; i < L; i++){
            int cnt = 0;
            for(int j = i + 1; j < L; j++){
                if(s[i] > s[j]) cnt++;
            }
            S += cnt * f[L - i - 1];
        }
        return S + 1;
    }
};
```

---

## æœ€å

**å¦‚æœæœ‰å¸®åŠ©åˆ°ä½ ï¼Œè¯·ç»™é¢˜è§£ç‚¹ä¸ªèµå’Œæ”¶è—ï¼Œè®©æ›´å¤šçš„äººçœ‹åˆ° ~ ("â–”â–¡â–”)/**

ä¹Ÿæ¬¢è¿ä½  [å…³æ³¨æˆ‘](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) å’Œ åŠ å…¥æˆ‘ä»¬çš„[ã€Œç»„é˜Ÿæ‰“å¡ã€](https://leetcode-cn.com/u/ac_oier/)å°ç¾¤ ï¼Œæä¾›å†™ã€Œè¯æ˜ã€&ã€Œæ€è·¯ã€çš„é«˜è´¨é‡é¢˜è§£ã€‚

æ‰€æœ‰é¢˜è§£å·²ç»åŠ å…¥ [åˆ·é¢˜æŒ‡å—](https://github.com/SharingSource/LogicStack-LeetCode/wiki)ï¼Œæ¬¢è¿ star å“¦ ~ 