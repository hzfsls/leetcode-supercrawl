## [1814.ç»Ÿè®¡ä¸€ä¸ªæ•°ç»„ä¸­å¥½å¯¹å­çš„æ•°ç›® ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/count-nice-pairs-in-an-array/solutions/100000/by-lcbin-rfuo)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)


**æ–¹æ³•ä¸€ï¼šå¼å­å˜æ¢ + å“ˆå¸Œè¡¨**

å¯¹äºä¸‹æ ‡å¯¹ $(i, j)$ï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œé‚£ä¹ˆæœ‰ $nums[i] + rev(nums[j]) = nums[j] + rev(nums[i])$ï¼Œå³ $nums[i] - rev(nums[i]) = nums[j] - rev(nums[j])$ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°† $nums[i] - rev(nums[i])$ ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ï¼Œç»Ÿè®¡æ¯ä¸ªé”®å‡ºç°çš„æ¬¡æ•°ã€‚æœ€åè®¡ç®—æ¯ä¸ªé”®å¯¹åº”çš„å€¼çš„ç»„åˆæ•°ï¼Œç›¸åŠ å¾—åˆ°æœ€ç»ˆçš„ç­”æ¡ˆã€‚

æ³¨æ„ç­”æ¡ˆçš„å–æ¨¡æ“ä½œã€‚

```python [sol1-Python3]
class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        def rev(x):
            y = 0
            while x:
                y = y * 10 + x % 10
                x //= 10
            return y

        cnt = Counter(x - rev(x) for x in nums)
        mod = 10**9 + 7
        return sum(v * (v - 1) // 2 for v in cnt.values()) % mod
```




```java [sol1-Java]
class Solution {
    public int countNicePairs(int[] nums) {
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int x : nums) {
            int y = x - rev(x);
            cnt.merge(y, 1, Integer::sum);
        }
        final int mod = (int) 1e9 + 7;
        long ans = 0;
        for (int v : cnt.values()) {
            ans = (ans + (long) v * (v - 1) / 2) % mod;
        }
        return (int) ans;
    }

    private int rev(int x) {
        int y = 0;
        for (; x > 0; x /= 10) {
            y = y * 10 + x % 10;
        }
        return y;
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    int countNicePairs(vector<int>& nums) {
        auto rev = [](int x) {
            int y = 0;
            for (; x > 0; x /= 10) {
                y = y * 10 + x % 10;
            }
            return y;
        };
        unordered_map<int, int> cnt;
        for (int& x : nums) {
            int y = x - rev(x);
            cnt[y]++;
        }
        long long ans = 0;
        const int mod = 1e9 + 7;
        for (auto& [_, v] : cnt) {
            ans = (ans + 1ll * v * (v - 1) / 2) % mod;
        }
        return ans;
    }
};
```



```go [sol1-Go]
func countNicePairs(nums []int) (ans int) {
	rev := func(x int) (y int) {
		for ; x > 0; x /= 10 {
			y = y*10 + x%10
		}
		return
	}
	cnt := map[int]int{}
	for _, x := range nums {
		y := x - rev(x)
		cnt[y]++
	}
	const mod int = 1e9 + 7
	for _, v := range cnt {
		ans = (ans + v*(v-1)/2) % mod
	}
	return
}
```

æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨ç»Ÿè®¡æ¬¡æ•°çš„è¿‡ç¨‹ä¸­ç›´æ¥ç´¯åŠ ç­”æ¡ˆã€‚

```python [sol2-Python3]
class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        def rev(x):
            y = 0
            while x:
                y = y * 10 + x % 10
                x //= 10
            return y

        ans = 0
        mod = 10**9 + 7
        cnt = Counter()
        for x in nums:
            y = x - rev(x)
            ans += cnt[y]
            cnt[y] += 1
        return ans % mod
```


```java [sol2-Java]
class Solution {
    public int countNicePairs(int[] nums) {
        Map<Integer, Integer> cnt = new HashMap<>();
        final int mod = (int) 1e9 + 7;
        int ans = 0;
        for (int x : nums) {
            int y = x - rev(x);
            ans = (ans + cnt.getOrDefault(y, 0)) % mod;
            cnt.merge(y, 1, Integer::sum);
        }
        return ans;
    }

    private int rev(int x) {
        int y = 0;
        for (; x > 0; x /= 10) {
            y = y * 10 + x % 10;
        }
        return y;
    }
}
```



```cpp [sol2-C++]
class Solution {
public:
    int countNicePairs(vector<int>& nums) {
        auto rev = [](int x) {
            int y = 0;
            for (; x > 0; x /= 10) {
                y = y * 10 + x % 10;
            }
            return y;
        };
        unordered_map<int, int> cnt;
        int ans = 0;
        const int mod = 1e9 + 7;
        for (int& x : nums) {
            int y = x - rev(x);
            ans = (ans + cnt[y]++) % mod;
        }
        return ans;
    }
};
```

```go [sol2-Go]
func countNicePairs(nums []int) (ans int) {
	rev := func(x int) (y int) {
		for ; x > 0; x /= 10 {
			y = y*10 + x%10
		}
		return
	}
	cnt := map[int]int{}
	const mod int = 1e9 + 7
	for _, x := range nums {
		y := x - rev(x)
		ans = (ans + cnt[y]) % mod
		cnt[y]++
	}
	return
}
```



æ—¶é—´å¤æ‚åº¦ $O(n \times \log M)$ï¼Œå…¶ä¸­ $n$ å’Œ $M$ åˆ†åˆ«æ˜¯æ•°ç»„ `nums` çš„é•¿åº¦å’Œæ•°ç»„ `nums` ä¸­çš„æœ€å¤§å€¼ã€‚ç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚




---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~