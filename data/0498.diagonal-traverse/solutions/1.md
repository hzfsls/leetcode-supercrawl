## [498.对角线遍历 中文热门题解1](https://leetcode.cn/problems/diagonal-traverse/solutions/100000/dui-jiao-xian-bian-li-fen-xi-ti-mu-zhao-zhun-gui-l)

作者：[ikaruga](https://leetcode.cn/u/ikaruga)

#### 解题思路
根据题目描述，首先仔细找一下这道题中一些数字上的规律。  

![图片.png](https://pic.leetcode-cn.com/c087f3ea8c35c83bf7eee073649d05e534827ae1e8de77d7f6759c7eb3db4b4f-%E5%9B%BE%E7%89%87.png){:width=260}
{:align=left}




（可以结合题目给的图来看）

得知：  
1. 每一趟对角线中元素的坐标（x, y）相加的和是递增的。
> 第一趟：1 的坐标(0, 0)。x + y == 0。
> 第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1。
> 第三趟：7 的坐标(0, 2), 5 的坐标(1, 1)，3 的坐标(2, 0)。第三趟 x + y == 2。
> 第四趟：……

2. 每一趟都是 x 或 y 其中一个从大到小（每次-1），另一个从小到大（每次+1）。
> 第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x 每次-1，y 每次+1。
> 第三趟：7 的坐标(0, 2), 5 的坐标(1, 1)，3 的坐标(2, 0)。x 每次 +1，y 每次 -1。

3. 确定初始值。例如这一趟是 x 从大到小， x 尽量取最大，当初始值超过 x 的上限时，不足的部分加到 y 上面。
> 第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1，x 初始值取 1，y 取 0。
> 第四趟：6 的坐标(2, 1)，8 的坐标(1, 2)。x + y == 3，x 初始值取 2，剩下的加到 y上，y 取 1。

4. 确定结束值。例如这一趟是 x 从大到小，这一趟结束的判断是， x 减到 0 或者 y 加到上限。
> 第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x 减到 0 为止。
> 第四趟：6 的坐标(2, 1)，8 的坐标(1, 2)。x 虽然才减到 1，但是 y 已经加到上限了。
 
5. 这一趟是 x 从大到小，那么下一趟是 y 从大到小，循环进行。  并且方向相反时，逻辑处理是一样的，除了x，y和他们各自的上限值是相反的。 
>  x 从大到小，第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1，x 初始值取 1，y 取 0。结束值 x 减到 0 为止。
>  x 从小到大，第三趟：7 的坐标(0, 2)，5 的坐标(1, 1)，3 的坐标(2, 0)。x + y == 2，y 初始值取 2，x 取 0。结束值 y 减到 0 为止。

让我们把规律变成伪代码吧：  

```C++ []
vector<int> nums;
int m = matrix.size();
int n = matrix[0].size();

int i = 0;	// i 是 x + y 的和
while (i < m + n)
{
	// 第 1 3 5 ... 趟
	int x1 = (i < m) ? i : m - 1;	// 确定 x y 的初始值
	int y1 = i - x1;
	while (x1 >= 0 && y1 < n)
	{
		nums.push_back(matrix[x1][y1]);
		x1--;
		y1++;
	}
	i++;

	if (i >= m + n) break;
	// 第 2 4 6 ... 趟
	int y2 = (i < n) ? i : n - 1;	// 确定 x y 的初始值
	int x2 = i - y2;
	while (y2 >= 0 && x2 < m)
	{
		nums.push_back(matrix[x2][y2]);
		x2++;
		y2--;
	}
	i++;
}
return nums;
```

#### 优化
无论这一趟的方向如何，逻辑处理是一样的，那写两套差不多的代码就比较蛋疼，试着合并成一套。  

```bool bXFlag = true;```  
使用一个bool值标记，将用到的数据正确定位。例如：  
 // 5. 逻辑处理是一样的，x，y的上限值是相反的  
```int pm = bXFlag ? m : n;```  
```int pn = bXFlag ? n : m;```  
这样就能保证逻辑计算的代码一样，数据不同。  

以一趟为一个单元，那么 i 就是每一趟的和。  
 // 1. 坐标（x, y）相加的和是递增的  
```for (int i = 0; i < m + n; i++)```  

根据规律，就可以确定 x 和 y 的初始值。  
 // 3. 当初始值超过 x 的上限时，不足的部分加到 y 上面  
```int x = (i < pm) ? i : pm - 1;```   
```int y = i - x;```   

每趟的结束条件。  
 // 4. 这一趟结束的判断是， x 减到 0 或者 y 加到上限  
```while (x >= 0 && y < pn)```   

一趟之中， x 和 y 变化。  
 // 2. 每一趟都是 x 或 y 其中一个从大到小（每次-1），另一个从小到大（每次+1）  
```x--;  y++;```   

输出数字。注意根据标志位变化。  
 // 5. 方向相反时，x，y是相反的  
```nums.push_back(bXFlag ? matrix[x][y] : matrix[y][x]);```   

这一趟结束了，循环起来，标志位变化。  
```bXFlag = !bXFlag;```   


下面是完整代码。    

----
#### 答题
```C++ []
vector<int> findDiagonalOrder(vector<vector<int>>& matrix) 
{
	vector<int> nums;
	int m = matrix.size();
	if (m == 0) return nums;
	int n = matrix[0].size();
	if (n == 0) return nums;

	bool bXFlag = true;
	for (int i = 0; i < m + n; i++)
	{
		int pm = bXFlag ? m : n;
		int pn = bXFlag ? n : m;

		int x = (i < pm) ? i : pm - 1;
		int y = i - x;                

		while (x >= 0 && y < pn)
		{
			nums.push_back(bXFlag ? matrix[x][y] : matrix[y][x]);
			x--;
			y++;
		}

		bXFlag = !bXFlag;
	}
	return nums;
}
```  

完成。



#### 致谢
感谢您的观看，希望对您有帮助，欢迎热烈的交流！  
