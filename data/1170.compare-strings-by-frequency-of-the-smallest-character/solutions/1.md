## [1170.æ¯”è¾ƒå­—ç¬¦ä¸²æœ€å°å­—æ¯å‡ºç°é¢‘æ¬¡ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/solutions/100000/python3javacgotypescript-yi-ti-yi-jie-pa-nu6o)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)


**æ–¹æ³•ä¸€ï¼šæ’åº + äºŒåˆ†æŸ¥æ‰¾**

æˆ‘ä»¬å…ˆæŒ‰ç…§é¢˜ç›®æè¿°ï¼Œå®ç°å‡½æ•° $f(s)$ï¼Œå‡½æ•°è¿”å›å­—ç¬¦ä¸² $s$ ä¸­æŒ‰å­—å…¸åºæ¯”è¾ƒæœ€å°å­—æ¯çš„å‡ºç°é¢‘æ¬¡ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°† $words$ ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸² $w$ éƒ½è®¡ç®—å‡º $f(w)$ï¼Œå¹¶å°†å…¶æ’åºï¼Œå­˜æ”¾åœ¨æ•°ç»„ $nums$ ä¸­ã€‚

ç„¶åï¼Œæˆ‘ä»¬éå† $queries$ ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸² $q$ï¼Œåœ¨ $nums$ ä¸­äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äº $f(q)$ çš„ä½ç½® $i$ï¼Œåˆ™ $nums$ ä¸­ä¸‹æ ‡ $i$ åŠå…¶åé¢çš„å…ƒç´ éƒ½æ»¡è¶³ $f(q) < f(W)$ï¼Œé‚£ä¹ˆå½“å‰æŸ¥è¯¢çš„ç­”æ¡ˆå°±æ˜¯ $n - i$ã€‚



```python [sol1-Python3]
class Solution:
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        def f(s: str) -> int:
            cnt = Counter(s)
            return next(cnt[c] for c in ascii_lowercase if cnt[c])

        n = len(words)
        nums = sorted(f(w) for w in words)
        return [n - bisect_right(nums, f(q)) for q in queries]
```



```java [sol1-Java]
class Solution {
    public int[] numSmallerByFrequency(String[] queries, String[] words) {
        int n = words.length;
        int[] nums = new int[n];
        for (int i = 0; i < n; ++i) {
            nums[i] = f(words[i]);
        }
        Arrays.sort(nums);
        int m = queries.length;
        int[] ans = new int[m];
        for (int i = 0; i < m; ++i) {
            int x = f(queries[i]);
            int l = 0, r = n;
            while (l < r) {
                int mid = (l + r) >> 1;
                if (nums[mid] > x) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            ans[i] = n - l;
        }
        return ans;
    }

    private int f(String s) {
        int[] cnt = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt[s.charAt(i) - 'a'];
        }
        for (int x : cnt) {
            if (x > 0) {
                return x;
            }
        }
        return 0;
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    vector<int> numSmallerByFrequency(vector<string>& queries, vector<string>& words) {
        auto f = [](string s) {
            int cnt[26] = {0};
            for (char c : s) {
                cnt[c - 'a']++;
            }
            for (int x : cnt) {
                if (x) {
                    return x;
                }
            }
            return 0;
        };
        int n = words.size();
        int nums[n];
        for (int i = 0; i < n; i++) {
            nums[i] = f(words[i]);
        }
        sort(nums, nums + n);
        vector<int> ans;
        for (auto& q : queries) {
            int x = f(q);
            ans.push_back(n - (upper_bound(nums, nums + n, x) - nums));
        }
        return ans;
    }
};
```



```go [sol1-Go]
func numSmallerByFrequency(queries []string, words []string) (ans []int) {
	f := func(s string) int {
		cnt := [26]int{}
		for _, c := range s {
			cnt[c-'a']++
		}
		for _, x := range cnt {
			if x > 0 {
				return x
			}
		}
		return 0
	}
	n := len(words)
	nums := make([]int, n)
	for i, w := range words {
		nums[i] = f(w)
	}
	sort.Ints(nums)
	for _, q := range queries {
		x := f(q)
		ans = append(ans, n-sort.SearchInts(nums, x+1))
	}
	return
}
```



```ts [sol1-TypeScript]
function numSmallerByFrequency(queries: string[], words: string[]): number[] {
    const f = (s: string): number => {
        const cnt = new Array(26).fill(0);
        for (const c of s) {
            cnt[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
        return cnt.find(x => x > 0);
    };
    const nums = words.map(f).sort((a, b) => a - b);
    const ans: number[] = [];
    for (const q of queries) {
        const x = f(q);
        let l = 0,
            r = nums.length;
        while (l < r) {
            const mid = (l + r) >> 1;
            if (nums[mid] > x) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        ans.push(nums.length - l);
    }
    return ans;
}
```


æ—¶é—´å¤æ‚åº¦ $O((n + q) \times M)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ å’Œ $q$ åˆ†åˆ«æ˜¯ $words$ å’Œ $queries$ çš„é•¿åº¦ï¼Œè€Œ $M$ æ˜¯å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~