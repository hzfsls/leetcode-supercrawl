## [1129.é¢œè‰²äº¤æ›¿çš„æœ€çŸ­è·¯å¾„ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/shortest-path-with-alternating-colors/solutions/100000/python3javacgo-yi-ti-yi-jie-bfsqing-xi-t-ag0i)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)
**æ–¹æ³•ä¸€ï¼šBFS**

é¢˜ç›®å®é™…ä¸Šæ˜¯æœ€çŸ­è·¯é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨ BFS æ¥è§£å†³ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹æ‰€æœ‰çš„è¾¹è¿›è¡Œé¢„å¤„ç†ï¼Œå°†æ‰€æœ‰çš„è¾¹æŒ‰ç…§é¢œè‰²åˆ†ç±»ï¼Œå­˜å‚¨åˆ°å¤šç»´æ•°ç»„ $g$ ä¸­ã€‚å…¶ä¸­ $g[0]$ å­˜å‚¨æ‰€æœ‰çº¢è‰²è¾¹ï¼Œè€Œ $g[1]$ å­˜å‚¨æ‰€æœ‰è“è‰²è¾¹ã€‚

æ¥ç€ï¼Œæˆ‘ä»¬å®šä¹‰ä»¥ä¸‹æ•°æ®ç»“æ„æˆ–å˜é‡ï¼š

-   é˜Ÿåˆ— $q$ï¼šç”¨æ¥å­˜å‚¨å½“å‰æœç´¢åˆ°çš„èŠ‚ç‚¹ï¼Œä»¥åŠå½“å‰è¾¹çš„é¢œè‰²ï¼›
-   é›†åˆ $vis$ï¼šç”¨æ¥å­˜å‚¨å·²ç»æœç´¢è¿‡çš„èŠ‚ç‚¹ï¼Œä»¥åŠå½“å‰è¾¹çš„é¢œè‰²ï¼›
-   å˜é‡ $d$ï¼šç”¨æ¥è¡¨ç¤ºå½“å‰æœç´¢çš„å±‚æ•°ï¼Œå³å½“å‰æœç´¢åˆ°çš„èŠ‚ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»ï¼›
-   æ•°ç»„ $ans$ï¼šç”¨æ¥å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹åˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚åˆå§‹æ—¶ï¼Œæˆ‘ä»¬å°† $ans$ æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸º $-1$ï¼Œè¡¨ç¤ºæ‰€æœ‰èŠ‚ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»éƒ½æœªçŸ¥ã€‚

æˆ‘ä»¬é¦–å…ˆå°†èµ·ç‚¹ $0$ å’Œèµ·ç‚¹è¾¹çš„é¢œè‰² $0$ æˆ– $1$ å…¥é˜Ÿï¼Œè¡¨ç¤ºä»èµ·ç‚¹å‡ºå‘ï¼Œä¸”å½“å‰æ˜¯çº¢è‰²æˆ–è“è‰²è¾¹ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¼€å§‹è¿›è¡Œ BFS æœç´¢ã€‚æˆ‘ä»¬æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ $(i, c)$ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆè¿˜æœªæ›´æ–°ï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹çš„ç­”æ¡ˆæ›´æ–°ä¸ºå½“å‰å±‚æ•° $d$ï¼Œå³ $ans[i] = d$ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†å½“å‰è¾¹çš„é¢œè‰² $c$ å–åï¼Œå³å¦‚æœå½“å‰è¾¹ä¸ºçº¢è‰²ï¼Œåˆ™å°†å…¶å˜ä¸ºè“è‰²ï¼Œåä¹‹äº¦ç„¶ã€‚æˆ‘ä»¬å–å‡ºé¢œè‰²å¯¹åº”çš„æ‰€æœ‰è¾¹ï¼Œå¦‚æœè¾¹çš„å¦ä¸€ç«¯èŠ‚ç‚¹ $j$ æœªè¢«æœç´¢è¿‡ï¼Œåˆ™å°†å…¶å…¥é˜Ÿã€‚

æœç´¢ç»“æŸåï¼Œè¿”å›ç­”æ¡ˆæ•°ç»„å³å¯ã€‚


```python [sol1-Python3]
class Solution:
    def shortestAlternatingPaths(
        self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]
    ) -> List[int]:
        g = [defaultdict(list), defaultdict(list)]
        for i, j in redEdges:
            g[0][i].append(j)
        for i, j in blueEdges:
            g[1][i].append(j)
        ans = [-1] * n
        vis = set()
        q = deque([(0, 0), (0, 1)])
        d = 0
        while q:
            for _ in range(len(q)):
                i, c = q.popleft()
                if ans[i] == -1:
                    ans[i] = d
                vis.add((i, c))
                c ^= 1
                for j in g[c][i]:
                    if (j, c) not in vis:
                        q.append((j, c))
            d += 1
        return ans
```



```java [sol1-Java]
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        List<Integer>[][] g = new List[2][n];
        for (var f : g) {
            Arrays.setAll(f, k -> new ArrayList<>());
        }
        for (var e : redEdges) {
            g[0][e[0]].add(e[1]);
        }
        for (var e : blueEdges) {
            g[1][e[0]].add(e[1]);
        }
        Deque<int[]> q = new ArrayDeque<>();
        q.offer(new int[] {0, 0});
        q.offer(new int[] {0, 1});
        boolean[][] vis = new boolean[n][2];
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        int d = 0;
        while (!q.isEmpty()) {
            for (int k = q.size(); k > 0; --k) {
                var p = q.poll();
                int i = p[0], c = p[1];
                if (ans[i] == -1) {
                    ans[i] = d;
                }
                vis[i][c] = true;
                c ^= 1;
                for (int j : g[c][i]) {
                    if (!vis[j][c]) {
                        q.offer(new int[] {j, c});
                    }
                }
            }
            ++d;
        }
        return ans;
    }
}
```


```cpp [sol1-C++]
class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<vector<int>>> g(2, vector<vector<int>>(n));
        for (auto& e : redEdges) {
            g[0][e[0]].push_back(e[1]);
        }
        for (auto& e : blueEdges) {
            g[1][e[0]].push_back(e[1]);
        }
        queue<pair<int, int>> q;
        q.emplace(0, 0);
        q.emplace(0, 1);
        bool vis[n][2];
        memset(vis, false, sizeof vis);
        vector<int> ans(n, -1);
        int d = 0;
        while (!q.empty()) {
            for (int k = q.size(); k; --k) {
                auto [i, c] = q.front();
                q.pop();
                if (ans[i] == -1) {
                    ans[i] = d;
                }
                vis[i][c] = true;
                c ^= 1;
                for (int& j : g[c][i]) {
                    if (!vis[j][c]) {
                        q.emplace(j, c);
                    }
                }
            }
            ++d;
        }
        return ans;
    }
};
```


```go [sol1-Go]
func shortestAlternatingPaths(n int, redEdges [][]int, blueEdges [][]int) []int {
	g := [2][][]int{}
	for i := range g {
		g[i] = make([][]int, n)
	}
	for _, e := range redEdges {
		g[0][e[0]] = append(g[0][e[0]], e[1])
	}
	for _, e := range blueEdges {
		g[1][e[0]] = append(g[1][e[0]], e[1])
	}
	type pair struct{ i, c int }
	q := []pair{pair{0, 0}, pair{0, 1}}
	ans := make([]int, n)
	vis := make([][2]bool, n)
	for i := range ans {
		ans[i] = -1
	}
	d := 0
	for len(q) > 0 {
		for k := len(q); k > 0; k-- {
			p := q[0]
			q = q[1:]
			i, c := p.i, p.c
			if ans[i] == -1 {
				ans[i] = d
			}
			vis[i][c] = true
			c ^= 1
			for _, j := range g[c][i] {
				if !vis[j][c] {
					q = append(q, pair{j, c})
				}
			}
		}
		d++
	}
	return ans
}
```

æ—¶é—´å¤æ‚åº¦ $O(n + m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n + m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸ºèŠ‚ç‚¹æ•°å’Œè¾¹æ•°ã€‚


---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~