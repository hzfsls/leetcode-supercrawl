## [350.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† II ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/intersection-of-two-arrays-ii/solutions/100000/ha-xi-biao-liang-ge-shu-zu-de-jiao-ji-ii-fkwo)

ä½œè€…ï¼š[demigodliu](https://leetcode.cn/u/demigodliu)
![å›¾è§£æ¯æ—¥ä¸€ç»ƒ.jpg](https://pic.leetcode-cn.com/1615817903-fzmpwZ-%E5%9B%BE%E8%A7%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83.jpg)

---

### ğŸ§  è§£é¢˜æ€è·¯

é€šè¿‡é¢˜æ„ï¼Œå¯»æ‰¾ä¸¤æ•°ç»„æ˜¯å¦æœ‰ç›¸åŒé¡¹ï¼Œå¹¶ä¸”æç¤ºä¸­è¯´å¯ä»¥ä¸è¦æ±‚äº¤é›†çš„é¡ºåºã€‚

æ—¢ç„¶å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥å…ˆè¡Œå°†æ•°ç»„æ’åºï¼Œæ–¹ä¾¿æˆ‘ä»¬æŸ¥æ‰¾ï¼Œç„¶åæ­£å¼æµç¨‹å¦‚ä¸‹ï¼š

1. åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆ $i$ æŒ‡å‘ $nums1$ æ•°ç»„é¦–ä½ï¼ŒæŒ‡é’ˆ $j$ æŒ‡å‘ $nums2$ æ•°ç»„é¦–ä½ã€‚
2. åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ ˆï¼Œç”¨äºå­˜æ”¾ç»“æœé›†ã€‚
3. å¼€å§‹æ¯”è¾ƒæŒ‡é’ˆ $i$ å’ŒæŒ‡é’ˆ $j$ çš„å€¼å¤§å°ï¼Œè‹¥ä¸¤ä¸ªå€¼ä¸ç­‰ï¼Œåˆ™æ•°å­—å°çš„æŒ‡é’ˆï¼Œå¾€å³ç§»ä¸€ä½ã€‚
4. è‹¥æŒ‡é’ˆ $i$ å’ŒæŒ‡é’ˆ $j$ çš„å€¼ç›¸ç­‰ï¼Œåˆ™å°†äº¤é›†å‹å…¥æ ˆã€‚
5. è‹¥ $nums$ æˆ– $nums2$ æœ‰ä¸€æ–¹éå†ç»“æŸï¼Œä»£è¡¨å¦ä¸€æ–¹çš„å‰©ä½™å€¼ï¼Œéƒ½æ˜¯å”¯ä¸€å­˜åœ¨ï¼Œä¸”ä¸ä¼šä¸ä¹‹äº§ç”Ÿäº¤é›†çš„ã€‚

---

### ğŸ¨ å›¾è§£æ¼”ç¤º

<![1.jpg](https://pic.leetcode-cn.com/1617032404-VMHJLm-1.jpg),![2.jpg](https://pic.leetcode-cn.com/1617032406-qYuIXB-2.jpg),![3.jpg](https://pic.leetcode-cn.com/1617032409-XWGjeM-3.jpg),![4.jpg](https://pic.leetcode-cn.com/1617032411-XPBbgQ-4.jpg),![5.jpg](https://pic.leetcode-cn.com/1617032414-mWVzyk-5.jpg),![6.jpg](https://pic.leetcode-cn.com/1617032416-oIOrwu-6.jpg),![7.jpg](https://pic.leetcode-cn.com/1617032419-zbCOiu-7.jpg),![8.jpg](https://pic.leetcode-cn.com/1617032421-tbzIxG-8.jpg),![9.jpg](https://pic.leetcode-cn.com/1617032426-JhSqSr-9.jpg),![10.jpg](https://pic.leetcode-cn.com/1617032423-vxhgDz-10.jpg)>

---

### ğŸ­ ç¤ºä¾‹ä»£ç 

```Javascript []
let intersect = function (nums1, nums2) {
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);
    let l = 0, r = 0, ans = [];
    while (l < nums1.length && r < nums2.length) {
        if (nums1[l] === nums2[r]) {
            ans.push(nums1[l]);
            l++;
            r++;
        } else nums1[l] < nums2[r] ? l++ : r++;
    }
    return ans;
};
```
```Java []
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int length1 = nums1.length, length2 = nums2.length;
        int[] intersection = new int[Math.min(length1, length2)];
        int index1 = 0, index2 = 0, index = 0;
        while (index1 < length1 && index2 < length2) {
            if (nums1[index1] < nums2[index2]) {
                index1++;
            } else if (nums1[index1] > nums2[index2]) {
                index2++;
            } else {
                intersection[index] = nums1[index1];
                index1++;
                index2++;
                index++;
            }
        }
        return Arrays.copyOfRange(intersection, 0, index);
    }
}
```
```C++ []
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int length1 = nums1.size(), length2 = nums2.size();
        vector<int> intersection;
        int index1 = 0, index2 = 0;
        while (index1 < length1 && index2 < length2) {
            if (nums1[index1] < nums2[index2]) {
                index1++;
            } else if (nums1[index1] > nums2[index2]) {
                index2++;
            } else {
                intersection.push_back(nums1[index1]);
                index1++;
                index2++;
            }
        }
        return intersection;
    }
};
```
```Python3 []
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()

        length1, length2 = len(nums1), len(nums2)
        intersection = list()
        index1 = index2 = 0
        while index1 < length1 and index2 < length2:
            if nums1[index1] < nums2[index2]:
                index1 += 1
            elif nums1[index1] > nums2[index2]:
                index2 += 1
            else:
                intersection.append(nums1[index1])
                index1 += 1
                index2 += 1
        
        return intersection
```
```Golang []
func intersect(nums1 []int, nums2 []int) []int {
    sort.Ints(nums1)
    sort.Ints(nums2)
    length1, length2 := len(nums1), len(nums2)
    index1, index2 := 0, 0

    intersection := []int{}
    for index1 < length1 && index2 < length2 {
        if nums1[index1] < nums2[index2] {
            index1++
        } else if nums1[index1] > nums2[index2] {
            index2++
        } else {
            intersection = append(intersection, nums1[index1])
            index1++
            index2++
        }
    }
    return intersection
}
```
```C []
int cmp(const void* _a, const void* _b) {
    int *a = _a, *b = (int*)_b;
    return *a == *b ? 0 : *a > *b ? 1 : -1;
}

int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size,
               int* returnSize) {
    qsort(nums1, nums1Size, sizeof(int), cmp);
    qsort(nums2, nums2Size, sizeof(int), cmp);
    *returnSize = 0;
    int* intersection = (int*)malloc(sizeof(int) * fmin(nums1Size, nums2Size));
    int index1 = 0, index2 = 0;
    while (index1 < nums1Size && index2 < nums2Size) {
        if (nums1[index1] < nums2[index2]) {
            index1++;
        } else if (nums1[index1] > nums2[index2]) {
            index2++;
        } else {
            intersection[(*returnSize)++] = nums1[index1];
            index1++;
            index2++;
        }
    }
    return intersection;
}
```

---

### è½¬èº«æŒ¥æ‰‹

å˜¿ï¼Œå°‘å¹´ï¼Œåšå›¾ä¸æ˜“ï¼Œç•™ä¸‹ä¸ªèµæˆ–è¯„è®ºå†èµ°å§ï¼è°¢å•¦~ ğŸ’

å·®ç‚¹å¿˜äº†ï¼Œç¥ä½ ç‰›å¹´å¤§å‰ ğŸ® ï¼ŒAC å’Œ Offer ğŸ“‘ å¤šå¤šç›Šå–„~

â›²â›²â›² æœŸå¾…ä¸‹æ¬¡å†è§~ 