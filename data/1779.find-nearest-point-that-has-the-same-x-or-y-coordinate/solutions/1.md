## [1779.æ‰¾åˆ°æœ€è¿‘çš„æœ‰ç›¸åŒ X æˆ– Y åæ ‡çš„ç‚¹ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/solutions/100000/by-lcbin-2h2q)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)
**æ–¹æ³•ä¸€ï¼šç›´æ¥éå†**

ç›´æ¥éå† `points` æ•°ç»„ï¼Œå¯¹äº $points[i]$ï¼Œå¦‚æœ $points[i][0] = x$ æˆ–è€… $points[i][1] = y$ï¼Œåˆ™è¯´æ˜ $points[i]$ æ˜¯æœ‰æ•ˆç‚¹ï¼Œè®¡ç®—æ›¼å“ˆé¡¿è·ç¦»ï¼Œæ›´æ–°æœ€å°è·ç¦»å’Œæœ€å°è·ç¦»çš„ä¸‹æ ‡ã€‚


```python [sol1-Python3]
class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        ans, mi = -1, inf
        for i, (a, b) in enumerate(points):
            if a == x or b == y:
                d = abs(a - x) + abs(b - y)
                if mi > d:
                    ans, mi = i, d
        return ans
```


```java [sol1-Java]
class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int ans = -1, mi = 1000000;
        for (int i = 0; i < points.length; ++i) {
            int a = points[i][0], b = points[i][1];
            if (a == x || b == y) {
                int d = Math.abs(a - x) + Math.abs(b - y);
                if (d < mi) {
                    mi = d;
                    ans = i;
                }
            }
        }
        return ans;
    }
}
```


```cpp [sol1-C++]
class Solution {
public:
    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
        int ans = -1, mi = 1e6;
        for (int i = 0; i < points.size(); ++i) {
            int a = points[i][0], b = points[i][1];
            if (a == x || b == y) {
                int d = abs(a - x) + abs(b - y);
                if (d < mi) {
                    mi = d;
                    ans = i;
                }
            }
        }
        return ans;
    }
};
```



```go [sol1-Go]
func nearestValidPoint(x int, y int, points [][]int) int {
	ans, mi := -1, 1000000
	for i, p := range points {
		a, b := p[0], p[1]
		if a == x || b == y {
			d := abs(a-x) + abs(b-y)
			if d < mi {
				ans, mi = i, d
			}
		}
	}
	return ans
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚å…¶ä¸­ $n$ ä¸º `points` æ•°ç»„çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~

