## [404.å·¦å¶å­ä¹‹å’Œ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/sum-of-left-leaves/solutions/100000/dai-ma-sui-xiang-lu-dai-ni-xue-tou-er-ch-j6f9)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)


**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[äºŒå‰æ ‘çš„é¢˜ç›®ä¸­ï¼Œæ€»æœ‰ä¸€äº›è§„åˆ™è®©ä½ æ‰¾ä¸åˆ°åŒ— | LeetCodeï¼š404.å·¦å¶å­ä¹‹å’Œ](https://www.bilibili.com/video/BV1GY4y1K7z8)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘åœ¨çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚ 

# æ€è·¯


**é¦–å…ˆè¦æ³¨æ„æ˜¯åˆ¤æ–­å·¦å¶å­ï¼Œä¸æ˜¯äºŒå‰æ ‘å·¦ä¾§èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸è¦ä¸Šæ¥æƒ³ç€å±‚åºéå†ã€‚**

å› ä¸ºé¢˜ç›®ä¸­å…¶å®æ²¡æœ‰è¯´æ¸…æ¥šå·¦å¶å­ç©¶ç«Ÿæ˜¯ä»€ä¹ˆèŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘æ¥ç»™å‡ºå·¦å¶å­çš„æ˜ç¡®å®šä¹‰ï¼š**èŠ‚ç‚¹Açš„å·¦***ä¸ä¸ºç©ºï¼Œä¸”å·¦***çš„å·¦å³***éƒ½ä¸ºç©ºï¼ˆè¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œé‚£ä¹ˆAèŠ‚ç‚¹çš„å·¦***ä¸ºå·¦å¶å­èŠ‚ç‚¹**

çœ‹è¿™ä¸ªå›¾çš„å·¦å¶å­ä¹‹å’Œæ˜¯å¤šå°‘ï¼Ÿ 

![image.png](https://pic.leetcode-cn.com/1662949225-OnEfOS-image.png)

æ€è€ƒä¸€ä¸‹å¦‚ä¸‹å›¾ä¸­äºŒå‰æ ‘ï¼Œå·¦å¶å­ä¹‹å’Œç©¶ç«Ÿæ˜¯å¤šå°‘ï¼Ÿ 

![image.png](https://pic.leetcode-cn.com/1662949206-GBfKCr-image.png)

**å…¶å®æ˜¯0ï¼Œå› ä¸ºè¿™æ£µæ ‘æ ¹æœ¬æ²¡æœ‰å·¦å¶å­ï¼**


ç›¸ä¿¡é€šè¿‡è¿™ä¸¤ä¸ªå›¾ï¼Œå¤§å®¶å¯ä»¥æœ€å·¦å¶å­çš„å®šä¹‰æœ‰æ˜ç¡®ç†è§£äº†ã€‚ 

é‚£ä¹ˆ**åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­æ˜¯æ— æ³•åˆ¤æ–­çš„ï¼Œå¿…é¡»è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ¥åˆ¤æ–­å…¶å·¦***æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚**


å¦‚æœè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™æ‰¾åˆ°äº†ä¸€ä¸ªå·¦å¶å­ï¼Œåˆ¤æ–­ä»£ç å¦‚ä¸‹ï¼š

```CPP
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    å·¦å¶å­èŠ‚ç‚¹å¤„ç†é€»è¾‘
}
```

## é€’å½’æ³•

é€’å½’çš„éå†é¡ºåºä¸ºååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œæ˜¯å› ä¸ºè¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼æ¥ç´¯åŠ æ±‚å–å·¦å¶å­æ•°å€¼ä¹‹å’Œã€‚

é€’å½’ä¸‰éƒ¨æ›²ï¼š

1. ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼

åˆ¤æ–­ä¸€ä¸ªæ ‘çš„å·¦å¶å­èŠ‚ç‚¹ä¹‹å’Œï¼Œé‚£ä¹ˆä¸€å®šè¦ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’å‡½æ•°çš„è¿”å›å€¼ä¸ºæ•°å€¼ä¹‹å’Œï¼Œæ‰€ä»¥ä¸ºint

ä½¿ç”¨é¢˜ç›®ä¸­ç»™å‡ºçš„å‡½æ•°å°±å¯ä»¥äº†ã€‚

2. ç¡®å®šç»ˆæ­¢æ¡ä»¶

å¦‚æœéå†åˆ°ç©ºèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå·¦å¶å­å€¼ä¸€å®šæ˜¯0 

```CPP
if (root == NULL) return 0;
```

æ³¨æ„ï¼Œåªæœ‰å½“å‰éå†çš„èŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œæ‰èƒ½åˆ¤æ–­å…¶å­èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚ æ‰€ä»¥å¦‚æœå½“å‰éå†çš„èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£å…¶å·¦å¶å­ä¹Ÿå¿…å®šæ˜¯0ï¼Œé‚£ä¹ˆç»ˆæ­¢æ¡ä»¶ä¸ºï¼š 

```CPP
if (root == NULL) return 0;
if (root->left == NULL && root->right== NULL) return 0; //å…¶å®è¿™ä¸ªä¹Ÿå¯ä»¥ä¸å†™ï¼Œå¦‚æœä¸å†™ä¸å½±å“ç»“æœï¼Œä½†å°±ä¼šè®©é€’å½’å¤šè¿›è¡Œäº†ä¸€å±‚ã€‚
```


3. ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

å½“é‡åˆ°å·¦å¶å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè®°å½•æ•°å€¼ï¼Œç„¶åé€šè¿‡é€’å½’æ±‚å–å·¦å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œå’Œ å³å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œç›¸åŠ ä¾¿æ˜¯æ•´ä¸ªæ ‘çš„å·¦å¶å­ä¹‹å’Œã€‚

ä»£ç å¦‚ä¸‹ï¼š

```CPP
int leftValue = sumOfLeftLeaves(root->left);    // å·¦
if (root->left && !root->left->left && !root->left->right) {
    leftValue = root->left->val;
}
int rightValue = sumOfLeftLeaves(root->right);  // å³

int sum = leftValue + rightValue;               // ä¸­
return sum;

```


æ•´ä½“é€’å½’ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right== NULL) return 0;

        int leftValue = sumOfLeftLeaves(root->left);    // å·¦
        if (root->left && !root->left->left && !root->left->right) { // å·¦å­æ ‘å°±æ˜¯ä¸€ä¸ªå·¦å¶å­çš„æƒ…å†µ
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // å³

        int sum = leftValue + rightValue;               // ä¸­
        return sum;
    }
};

```

ä»¥ä¸Šä»£ç ç²¾ç®€ä¹‹åå¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        int leftValue = 0;
        if (root->left != NULL && root->left->left == NULL && root->left->right == NULL) {
            leftValue = root->left->val;
        }
        return leftValue + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
    }
};
``` 

ç²¾ç®€ä¹‹åçš„ä»£ç å…¶å®çœ‹ä¸å‡ºæ¥ç”¨çš„æ˜¯ä»€ä¹ˆéå†æ–¹å¼äº†ï¼Œå¯¹äºç®—æ³•åˆå­¦è€…ä»¥ä¸Šæ ¹æ®ç¬¬ä¸€ä¸ªç‰ˆæœ¬æ¥å­¦ä¹ ã€‚ 

## è¿­ä»£æ³•

æœ¬é¢˜è¿­ä»£æ³•ä½¿ç”¨å‰ä¸­ååºéƒ½æ˜¯å¯ä»¥çš„ï¼Œåªè¦æŠŠå·¦å¶å­èŠ‚ç‚¹ç»Ÿè®¡å‡ºæ¥ï¼Œå°±å¯ä»¥äº†ï¼Œé‚£ä¹ˆå‚è€ƒæ–‡ç«  [äºŒå‰æ ‘ï¼šå¬è¯´é€’å½’èƒ½åšçš„ï¼Œæ ˆä¹Ÿèƒ½åšï¼](https://programmercarl.com/äºŒå‰æ ‘çš„è¿­ä»£éå†.html)å’Œ[äºŒå‰æ ‘ï¼šè¿­ä»£æ³•ç»Ÿä¸€å†™æ³•](https://programmercarl.com/äºŒå‰æ ‘çš„ç»Ÿä¸€è¿­ä»£æ³•.html)ä¸­çš„å†™æ³•ï¼Œå¯ä»¥å†™å‡ºä¸€ä¸ªå‰åºéå†çš„è¿­ä»£æ³•ã€‚

åˆ¤æ–­æ¡ä»¶éƒ½æ˜¯ä¸€æ ·çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š

```CPP

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```

# æ€»ç»“

è¿™é“é¢˜ç›®è¦æ±‚å·¦å¶å­ä¹‹å’Œï¼Œå…¶å®æ˜¯æ¯”è¾ƒç»•çš„ï¼Œå› ä¸ºä¸èƒ½åˆ¤æ–­æœ¬èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­èŠ‚ç‚¹ã€‚

æ­¤æ—¶å°±è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ¥åˆ¤æ–­å…¶å·¦***æ˜¯ä¸æ˜¯å·¦å¶å­äº†ã€‚

**å¹³æ—¶æˆ‘ä»¬è§£äºŒå‰æ ‘çš„é¢˜ç›®æ—¶ï¼Œå·²ç»ä¹ æƒ¯äº†é€šè¿‡èŠ‚ç‚¹çš„å·¦å³***åˆ¤æ–­æœ¬èŠ‚ç‚¹çš„å±æ€§ï¼Œè€Œæœ¬é¢˜æˆ‘ä»¬è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹åˆ¤æ–­æœ¬èŠ‚ç‚¹çš„å±æ€§ã€‚**

å¸Œæœ›é€šè¿‡è¿™é“é¢˜ç›®ï¼Œå¯ä»¥æ‰©å±•å¤§å®¶å¯¹äºŒå‰æ ‘çš„è§£é¢˜æ€è·¯ã€‚


# å…¶ä»–è¯­è¨€ç‰ˆæœ¬



```java []
// **é€’å½’**
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int leftValue = sumOfLeftLeaves(root.left);    // å·¦
        int rightValue = sumOfLeftLeaves(root.right);  // å³
                                                       
        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) { 
            midValue = root.left.val;
        }
        int sum = midValue + leftValue + rightValue;  // ä¸­
        return sum;
    }
}

// **è¿­ä»£**
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        Stack<TreeNode> stack = new Stack<> ();
        stack.add(root);
        int result = 0;
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.left != null && node.left.left == null && node.left.right == null) {
                result += node.left.val;
            }
            if (node.right != null) stack.add(node.right);
            if (node.left != null) stack.add(node.left);
        }
        return result;
    }
}

// å±‚åºéå†è¿­ä»£æ³•
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size -- > 0) {
                TreeNode node = queue.poll();
                if (node.left != null) { // å·¦èŠ‚ç‚¹ä¸ä¸ºç©º
                    queue.offer(node.left);
                    if (node.left.left == null && node.left.right == null){ // å·¦å¶å­èŠ‚ç‚¹
                        sum += node.left.val;
                    }
                }
                if (node.right != null) queue.offer(node.right);
            }
        }
        return sum;
    }
}
```



```python []
# **é€’å½’ååºéå†**
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root: 
            return 0
        
        left_left_leaves_sum = self.sumOfLeftLeaves(root.left)  # å·¦
        right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # å³
        
        cur_left_leaf_val = 0
        if root.left and not root.left.left and not root.left.right: 
            cur_left_leaf_val = root.left.val 
            
        return cur_left_leaf_val + left_left_leaves_sum + right_left_leaves_sum # ä¸­

## **è¿­ä»£**
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        """
        Idea: Each time check current node's left node. 
              If current node don't have one, skip it. 
        """
        stack = []
        if root: 
            stack.append(root)
        res = 0
        
        while stack: 
            # æ¯æ¬¡éƒ½æŠŠå½“å‰èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹åŠ è¿›å». 
            cur_node = stack.pop()
            if cur_node.left and not cur_node.left.left and not cur_node.left.right: 
                res += cur_node.left.val
                
            if cur_node.left: 
                stack.append(cur_node.left)
            if cur_node.right: 
                stack.append(cur_node.right)
                
        return res
```



```go []
// **é€’å½’æ³•**
func sumOfLeftLeaves(root *TreeNode) int {
    var  res int
    findLeft(root,&res)
    return res
}
func findLeft(root *TreeNode,res *int){
    //å·¦èŠ‚ç‚¹
    if root.Left!=nil&&root.Left.Left==nil&&root.Left.Right==nil{
        *res=*res+root.Left.Val
    }
    if root.Left!=nil{
        findLeft(root.Left,res)
    }
    if root.Right!=nil{
        findLeft(root.Right,res)
    }
}

// **è¿­ä»£æ³•**
func sumOfLeftLeaves(root *TreeNode) int {
    var  res int
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node.Left!=nil&&node.Left.Left==nil&&node.Left.Right==nil{
                res=res+node.Left.Val
            }
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
    }
    return res
}
```




```javascript []
// **é€’å½’æ³•** 
var sumOfLeftLeaves = function(root) {
    //é‡‡ç”¨ååºéå† é€’å½’éå†
    // 1. ç¡®å®šé€’å½’å‡½æ•°å‚æ•°
    const nodesSum = function(node){
        // 2. ç¡®å®šç»ˆæ­¢æ¡ä»¶
        if(node===null){
            return 0;
        }
        let leftValue = nodesSum(node.left);
        let rightValue = nodesSum(node.right);
        // 3. å•å±‚é€’å½’é€»è¾‘
        let midValue = 0;
        if(node.left&&node.left.left===null&&node.left.right===null){
            midValue = node.left.val;
        }
        let sum = midValue + leftValue + rightValue;
        return sum;
    }
    return nodesSum(root);
};

// **è¿­ä»£æ³•**
var sumOfLeftLeaves = function(root) {
   //é‡‡ç”¨å±‚åºéå†
   if(root===null){
       return null;
   }
   let queue = [];
   let sum = 0;
   queue.push(root);
   while(queue.length){
     let node = queue.shift();
     if(node.left!==null&&node.left.left===null&&node.left.right===null){
         sum+=node.left.val;
     }
     node.left&&queue.push(node.left);
     node.right&&queue.push(node.right);
   }
   return sum;
};
```





```typescript []
// > é€’å½’æ³•
function sumOfLeftLeaves(root: TreeNode | null): number {
    if (root === null) return 0;
    let midVal: number = 0;
    if (
        root.left !== null &&
        root.left.left === null &&
        root.left.right === null
    ) {
        midVal = root.left.val;
    }
    let leftVal: number = sumOfLeftLeaves(root.left);
    let rightVal: number = sumOfLeftLeaves(root.right);
    return midVal + leftVal + rightVal;
};

// > è¿­ä»£æ³•
function sumOfLeftLeaves(root: TreeNode | null): number {
    let helperStack: TreeNode[] = [];
    let tempNode: TreeNode;
    let sum: number = 0;
    if (root !== null) helperStack.push(root);
    while (helperStack.length > 0) {
        tempNode = helperStack.pop()!;
        if (
            tempNode.left !== null &&
            tempNode.left.left === null &&
            tempNode.left.right === null
        ) {
            sum += tempNode.left.val;
        }
        if (tempNode.right !== null) helperStack.push(tempNode.right);
        if (tempNode.left !== null) helperStack.push(tempNode.left);
    }
    return sum;
};
```



```swift []
// **é€’å½’æ³•** 
func sumOfLeftLeaves(_ root: TreeNode?) -> Int {
    guard let root = root else {
        return 0
    }

    let leftValue = sumOfLeftLeaves(root.left)
    let rightValue = sumOfLeftLeaves(root.right)

    var midValue: Int = 0
    if root.left != nil && root.left?.left == nil && root.left?.right == nil {
        midValue = root.left!.val
    }

    let sum = midValue + leftValue + rightValue
    return sum
}

// **è¿­ä»£æ³•**
func sumOfLeftLeaves(_ root: TreeNode?) -> Int {
    guard let root = root else {
        return 0
    }

    var stack = Array<TreeNode>()
    stack.append(root)
    var sum = 0

    while !stack.isEmpty {
        let lastNode = stack.removeLast()

        if lastNode.left != nil && lastNode.left?.left == nil && lastNode.left?.right == nil {
            sum += lastNode.left!.val
        }
        if let right = lastNode.right {
            stack.append(right)
        }
        if let left = lastNode.left {
            stack.append(left)
        }
    }
    return sum
}
```



```c []
// é€’å½’æ³•ï¼š
int sumOfLeftLeaves(struct TreeNode* root){
    // é€’å½’ç»“æŸæ¡ä»¶ï¼šè‹¥å½“å‰ç»“ç‚¹ä¸ºç©ºï¼Œè¿”å›0
    if(!root)
        return 0;
    
    // é€’å½’å–å·¦å­æ ‘çš„å·¦ç»“ç‚¹å’Œå’Œå³å­æ ‘çš„å·¦ç»“ç‚¹å’Œ
    int leftValue = sumOfLeftLeaves(root->left);
    int rightValue = sumOfLeftLeaves(root->right);

    // è‹¥å½“å‰ç»“ç‚¹çš„å·¦ç»“ç‚¹å­˜åœ¨ï¼Œä¸”å…¶ä¸ºå¶å­ç»“ç‚¹ã€‚å–å®ƒçš„å€¼
    int midValue = 0;
    if(root->left && (!root->left->left && !root->left->right))
        midValue = root->left->val;
    
    return leftValue + rightValue + midValue;
}

// è¿­ä»£æ³•:
int sumOfLeftLeaves(struct TreeNode* root){
    struct TreeNode* stack[1000];
    int stackTop = 0;

    // è‹¥ä¼ å…¥rootç»“ç‚¹ä¸ä¸ºç©ºï¼Œå°†å…¶å…¥æ ˆ
    if(root)
        stack[stackTop++] = root;
    
    int sum = 0;
    //è‹¥æ ˆä¸ä¸ºç©ºï¼Œè¿›è¡Œå¾ªç¯
    while(stackTop) {
        // å‡ºæ ˆæ ˆé¡¶å…ƒç´ 
        struct TreeNode *topNode = stack[--stackTop];
        // è‹¥æ ˆé¡¶å…ƒç´ çš„å·¦***ä¸ºå·¦å¶å­ç»“ç‚¹ï¼Œå°†å…¶å€¼åŠ å…¥sumä¸­
        if(topNode->left && (!topNode->left->left && !topNode->left->right))
            sum += topNode->left->val;
        
        // è‹¥å½“å‰æ ˆé¡¶ç»“ç‚¹æœ‰å·¦å³***ã€‚å°†ä»–ä»¬åŠ å…¥æ ˆä¸­è¿›è¡Œéå†
        if(topNode->right)
            stack[stackTop++] = topNode->right;
        if(topNode->left)
            stack[stackTop++] = topNode->left;
    }
    return sum;
}
```



```scala []
// **é€’å½’:**
object Solution {
  def sumOfLeftLeaves(root: TreeNode): Int = {
    if(root == null) return 0
    var midValue = 0
    if(root.left != null && root.left.left == null && root.left.right == null){
      midValue = root.left.value
    }
    // returnå…³é”®å­—å¯ä»¥çœç•¥
    midValue + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)
  }
}

// **è¿­ä»£:**
object Solution {
  import scala.collection.mutable
  def sumOfLeftLeaves(root: TreeNode): Int = {
    val stack = mutable.Stack[TreeNode]()
    if (root == null) return 0
    stack.push(root)
    var sum = 0
    while (!stack.isEmpty) {
      val curNode = stack.pop()
      if (curNode.left != null && curNode.left.left == null && curNode.left.right == null) {
        sum += curNode.left.value // å¦‚æœæ»¡è¶³æ¡ä»¶å°±ç´¯åŠ 
      }
      if (curNode.right != null) stack.push(curNode.right)
      if (curNode.left != null) stack.push(curNode.left)
    }
    sum
  }
}
```


# äºŒå‰æ ‘åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ äºŒå‰æ ‘çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚ä»¥ä¸‹æ¯é“é¢˜ç›®åœ¨åŠ›æ‰£é¢˜è§£åŒºéƒ½æœ‰ã€Œä»£ç éšæƒ³å½•ã€çš„é¢˜è§£ã€‚å¯¼å›¾åœ¨[Github:leetcode-master](https://github.com/youngyangyang04/leetcode-master)


![image.png](https://pic.leetcode-cn.com/1625557068-rTzCSW-image.png){:width="450px"}{:align="center"}


------------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼



**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**
