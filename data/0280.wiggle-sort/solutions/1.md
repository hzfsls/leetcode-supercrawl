## [280.摆动排序 中文热门题解1](https://leetcode.cn/problems/wiggle-sort/solutions/100000/yong-ding-lu-lai-shuo-ming-wei-shi-yao-ke-yi-zhe-y)

作者：[xue-bu-wan-bu-gai-ming](https://leetcode.cn/u/xue-bu-wan-bu-gai-ming)
**知其然还要知其所以然**

先上我的第一份代码:
**解法一**
```
class Solution {
public:
    void wiggleSort(vector<int>& n) {
        vector<int> cp(n);
        sort(cp.begin(), cp.end());
        for (int b{}, e = cp.size()-1, i{}; i < cp.size(); ++i) {
            n[i] = cp[!(i&1) ? b++ : e--];
        }
    }
};
```
我看完题第一反应就是直接一小一大排列, 不做任何加工会不会有什么问题? 于是我干脆第一个放最小的 第二个放最大的
这样能保证最小的后面一定有至少一个比他大的 最大的后面也有比他小的存在
**本质就是一个排好序的序列比如1 2 3 4 5 6, 我第一个放1 第二个放6 然后再2 再5这样从两端向中间汇聚** 一定能保证后面有数可选 并且达到题目要求 这是我最原始的想法

而看了题解后 发现能直接在需要替换的地方替换 比如偶数位一定要小于右边的一位 奇数位一定要大于右边的一位 这样一小一大一小一大 有`n`个数 就有`n-1`个这样的关系 单最后一位不用向右看了 只需要满足和前面一位的关系了.
我觉得很疑惑 为什么可以直接换? **难道不会与前面换好的数产生冲突么?** 比如我先换了两个数abc为bac 可能需要再把ac交换 这相当于产生了新的关系与前面的 不会又不满足前面的关系了么 实际上我的担心是多余的 因为:

**定律** `在连续多项非等于关系中 第一个总是大于或小于后面所有的项.`

证明是显而易见的. 其实也就是说比如`a<b<c<d<..` 那么`a`一定小于后面所有的项 大于关系同理. 那么这个定律有什么用呢 就是说 后面的项你不管怎么交换顺序 第一个数比如`a`一定还是**大于或小于**后面的数的 不会因为你交换了它们就不成立了 比如`1<2<3` 你交换成`1<3>2` 那么3 2 必定也是小于1的啊!
这就是这题的关键 这题解法能成立的`充足理由律`
因为当遇到`1<2<3`时 你换位`1<3>2`同样不会与前面产生矛盾 并且符合题意 同样地 `3>2>1`你需要换成`3>1<2`时 后面的1 2 还是小于3的 所以就是说 这题你只要放心大胆替换就行了 不必担心会产生矛盾. 下面是C++代码:
**解法二**
```
class Solution {
public:
    void wiggleSort(vector<int>& n) {
        for (int i{}; i < (int)n.size()-1; ++i) {
            if ((i&1) == n[i] < n[i+1]) swap(n[i], n[i+1]);
        }
    }
};
```
实际上在处于数列偶数位时与后面数大小关系有两种(等于关系不用考虑 直接归为大于或小于关系皆可) 处于奇数位时与后面数大小关系也有两种 **而你只需要在偶数位时与后面数为大于关系时 交换它们** 或 **在奇数位时与后面数为小于关系时 再交换它们** 那么就ok了 于是可以合并为两个情况(奇偶数位和大于小于关系某两项同时成立) **当奇数位时一定伴随着此数小于后面或当非奇数位时(偶数位)此数一定不小于(即大于等于)后数** 也就是逻辑等价号`==` 同真为真 同假也为真 刚好一次性涵盖了两种情况 可以见我这个解释:
![image.png](https://pic.leetcode-cn.com/352e2df18940fc03f266801a5bcbf739a24da96bfeb60113760318632a4919d1-image.png)

[官方题解留言区](https://leetcode-cn.com/problems/wiggle-sort/solution/bai-dong-pai-xu-by-leetcode/)

最后是先排序再奇数位直接换的算法 注意最后位只能到`sz-2` 因为需要 **"右看"** 一下元素 并且这样对于奇数个数或偶数个数都不会漏掉 同时注意吧`sz`类型转为int 因为unsinged类型0减1后变为最大值了 这样再进入循环会内存访问非法.
**解法三**
```
class Solution {
public:
    void wiggleSort(vector<int>& n) {
        sort(n.begin(), n.end());
        for (int i{1}; i < (int)n.size()-1; i += 2) {
            swap(n[i], n[i+1]);
        }
    }
};
```
