## [90.å­é›† II ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/subsets-ii/solutions/100000/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)
# ç®—æ³•å…¬å¼€è¯¾

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[å›æº¯ç®—æ³•è§£å†³å­é›†é—®é¢˜ï¼Œå¦‚ä½•å»é‡ï¼Ÿ| LeetCodeï¼š90.å­é›†II](https://www.bilibili.com/video/BV1vm4y1F71J/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚


## æ€è·¯

åšæœ¬é¢˜ä¹‹å‰ä¸€å®šè¦å…ˆåš[78.å­é›†](https://programmercarl.com/0078.å­é›†.html)ã€‚

è¿™é“é¢˜ç›®å’Œ[78.å­é›†](https://programmercarl.com/0078.å­é›†.html)åŒºåˆ«å°±æ˜¯é›†åˆé‡Œæœ‰é‡å¤å…ƒç´ äº†ï¼Œè€Œä¸”æ±‚å–çš„å­é›†è¦å»é‡ã€‚

é‚£ä¹ˆå…³äºå›æº¯ç®—æ³•ä¸­çš„å»é‡é—®é¢˜ï¼Œ**åœ¨[40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)ä¸­å·²ç»è¯¦ç»†è®²è§£è¿‡äº†ï¼Œå’Œæœ¬é¢˜æ˜¯ä¸€ä¸ªå¥—è·¯**ã€‚

**å‰§é€ä¸€ä¸‹ï¼ŒåæœŸè¦è®²è§£çš„æ’åˆ—é—®é¢˜é‡Œå»é‡ä¹Ÿæ˜¯è¿™ä¸ªå¥—è·¯ï¼Œæ‰€ä»¥ç†è§£â€œæ ‘å±‚å»é‡â€å’Œâ€œæ ‘æå»é‡â€éå¸¸é‡è¦**ã€‚

ç”¨ç¤ºä¾‹ä¸­çš„[1, 2, 2] æ¥ä¸¾ä¾‹ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š ï¼ˆ**æ³¨æ„å»é‡éœ€è¦å…ˆå¯¹é›†åˆæ’åº**ï¼‰



![image.png](https://pic.leetcode.cn/1674874725-XYWjam-image.png)


ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼ŒåŒä¸€æ ‘å±‚ä¸Šé‡å¤å–2 å°±è¦è¿‡æ»¤æ‰ï¼ŒåŒä¸€æ ‘æä¸Šå°±å¯ä»¥é‡å¤å–2ï¼Œå› ä¸ºåŒä¸€æ ‘æä¸Šå…ƒç´ çš„é›†åˆæ‰æ˜¯å”¯ä¸€å­é›†ï¼

æœ¬é¢˜å°±æ˜¯å…¶å®å°±æ˜¯[å›æº¯ç®—æ³•ï¼šæ±‚å­é›†é—®é¢˜ï¼](https://programmercarl.com/0078.å­é›†.html)çš„åŸºç¡€ä¸ŠåŠ ä¸Šäº†å»é‡ï¼Œå»é‡æˆ‘ä»¬åœ¨[å›æº¯ç®—æ³•ï¼šæ±‚ç»„åˆæ€»å’Œï¼ˆä¸‰ï¼‰](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)ä¹Ÿè®²è¿‡äº†ï¼Œæ‰€ä»¥æˆ‘å°±ç›´æ¥ç»™å‡ºä»£ç äº†ï¼š

C++ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == trueï¼Œè¯´æ˜åŒä¸€æ ‘æcandidates[i - 1]ä½¿ç”¨è¿‡
            // used[i - 1] == falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚candidates[i - 1]ä½¿ç”¨è¿‡
            // è€Œæˆ‘ä»¬è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // å»é‡éœ€è¦æ’åº
        backtracking(nums, 0, used);
        return result;
    }
};
```

ä½¿ç”¨setå»é‡çš„ç‰ˆæœ¬ã€‚
```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // å»é‡éœ€è¦æ’åº
        backtracking(nums, 0);
        return result;
    }
};
```

## è¡¥å……

æœ¬é¢˜ä¹Ÿå¯ä»¥ä¸ä½¿ç”¨usedæ•°ç»„æ¥å»é‡ï¼Œå› ä¸ºé€’å½’çš„æ—¶å€™ä¸‹ä¸€ä¸ªstartIndexæ˜¯i+1è€Œä¸æ˜¯0ã€‚

å¦‚æœè¦æ˜¯å…¨æ’åˆ—çš„è¯ï¼Œæ¯æ¬¡è¦ä»0å¼€å§‹éå†ï¼Œä¸ºäº†è·³è¿‡å·²å…¥æ ˆçš„å…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨usedã€‚

ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // è€Œæˆ‘ä»¬è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
            if (i > startIndex && nums[i] == nums[i - 1] ) { // æ³¨æ„è¿™é‡Œä½¿ç”¨i > startIndex
                continue;
            }
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // å»é‡éœ€è¦æ’åº
        backtracking(nums, 0);
        return result;
    }
};
```

## æ€»ç»“

å…¶å®è¿™é“é¢˜ç›®çš„çŸ¥è¯†ç‚¹ï¼Œæˆ‘ä»¬ä¹‹å‰éƒ½è®²è¿‡äº†ï¼Œå¦‚æœä¹‹å‰è®²è¿‡çš„å­é›†é—®é¢˜å’Œå»é‡é—®é¢˜éƒ½æŒæ¡çš„å¥½ï¼Œè¿™é“é¢˜ç›®åº”è¯¥åˆ†åˆ†é’ŸACã€‚

å½“ç„¶æœ¬é¢˜å»é‡çš„é€»è¾‘ï¼Œä¹Ÿå¯ä»¥è¿™ä¹ˆå†™

```cpp
if (i > startIndex && nums[i] == nums[i - 1] ) {
	continue;
}
```

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬


```java []
// ä½¿ç”¨usedæ•°ç»„
class Solution {
   List<List<Integer>> result = new ArrayList<>();// å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœçš„é›†åˆ
   LinkedList<Integer> path = new LinkedList<>();// ç”¨æ¥å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœ
   boolean[] used;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if (nums.length == 0){
            result.add(path);
            return result;
        }
        Arrays.sort(nums);
        used = new boolean[nums.length];
        subsetsWithDupHelper(nums, 0);
        return result;
    }
    
    private void subsetsWithDupHelper(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length){
            return;
        }
        for (int i = startIndex; i < nums.length; i++){
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            subsetsWithDupHelper(nums, i + 1);
            path.removeLast();
            used[i] = false;
        }
    }
}

// ä¸ä½¿ç”¨usedæ•°ç»„
class Solution {

  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  
  public List<List<Integer>> subsetsWithDup( int[] nums ) {
    Arrays.sort( nums );
    subsetsWithDupHelper( nums, 0 );
    return res;
  }


  private void subsetsWithDupHelper( int[] nums, int start ) {
    res.add( new ArrayList<>( path ) );

    for ( int i = start; i < nums.length; i++ ) {
        // è·³è¿‡å½“å‰æ ‘å±‚ä½¿ç”¨è¿‡çš„ã€ç›¸åŒçš„å…ƒç´ 
      if ( i > start && nums[i - 1] == nums[i] ) {
        continue;
      }
      path.add( nums[i] );
      subsetsWithDupHelper( nums, i + 1 );
      path.removeLast();
    }
  }

}
```

```python []
class Solution:
    def __init__(self):
        self.paths = []
        self.path = []

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        self.backtracking(nums, 0)
        return self.paths

    def backtracking(self, nums: List[int], start_index: int) -> None:
        # ps.ç©ºé›†åˆä»ç¬¦åˆè¦æ±‚
        self.paths.append(self.path[:])
        # Base Case
        if start_index == len(nums):
            return
        
        # å•å±‚é€’å½’é€»è¾‘
        for i in range(start_index, len(nums)):
            if i > start_index and nums[i] == nums[i-1]:
                # å½“å‰åå…ƒç´ å€¼ç›¸åŒæ—¶ï¼Œè·³å…¥ä¸‹ä¸€ä¸ªå¾ªç¯ï¼Œå»é‡
                continue
            self.path.append(nums[i])
            self.backtracking(nums, i+1)
            self.path.pop()

# ä¸ä½¿ç”¨usedæ•°ç»„
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        nums.sort() # å»é‡éœ€è¦å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åº

        def backtracking(nums, startIndex):
            # ç»ˆæ­¢æ¡ä»¶
            res.append(path[:])
            if startIndex == len(nums):
                return
            
            # forå¾ªç¯
            for i in range(startIndex, len(nums)):
                # æ•°å±‚å»é‡
                if i > startIndex and nums[i] == nums[i-1]: # å»é‡
                    continue
                path.append(nums[i])
                backtracking(nums, i+1)
                path.pop()
        
        backtracking(nums, 0)
        return res

# ä½¿ç”¨usedæ•°ç»„
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        result = []
        path = []
        nums.sort()
        used = [0] * len(nums)
        def backtrack(nums, startIdx):
            result.append(path[:])
            for i in range(startIdx, len(nums)):
                if i > startIdx and nums[i] == nums[i-1] and used[i-1] == 0:
                    continue
                used[i] = 1
                path.append(nums[i])
                backtrack(nums, i+1)
                path.pop()
                used[i] = 0
        backtrack(nums, 0)
        return result
```


```Go []
var (
    path   []int
    res  [][]int
)
func subsetsWithDup(nums []int) [][]int {
    path, res = make([]int, 0, len(nums)), make([][]int, 0)
    sort.Ints(nums)
    dfs(nums, 0)
    return res
}

func dfs(nums []int, start int) {
    tmp := make([]int, len(path))
    copy(tmp, path)
    res = append(res, tmp)

    for i := start; i < len(nums); i++ {
        if i != start && nums[i] == nums[i-1] {
            continue
        }
        path = append(path, nums[i])
        dfs(nums, i+1)
        path = path[:len(path)-1]
    }
}
```

```Javascript []

var subsetsWithDup = function(nums) {
    let result = []
    let path = []
    let sortNums = nums.sort((a, b) => {
        return a - b
    })
    function backtracing(startIndex, sortNums) {
        result.push([...path])
        if(startIndex > nums.length - 1) {
            return
        }
        for(let i = startIndex; i < nums.length; i++) {
            if(i > startIndex && nums[i] === nums[i - 1]) {
                continue
            }
            path.push(nums[i])
            backtracing(i + 1, sortNums)
            path.pop()
        }
    }
    backtracing(0, sortNums)
    return result
};

```


```typescript []
function subsetsWithDup(nums: number[]): number[][] {
    nums.sort((a, b) => a - b);
    const resArr: number[][] = [];
    backTraking(nums, 0, []);
    return resArr;
    function backTraking(nums: number[], startIndex: number, route: number[]): void {
        resArr.push([...route]);
        let length: number = nums.length;
        if (startIndex === length) return;
        for (let i = startIndex; i < length; i++) {
            if (i > startIndex && nums[i] === nums[i - 1]) continue;
            route.push(nums[i]);
            backTraking(nums, i + 1, route);
            route.pop();
        }
    }
};

// ä½¿ç”¨setå»é‡ç‰ˆæœ¬
function subsetsWithDup(nums: number[]): number[][] {
    const result: number[][] = [];
    const path: number[] = [];
    // å»é‡ä¹‹å‰å…ˆæ’åº
    nums.sort((a, b) => a - b);
    function backTracking(startIndex: number) {
        // æ”¶é›†ç»“æœ
        result.push([...path])
        // æ­¤å¤„ä¸è¿”å›ä¹Ÿå¯ä»¥å› ä¸ºï¼Œæ¯æ¬¡é€’å½’éƒ½ä¼šä½¿startIndex + 1ï¼Œå½“è¿™ä¸ªæ•°å¤§åˆ°nums.lengthçš„æ—¶å€™å°±ä¸ä¼šè¿›å…¥é€’å½’äº†ã€‚
        if (startIndex === nums.length) {
            return
        }
        // å®šä¹‰æ¯ä¸€ä¸ªæ ‘å±‚çš„seté›†åˆ
        const set: Set<number> = new Set()
        for (let i = startIndex; i < nums.length; i++) {
            // å»é‡
            if (set.has(nums[i])) {
                continue
            }
            set.add(nums[i])
            path.push(nums[i])
            backTracking(i + 1)
            // å›æº¯
            path.pop()
        }
    }
    backTracking(0)
    return result
};
```

```Rust []
impl Solution {
    fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, nums: &Vec<i32>, start_index: usize, used: &mut Vec<bool>) {
        result.push(path.clone());
        let len = nums.len();
        // if start_index >= len { return; }
        for i in start_index..len {
            if i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false { continue; }
            path.push(nums[i]);
            used[i] = true;
            Self::backtracking(result, path, nums, i + 1, used);
            used[i] = false;
            path.pop();
        }
    }

    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        let mut used = vec![false; nums.len()];
        let mut nums = nums;
        nums.sort();
        Self::backtracking(&mut result, &mut path, &nums, 0, &mut used);
        result
    }
}
```


```c []
int* path;
int pathTop;
int** ans;
int ansTop;
//è´Ÿè´£å­˜æ”¾äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªæ•°ç»„çš„é•¿åº¦
int* lengths;
//å¿«æ’cmpå‡½æ•°
int cmp(const void* a, const void* b) {
    return *((int*)a) - *((int*)b);
}

//å¤åˆ¶å‡½æ•°ï¼Œå°†å½“å‰pathä¸­çš„å…ƒç´ å¤åˆ¶åˆ°ansä¸­ã€‚åŒæ—¶è®°å½•pathé•¿åº¦
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    ans = (int**)realloc(ans, sizeof(int*) * (ansTop + 1));
    lengths[ansTop] = pathTop;
    ans[ansTop++] = tempPath;
}

void backTracking(int* nums, int numsSize, int startIndex, int* used) {
    //é¦–å…ˆå°†å½“å‰pathå¤åˆ¶
    copy();
    //è‹¥startIndexå¤§äºæ•°ç»„æœ€åä¸€ä½å…ƒç´ çš„ä½ç½®ï¼Œè¿”å›
    if(startIndex >= numsSize)
        return ;
    
    int i;
    for(i = startIndex; i < numsSize; i++) {
        //å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
        if(i > 0 && nums[i] ==  nums[i-1] && used[i-1] == false) 
            continue;
        path[pathTop++] = nums[i];
        used[i] = true;
        backTracking(nums, numsSize, i + 1, used);
        used[i] = false;
        pathTop--;
    }
}

int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //å£°æ˜è¾…åŠ©å˜é‡
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(0);
    lengths = (int*)malloc(sizeof(int) * 1500);
    int* used = (int*)malloc(sizeof(int) * numsSize);
    pathTop = ansTop = 0;

    //æ’åºåæŸ¥é‡æ‰èƒ½ç”Ÿæ•ˆ
    qsort(nums, numsSize, sizeof(int), cmp);
    backTracking(nums, numsSize, 0, used);

    //è®¾ç½®ä¸€ç»´æ•°ç»„å’ŒäºŒç»´æ•°ç»„çš„è¿”å›å¤§å°
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = lengths[i];
    }
    return ans;
}
```

```swift []
func subsetsWithDup(_ nums: [Int]) -> [[Int]] {
    let nums = nums.sorted()
    var result = [[Int]]()
    var path = [Int]()
    func backtracking(startIndex: Int) {
        // ç›´æ¥æ”¶é›†ç»“æœ
        result.append(path)

        let end = nums.count
        guard startIndex < end else { return } // ç»ˆæ­¢æ¡ä»¶
        for i in startIndex ..< end {
            if i > startIndex, nums[i] == nums[i - 1] { continue } // è·³è¿‡é‡å¤å…ƒç´ 
            path.append(nums[i]) // å¤„ç†ï¼šæ”¶é›†å…ƒç´ 
            backtracking(startIndex: i + 1) // å…ƒç´ ä¸é‡å¤è®¿é—®
            path.removeLast() // å›æº¯
        }
    }
    backtracking(startIndex: 0)
    return result
}
```



```scala []
// ä¸ä½¿ç”¨usedæ•°ç»„:
object Solution {
  import scala.collection.mutable
  def subsetsWithDup(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()
    var num = nums.sorted // æ’åº

    def backtracking(startIndex: Int): Unit = {
      result.append(path.toList)
      if (startIndex >= num.size){
        return
      }
      for (i <- startIndex until num.size) {
        // åŒä¸€æ ‘å±‚é‡å¤çš„å…ƒç´ ä¸è¿›å…¥å›æº¯
        if (!(i > startIndex && num(i) == num(i - 1))) {
          path.append(num(i))
          backtracking(i + 1)
          path.remove(path.size - 1)
        }
      }
    }

    backtracking(0)
    result.toList
  }
}

// ä½¿ç”¨Setå»é‡:
object Solution {
  import scala.collection.mutable
  def subsetsWithDup(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.Set[List[Int]]()
    var num = nums.sorted
    def backtracking(path: mutable.ListBuffer[Int], startIndex: Int): Unit = {
      if (startIndex == num.length) {
        result.add(path.toList)
        return
      }
      path.append(num(startIndex))
      backtracking(path, startIndex + 1)  // é€‰æ‹©
      path.remove(path.size - 1)
      backtracking(path, startIndex + 1)  // ä¸é€‰æ‹©
    }

    backtracking(mutable.ListBuffer[Int](), 0)

    result.toList
  }
}
``` 

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
    * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
    * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
    * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
    * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
    * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
    * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
    * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜ 
    * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
    * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
    * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
    * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
    * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
    * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»– 
    * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
    * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

-----------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

