## [1023.é©¼å³°å¼åŒ¹é… ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/camelcase-matching/solutions/100000/python3javacgotypescript-yi-ti-yi-jie-sh-vr5x)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)


**æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆ**

æˆ‘ä»¬å¯ä»¥éå† `queries` ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å…¶æ˜¯å¦ä¸ `pattern` åŒ¹é…ï¼Œè‹¥åŒ¹é…åˆ™å°† `true` åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œå¦åˆ™åŠ å…¥ `false`ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®ç°ä¸€ä¸ª $check(s, t)$ å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­å­—ç¬¦ä¸² $s$ å’Œ $t$ æ˜¯å¦åŒ¹é…ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆ $i$ å’Œ $j$ï¼Œåˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é¦–å­—ç¬¦ï¼Œç„¶åéå†ä¸¤ä¸ªå­—ç¬¦ä¸²ã€‚å¦‚æœæŒ‡é’ˆ $i$ å’Œ $j$ æŒ‡å‘çš„å­—ç¬¦ä¸åŒï¼Œå¹¶ä¸” $s[i]$ ä¸ºå°å†™å­—æ¯ï¼Œåˆ™æŒ‡é’ˆ $i$ å¾ªç¯å‘åç§»åŠ¨ä¸€ä½ã€‚

å¦‚æœæŒ‡é’ˆ $i$ å·²ç»åˆ°è¾¾å­—ç¬¦ä¸² $s$ çš„æœ«å°¾ï¼Œæˆ–è€…æŒ‡é’ˆ $i$ å’Œ $j$ æŒ‡å‘çš„å­—ç¬¦ä¸åŒï¼Œåˆ™è¿”å› `false`ã€‚å¦åˆ™ï¼ŒæŒ‡é’ˆ $i$ å’Œ $j$ åŒæ—¶å‘åç§»åŠ¨ä¸€ä½ã€‚å½“æŒ‡é’ˆ $j$ åˆ°è¾¾å­—ç¬¦ä¸² $t$ çš„æœ«å°¾æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­å­—ç¬¦ä¸² $s$ ä¸­å‰©ä½™çš„å­—ç¬¦æ˜¯å¦éƒ½ä¸ºå°å†™å­—æ¯ï¼Œè‹¥æ˜¯åˆ™è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚



```python [sol1-Python3]
class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        def check(s, t):
            m, n = len(s), len(t)
            i = j = 0
            while j < n:
                while i < m and s[i] != t[j] and s[i].islower():
                    i += 1
                if i == m or s[i] != t[j]:
                    return False
                i, j = i + 1, j + 1
            while i < m and s[i].islower():
                i += 1
            return i == m

        return [check(q, pattern) for q in queries]
```



```java [sol1-Java]
class Solution {
    public List<Boolean> camelMatch(String[] queries, String pattern) {
        List<Boolean> ans = new ArrayList<>();
        for (var q : queries) {
            ans.add(check(q, pattern));
        }
        return ans;
    }

    private boolean check(String s, String t) {
        int m = s.length(), n = t.length();
        int i = 0, j = 0;
        for (; j < n; ++i, ++j) {
            while (i < m && s.charAt(i) != t.charAt(j) && Character.isLowerCase(s.charAt(i))) {
                ++i;
            }
            if (i == m || s.charAt(i) != t.charAt(j)) {
                return false;
            }
        }
        while (i < m && Character.isLowerCase(s.charAt(i))) {
            ++i;
        }
        return i == m;
    }
}
```


```cpp [sol1-C++]
class Solution {
public:
    vector<bool> camelMatch(vector<string>& queries, string pattern) {
        vector<bool> ans;
        auto check = [](string& s, string& t) {
            int m = s.size(), n = t.size();
            int i = 0, j = 0;
            for (; j < n; ++i, ++j) {
                while (i < m && s[i] != t[j] && islower(s[i])) {
                    ++i;
                }
                if (i == m || s[i] != t[j]) {
                    return false;
                }
            }
            while (i < m && islower(s[i])) {
                ++i;
            }
            return i == m;
        };
        for (auto& q : queries) {
            ans.push_back(check(q, pattern));
        }
        return ans;
    }
};
```


```go [sol1-Go]
func camelMatch(queries []string, pattern string) (ans []bool) {
	check := func(s, t string) bool {
		m, n := len(s), len(t)
		i, j := 0, 0
		for ; j < n; i, j = i+1, j+1 {
			for i < m && s[i] != t[j] && (s[i] >= 'a' && s[i] <= 'z') {
				i++
			}
			if i == m || s[i] != t[j] {
				return false
			}
		}
		for i < m && s[i] >= 'a' && s[i] <= 'z' {
			i++
		}
		return i == m
	}
	for _, q := range queries {
		ans = append(ans, check(q, pattern))
	}
	return
}
```



```ts [sol1-TypeScript]
function camelMatch(queries: string[], pattern: string): boolean[] {
    const check = (s: string, t: string) => {
        const m = s.length;
        const n = t.length;
        let i = 0;
        let j = 0;
        for (; j < n; ++i, ++j) {
            while (i < m && s[i] !== t[j] && s[i].codePointAt(0) >= 97) {
                ++i;
            }
            if (i === m || s[i] !== t[j]) {
                return false;
            }
        }
        while (i < m && s[i].codePointAt(0) >= 97) {
            ++i;
        }
        return i == m;
    };
    const ans: boolean[] = [];
    for (const q of queries) {
        ans.push(check(q, pattern));
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $(n \times m)$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸ºæ•°ç»„ `queries` çš„é•¿åº¦å’Œå­—ç¬¦ä¸² `pattern` çš„é•¿åº¦ã€‚


---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~