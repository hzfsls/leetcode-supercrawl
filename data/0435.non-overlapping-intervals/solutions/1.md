## [435.æ— é‡å åŒºé—´ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/non-overlapping-intervals/solutions/100000/435-wu-zhong-die-qu-jian-tan-xin-jing-di-qze0)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)
**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[è´ªå¿ƒç®—æ³•ï¼Œä¾ç„¶æ˜¯åˆ¤æ–­é‡å åŒºé—´ | LeetCodeï¼š435.æ— é‡å åŒºé—´](https://www.bilibili.com/video/BV1A14y1c7E1)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘åœ¨çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

## æ€è·¯

**ç›¸ä¿¡å¾ˆå¤šåŒå­¦çœ‹åˆ°è¿™é“é¢˜ç›®éƒ½å†¥å†¥ä¹‹ä¸­æ„Ÿè§‰è¦æ’åºï¼Œä½†æ˜¯ç©¶ç«Ÿæ˜¯æŒ‰ç…§å³è¾¹ç•Œæ’åºï¼Œè¿˜æ˜¯æŒ‰ç…§å·¦è¾¹ç•Œæ’åºå‘¢ï¼Ÿ**

å…¶å®éƒ½å¯ä»¥ã€‚ä¸»è¦å°±æ˜¯ä¸ºäº†è®©åŒºé—´å°½å¯èƒ½çš„é‡å ã€‚ 

**æˆ‘æ¥æŒ‰ç…§å³è¾¹ç•Œæ’åºï¼Œä»å·¦å‘å³è®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°ã€‚æœ€åç”¨åŒºé—´æ€»æ•°å‡å»éäº¤å‰åŒºé—´çš„ä¸ªæ•°å°±æ˜¯éœ€è¦ç§»é™¤çš„åŒºé—´ä¸ªæ•°äº†**ã€‚

æ­¤æ—¶é—®é¢˜å°±æ˜¯è¦æ±‚éäº¤å‰åŒºé—´çš„æœ€å¤§ä¸ªæ•°ã€‚

è¿™é‡Œè®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°è¿˜æ˜¯æœ‰æŠ€å·§çš„ï¼Œå¦‚å›¾ï¼š



![image.png](https://pic.leetcode.cn/1683277001-kXMrWT-image.png)


åŒºé—´ï¼Œ1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6éƒ½æŒ‰ç…§å³è¾¹ç•Œæ’å¥½åºã€‚

å½“ç¡®å®šåŒºé—´ 1 å’Œ åŒºé—´2 é‡å åï¼Œå¦‚ä½•ç¡®å®šæ˜¯å¦ä¸ åŒºé—´3 ä¹Ÿé‡è´´å‘¢ï¼Ÿ 

å°±æ˜¯å– åŒºé—´1 å’Œ åŒºé—´2 å³è¾¹ç•Œçš„æœ€å°å€¼ï¼Œå› ä¸ºè¿™ä¸ªæœ€å°å€¼ä¹‹å‰çš„éƒ¨åˆ†ä¸€å®šæ˜¯ åŒºé—´1 å’ŒåŒºé—´2 çš„é‡åˆéƒ¨åˆ†ï¼Œå¦‚æœè¿™ä¸ªæœ€å°å€¼ä¹Ÿè§¦è¾¾åˆ°åŒºé—´3ï¼Œé‚£ä¹ˆè¯´æ˜ åŒºé—´ 1ï¼Œ2ï¼Œ3éƒ½æ˜¯é‡åˆçš„ã€‚ 

æ¥ä¸‹æ¥å°±æ˜¯æ‰¾å¤§äºåŒºé—´1ç»“æŸä½ç½®çš„åŒºé—´ï¼Œæ˜¯ä»åŒºé—´4å¼€å§‹ã€‚**é‚£æœ‰åŒå­¦é—®äº†ä¸ºä»€ä¹ˆä¸ä»åŒºé—´5å¼€å§‹ï¼Ÿåˆ«å¿˜äº†å·²ç»æ˜¯æŒ‰ç…§å³è¾¹ç•Œæ’åºçš„äº†**ã€‚

åŒºé—´4ç»“æŸä¹‹åï¼Œå†æ‰¾åˆ°åŒºé—´6ï¼Œæ‰€ä»¥ä¸€å…±è®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°æ˜¯ä¸‰ä¸ªã€‚

æ€»å…±åŒºé—´ä¸ªæ•°ä¸º6ï¼Œå‡å»éäº¤å‰åŒºé—´çš„ä¸ªæ•°3ã€‚ç§»é™¤åŒºé—´çš„æœ€å°æ•°é‡å°±æ˜¯3ã€‚

C++ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    // æŒ‰ç…§åŒºé—´å³è¾¹ç•Œæ’åº
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1; // è®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°
        int end = intervals[0][1]; // è®°å½•åŒºé—´åˆ†å‰²ç‚¹
        for (int i = 1; i < intervals.size(); i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šO(nlog n) ï¼Œæœ‰ä¸€ä¸ªå¿«æ’
* ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œæœ‰ä¸€ä¸ªå¿«æ’ï¼Œæœ€å·®æƒ…å†µ(å€’åº)æ—¶ï¼Œéœ€è¦næ¬¡é€’å½’è°ƒç”¨ã€‚å› æ­¤ç¡®å®éœ€è¦O(n)çš„æ ˆç©ºé—´

å¤§å®¶æ­¤æ—¶ä¼šå‘ç°å¦‚æ­¤å¤æ‚çš„ä¸€ä¸ªé—®é¢˜ï¼Œä»£ç å®ç°å´è¿™ä¹ˆç®€å•ï¼



## è¡¥å……ï¼ˆ1ï¼‰

å·¦è¾¹ç•Œæ’åºå¯ä¸å¯ä»¥å‘¢ï¼Ÿ 

ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œåªä¸è¿‡ å·¦è¾¹ç•Œæ’åºæˆ‘ä»¬å°±æ˜¯ç›´æ¥æ±‚ é‡å çš„åŒºé—´ï¼Œcountä¸ºè®°å½•é‡å åŒºé—´æ•°ã€‚

```CPP 
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0]; // æ”¹ä¸ºå·¦è¾¹ç•Œæ’åº
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 0; // æ³¨æ„è¿™é‡Œä»0å¼€å§‹ï¼Œå› ä¸ºæ˜¯è®°å½•é‡å åŒºé—´
        int end = intervals[0][1]; // è®°å½•åŒºé—´åˆ†å‰²ç‚¹
        for (int i = 1; i < intervals.size(); i++) {   
            if (intervals[i][0] >= end)  end = intervals[i][1]; // æ— é‡å çš„æƒ…å†µ
            else { // é‡å æƒ…å†µ 
                end = min(end, intervals[i][1]);
                count++;
            }
        }
        return count;
    }
};
```

å…¶å®ä»£ç è¿˜å¯ä»¥ç²¾ç®€ä¸€ä¸‹ï¼Œ ç”¨ intervals[i][1] æ›¿ä»£ endå˜é‡ï¼Œåªåˆ¤æ–­ é‡å æƒ…å†µå°±å¥½

```CPP 
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0]; // æ”¹ä¸ºå·¦è¾¹ç•Œæ’åº
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 0; // æ³¨æ„è¿™é‡Œä»0å¼€å§‹ï¼Œå› ä¸ºæ˜¯è®°å½•é‡å åŒºé—´
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] < intervals[i - 1][1]) { //é‡å æƒ…å†µ
                intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]);
                count++;
            }
        }
        return count;
    }
};

```

## è¡¥å……ï¼ˆ2ï¼‰

æœ¬é¢˜å…¶å®å’Œ[452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ](https://programmercarl.com/0452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ.html)éå¸¸åƒï¼Œå¼“ç®­çš„æ•°é‡å°±ç›¸å½“äºæ˜¯éäº¤å‰åŒºé—´çš„æ•°é‡ï¼Œåªè¦æŠŠå¼“ç®­é‚£é“é¢˜ç›®ä»£ç é‡Œå°„çˆ†æ°”çƒçš„åˆ¤æ–­æ¡ä»¶åŠ ä¸ªç­‰å·ï¼ˆè®¤ä¸º[0ï¼Œ1][1ï¼Œ2]ä¸æ˜¯ç›¸é‚»åŒºé—´ï¼‰ï¼Œç„¶åç”¨æ€»åŒºé—´æ•°å‡å»å¼“ç®­æ•°é‡ å°±æ˜¯è¦ç§»é™¤çš„åŒºé—´æ•°é‡äº†ã€‚

æŠŠ[452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ](https://programmercarl.com/0452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ.html)ä»£ç ç¨åšä¿®æ”¹ï¼Œå°±å¯ä»¥ACæœ¬é¢˜ã€‚

```CPP
class Solution {
public:
    // æŒ‰ç…§åŒºé—´å³è¾¹ç•Œæ’åº
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1]; // å³è¾¹ç•Œæ’åº 
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);

        int result = 1; // points ä¸ä¸ºç©ºè‡³å°‘éœ€è¦ä¸€æ”¯ç®­
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] >= intervals[i - 1][1]) {
                result++; // éœ€è¦ä¸€æ”¯ç®­
            }
            else {  // æ°”çƒiå’Œæ°”çƒi-1æŒ¨ç€
                intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); // æ›´æ–°é‡å æ°”çƒæœ€å°å³è¾¹ç•Œ
            }
        }
        return intervals.size() - result;
    }
};
```

è¿™é‡ŒæŒ‰ç…§ å·¦è¾¹ç•Œæ’åºï¼Œæˆ–è€…æŒ‰ç…§å³è¾¹ç•Œæ’åºï¼Œéƒ½å¯ä»¥ACï¼ŒåŸç†æ˜¯ä¸€æ ·çš„ã€‚
```CPP
class Solution {
public:
    // æŒ‰ç…§åŒºé—´å·¦è¾¹ç•Œæ’åº
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0]; // å·¦è¾¹ç•Œæ’åº
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);

        int result = 1; // points ä¸ä¸ºç©ºè‡³å°‘éœ€è¦ä¸€æ”¯ç®­
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] >= intervals[i - 1][1]) {
                result++; // éœ€è¦ä¸€æ”¯ç®­
            }
            else {  // æ°”çƒiå’Œæ°”çƒi-1æŒ¨ç€
                intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); // æ›´æ–°é‡å æ°”çƒæœ€å°å³è¾¹ç•Œ
            }
        }
        return intervals.size() - result;
    }
};

```

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬


```java []
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> {
            return Integer.compare(a[0],b[0]);
        });
        int count = 1;
        for(int i = 1;i < intervals.length;i++){
            if(intervals[i][0] < intervals[i-1][1]){
                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);
                continue;
            }else{
                count++;
            }    
        }
        return intervals.length - count;
    }
}

// æŒ‰å·¦è¾¹æ’åºï¼Œä¸ç®¡å³è¾¹é¡ºåºã€‚ç›¸äº¤çš„æ—¶å€™å–æœ€å°çš„å³è¾¹ã€‚
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> {
            return Integer.compare(a[0],b[0]);
        });
        int remove = 0;
        int pre = intervals[0][1];
        for(int i = 1; i < intervals.length; i++) {
            if(pre > intervals[i][0]) {
                remove++;
                pre = Math.min(pre, intervals[i][1]);
            }
            else pre = intervals[i][1];
        }
        return remove;
    }
}
```


```python []
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # è®°å½•éäº¤å‰åŒºé—´çš„ä¸ªæ•°
        end = intervals[0][1] # è®°å½•åŒºé—´åˆ†å‰²ç‚¹
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count
```

```go []
func eraseOverlapIntervals(intervals [][]int) int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][1] < intervals[j][1]
    })
    res := 1
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] >= intervals[i-1][1] {
            res++
        } else {
            intervals[i][1] = min(intervals[i - 1][1], intervals[i][1])
        }
    }
    return len(intervals) - res
}
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```


```Javascript []
- æŒ‰å³è¾¹ç•Œæ’åº
var eraseOverlapIntervals = function(intervals) {
    intervals.sort((a, b) => {
        return a[1] - b[1]
    })

    let count = 1
    let end = intervals[0][1]

    for(let i = 1; i < intervals.length; i++) {
        let interval = intervals[i]
        if(interval[0] >= end) {
            end = interval[1]
            count += 1
        }
    }
    
    return intervals.length - count
};

// æŒ‰å·¦è¾¹ç•Œæ’åº
var eraseOverlapIntervals = function(intervals) {
    // æŒ‰ç…§å·¦è¾¹ç•Œå‡åºæ’åˆ—
    intervals.sort((a, b) => a[0] - b[0])
    let count = 1
    let end = intervals[intervals.length - 1][0]
    // å€’åºéå†ï¼Œå¯¹å•ä¸ªåŒºé—´æ¥è¯´ï¼Œå·¦è¾¹ç•Œè¶Šå¤§è¶Šå¥½ï¼Œå› ä¸ºç»™å‰é¢åŒºé—´çš„ç©ºé—´è¶Šå¤§
    for(let i = intervals.length - 2; i >= 0; i--) {
        if(intervals[i][1] <= end) {
            count++
            end = intervals[i][0]
        }
    }
    // count è®°å½•çš„æ˜¯æœ€å¤§éé‡å¤åŒºé—´çš„ä¸ªæ•°
    return intervals.length - count
}
```



```typescript []
// > æŒ‰å³è¾¹ç•Œæ’åºï¼Œä»å·¦å¾€å³éå†
function eraseOverlapIntervals(intervals: number[][]): number {
    const length = intervals.length;
    if (length === 0) return 0;
    intervals.sort((a, b) => a[1] - b[1]);
    let right: number = intervals[0][1];
    let count: number = 1;
    for (let i = 1; i < length; i++) {
        if (intervals[i][0] >= right) {
            count++;
            right = intervals[i][1];
        }
    }
    return length - count;
};

// > æŒ‰å·¦è¾¹ç•Œæ’åºï¼Œä»å·¦å¾€å³éå†
function eraseOverlapIntervals(intervals: number[][]): number {
    if (intervals.length === 0) return 0;
    intervals.sort((a, b) => a[0] - b[0]);
    let right: number = intervals[0][1];
    let tempInterval: number[];
    let resCount: number = 0;
    for (let i = 1, length = intervals.length; i < length; i++) {
        tempInterval = intervals[i];
        if (tempInterval[0] >= right) {
            // æœªé‡å 
            right = tempInterval[1];
        } else {
            // æœ‰é‡å ï¼Œç§»é™¤å½“å‰intervalå’Œå‰ä¸€ä¸ªintervalä¸­å³è¾¹ç•Œæ›´å¤§çš„é‚£ä¸ª
            right = Math.min(right, tempInterval[1]);
            resCount++;
        }
    }
    return resCount;
};
```


```scala []
object Solution {
  def eraseOverlapIntervals(intervals: Array[Array[Int]]): Int = {
    var result = 0
    var interval = intervals.sortWith((a, b) => {
      a(1) < b(1)
    })
    var edge = Int.MinValue
    for (i <- 0 until interval.length) {
      if (edge <= interval(i)(0)) {
        edge = interval(i)(1)
      } else {
        result += 1
      }
    }
    result
  }
}
```


```Rust []
impl Solution {
    pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {
        if intervals.is_empty() {
            return 0;
        }
        intervals.sort_by_key(|interval| interval[1]);
        let mut count = 1;
        let mut end = intervals[0][1];
        for v in intervals.iter().skip(1) {
            if end <= v[0] {
                end = v[1];
                count += 1;
            }
        }

        (intervals.len() - count) as i32
    }
}
``` 

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**


