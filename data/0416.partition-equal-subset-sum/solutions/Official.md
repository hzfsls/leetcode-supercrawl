### ğŸ“º è§†é¢‘é¢˜è§£  
![416.åˆ†å‰²ç­‰å’Œå­é›†.mp4](1712d35b-f0ab-48aa-b964-fe22bf0a5931)

### ğŸ“– æ–‡å­—é¢˜è§£
#### å‰è¨€

**ä½œè€…åœ¨è¿™é‡Œå¸Œæœ›è¯»è€…è®¤çœŸé˜…è¯»å‰è¨€éƒ¨åˆ†ã€‚**

æœ¬é¢˜æ˜¯ç»å…¸çš„ã€Œ[NP å®Œå…¨é—®é¢˜](https://baike.baidu.com/item/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98)ã€ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½ å‘ç°äº†è¯¥é—®é¢˜çš„ä¸€ä¸ª[å¤šé¡¹å¼ç®—æ³•](https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95)ï¼Œé‚£ä¹ˆæ­å–œä½ è¯æ˜å‡ºäº† P=NPï¼Œå¯ä»¥æœŸå¾…ä¸€ä¸‹å›¾çµå¥–äº†ã€‚

æ­£å› å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¸åº”æœŸæœ›è¯¥é—®é¢˜æœ‰å¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦çš„è§£æ³•ã€‚æˆ‘ä»¬èƒ½æƒ³åˆ°çš„ï¼Œä¾‹å¦‚åŸºäºè´ªå¿ƒç®—æ³•çš„ã€Œå°†æ•°ç»„é™åºæ’åºåï¼Œä¾æ¬¡å°†æ¯ä¸ªå…ƒç´ æ·»åŠ è‡³å½“å‰å…ƒç´ å’Œè¾ƒå°çš„å­é›†ä¸­ã€ä¹‹ç±»çš„æ–¹æ³•éƒ½æ˜¯é”™è¯¯çš„ï¼Œå¯ä»¥è½»æ¾åœ°ä¸¾å‡ºåä¾‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»å°è¯•éå¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ï¼Œä¾‹å¦‚æ—¶é—´å¤æ‚åº¦ä¸å…ƒç´ å¤§å°ç›¸å…³çš„**åŠ¨æ€è§„åˆ’**ã€‚

#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

**æ€è·¯ä¸ç®—æ³•**

è¿™é“é¢˜å¯ä»¥æ¢ä¸€ç§è¡¨è¿°ï¼šç»™å®šä¸€ä¸ªåªåŒ…å«æ­£æ•´æ•°çš„éç©ºæ•°ç»„ $\textit{nums}[0]$ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥ä»æ•°ç»„ä¸­é€‰å‡ºä¸€äº›æ•°å­—ï¼Œä½¿å¾—è¿™äº›æ•°å­—çš„å’Œç­‰äºæ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚å› æ­¤è¿™ä¸ªé—®é¢˜å¯ä»¥è½¬æ¢æˆã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€ã€‚è¿™é“é¢˜ä¸ä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€çš„åŒºåˆ«åœ¨äºï¼Œä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€è¦æ±‚é€‰å–çš„ç‰©å“çš„é‡é‡ä¹‹å’Œ**ä¸èƒ½è¶…è¿‡**èƒŒåŒ…çš„æ€»å®¹é‡ï¼Œè¿™é“é¢˜åˆ™è¦æ±‚é€‰å–çš„æ•°å­—çš„å’Œ**æ°å¥½ç­‰äº**æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚ç±»ä¼¼äºä¼ ç»Ÿçš„ã€Œ$0-1$ èƒŒåŒ…é—®é¢˜ã€ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚

åœ¨ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦è¿›è¡Œä»¥ä¸‹åˆ¤æ–­ã€‚

- æ ¹æ®æ•°ç»„çš„é•¿åº¦ $n$ åˆ¤æ–­æ•°ç»„æ˜¯å¦å¯ä»¥è¢«åˆ’åˆ†ã€‚å¦‚æœ $n<2$ï¼Œåˆ™ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œå› æ­¤ç›´æ¥è¿”å› $\text{false}$ã€‚

- è®¡ç®—æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œ $\textit{sum}$ ä»¥åŠæœ€å¤§å…ƒç´  $\textit{maxNum}$ã€‚å¦‚æœ $\textit{sum}$ æ˜¯å¥‡æ•°ï¼Œåˆ™ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œå› æ­¤ç›´æ¥è¿”å› $\text{false}$ã€‚å¦‚æœ $\textit{sum}$ æ˜¯å¶æ•°ï¼Œåˆ™ä»¤ $\textit{target}=\frac{\textit{sum}}{2}$ï¼Œéœ€è¦åˆ¤æ–­æ˜¯å¦å¯ä»¥ä»æ•°ç»„ä¸­é€‰å‡ºä¸€äº›æ•°å­—ï¼Œä½¿å¾—è¿™äº›æ•°å­—çš„å’Œç­‰äº $\textit{target}$ã€‚å¦‚æœ $\textit{maxNum}>\textit{target}$ï¼Œåˆ™é™¤äº† $\textit{maxNum}$ ä»¥å¤–çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œä¸€å®šå°äº $\textit{target}$ï¼Œå› æ­¤ä¸å¯èƒ½å°†æ•°ç»„åˆ†å‰²æˆå…ƒç´ å’Œç›¸ç­‰çš„ä¸¤ä¸ªå­é›†ï¼Œç›´æ¥è¿”å› $\text{false}$ã€‚

åˆ›å»ºäºŒç»´æ•°ç»„ $\textit{dp}$ï¼ŒåŒ…å« $n$ è¡Œ $\textit{target}+1$ åˆ—ï¼Œå…¶ä¸­ $\textit{dp}[i][j]$ è¡¨ç¤ºä»æ•°ç»„çš„ $[0,i]$ ä¸‹æ ‡èŒƒå›´å†…é€‰å–è‹¥å¹²ä¸ªæ­£æ•´æ•°ï¼ˆå¯ä»¥æ˜¯ $0$ ä¸ªï¼‰ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ç§é€‰å–æ–¹æ¡ˆä½¿å¾—è¢«é€‰å–çš„æ­£æ•´æ•°çš„å’Œç­‰äº $j$ã€‚åˆå§‹æ—¶ï¼Œ$\textit{dp}$ ä¸­çš„å…¨éƒ¨å…ƒç´ éƒ½æ˜¯ $\text{false}$ã€‚

åœ¨å®šä¹‰çŠ¶æ€ä¹‹åï¼Œéœ€è¦è€ƒè™‘è¾¹ç•Œæƒ…å†µã€‚ä»¥ä¸‹ä¸¤ç§æƒ…å†µéƒ½å±äºè¾¹ç•Œæƒ…å†µã€‚

- å¦‚æœä¸é€‰å–ä»»ä½•æ­£æ•´æ•°ï¼Œåˆ™è¢«é€‰å–çš„æ­£æ•´æ•°ç­‰äº $0$ã€‚å› æ­¤å¯¹äºæ‰€æœ‰ $0 \le i < n$ï¼Œéƒ½æœ‰ $\textit{dp}[i][0]=\text{true}$ã€‚

- å½“ $i==0$ æ—¶ï¼Œåªæœ‰ä¸€ä¸ªæ­£æ•´æ•° $\textit{nums}[0]$ å¯ä»¥è¢«é€‰å–ï¼Œå› æ­¤ $\textit{dp}[0][\textit{nums}[0]]=\text{true}$ã€‚

å¯¹äº $i>0$ ä¸” $j>0$ çš„æƒ…å†µï¼Œå¦‚ä½•ç¡®å®š $\textit{dp}[i][j]$ çš„å€¼ï¼Ÿéœ€è¦åˆ†åˆ«è€ƒè™‘ä»¥ä¸‹ä¸¤ç§æƒ…å†µã€‚

- å¦‚æœ $j \ge \textit{nums}[i]$ï¼Œåˆ™å¯¹äºå½“å‰çš„æ•°å­— $\textit{nums}[i]$ï¼Œå¯ä»¥é€‰å–ä¹Ÿå¯ä»¥ä¸é€‰å–ï¼Œä¸¤ç§æƒ…å†µåªè¦æœ‰ä¸€ä¸ªä¸º $\text{true}$ï¼Œå°±æœ‰ $\textit{dp}[i][j]=\text{true}$ã€‚
   - å¦‚æœä¸é€‰å– $\textit{nums}[i]$ï¼Œåˆ™ $\textit{dp}[i][j]=\textit{dp}[i-1][j]$ï¼›
   - å¦‚æœé€‰å– $\textit{nums}[i]$ï¼Œåˆ™ $\textit{dp}[i][j]=\textit{dp}[i-1][j-\textit{nums}[i]]$ã€‚

- å¦‚æœ $j < \textit{nums}[i]$ï¼Œåˆ™åœ¨é€‰å–çš„æ•°å­—çš„å’Œç­‰äº $j$ çš„æƒ…å†µä¸‹æ— æ³•é€‰å–å½“å‰çš„æ•°å­— $\textit{nums}[i]$ï¼Œå› æ­¤æœ‰ $\textit{dp}[i][j]=\textit{dp}[i-1][j]$ã€‚

çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š

$$
\textit{dp}[i][j]=\begin{cases}
\textit{dp}[i-1][j]~|~\textit{dp}[i-1][j-\textit{nums}[i]], & j \ge \textit{nums}[i] \\
\textit{dp}[i-1][j], & j < \textit{nums}[i]
\end{cases}
$$

æœ€ç»ˆå¾—åˆ° $\textit{dp}[n-1][\textit{target}]$ å³ä¸ºç­”æ¡ˆã€‚

<![ppt1](https://assets.leetcode-cn.com/solution-static/416/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/416/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/416/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/416/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/416/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/416/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/416/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/416/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/416/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/416/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/416/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/416/12.png)>

```Java [sol0-Java]
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        boolean[][] dp = new boolean[n][target + 1];
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;
        for (int i = 1; i < n; i++) {
            int num = nums[i];
            for (int j = 1; j <= target; j++) {
                if (j >= num) {
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n - 1][target];
    }
}
```

```C++ [sol0-C++]
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return false;
        }
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int maxNum = *max_element(nums.begin(), nums.end());
        if (sum & 1) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        vector<vector<int>> dp(n, vector<int>(target + 1, 0));
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;
        for (int i = 1; i < n; i++) {
            int num = nums[i];
            for (int j = 1; j <= target; j++) {
                if (j >= num) {
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n - 1][target];
    }
};
```

```JavaScript [sol0-JavaScript]
var canPartition = function(nums) {
    const n = nums.length;
    if (n < 2) {
        return false;
    }
    let sum = 0, maxNum = 0;
    for (const num of nums) {
        sum += num;
        maxNum = maxNum > num ? maxNum : num;
    }
    if (sum & 1) {
        return false;
    }
    const target = Math.floor(sum / 2);
    if (maxNum > target) {
        return false;
    }
    const dp = new Array(n).fill(0).map(() => new Array(target + 1, false));
    for (let i = 0; i < n; i++) {
        dp[i][0] = true;
    }
    dp[0][nums[0]] = true;
    for (let i = 1; i < n; i++) {
        const num = nums[i];
        for (let j = 1; j <= target; j++) {
            if (j >= num) {
                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[n - 1][target];
};
```

```Golang [sol0-Golang]
func canPartition(nums []int) bool {
    n := len(nums)
    if n < 2 {
        return false
    }

    sum, max := 0, 0
    for _, v := range nums {
        sum += v
        if v > max {
            max = v
        }
    }
    if sum%2 != 0 {
        return false
    }

    target := sum / 2
    if max > target {
        return false
    }

    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, target+1)
    }
    for i := 0; i < n; i++ {
        dp[i][0] = true
    }
    dp[0][nums[0]] = true
    for i := 1; i < n; i++ {
        v := nums[i]
        for j := 1; j <= target; j++ {
            if j >= v {
                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n-1][target]
}
```

```C [sol0-C]
bool canPartition(int* nums, int numsSize) {
    if (numsSize < 2) {
        return false;
    }
    int sum = 0, maxNum = 0;
    for (int i = 0; i < numsSize; ++i) {
        sum += nums[i];
        maxNum = fmax(maxNum, nums[i]);
    }
    if (sum & 1) {
        return false;
    }
    int target = sum / 2;
    if (maxNum > target) {
        return false;
    }
    int dp[numsSize][target + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < numsSize; i++) {
        dp[i][0] = true;
    }
    dp[0][nums[0]] = true;
    for (int i = 1; i < numsSize; i++) {
        int num = nums[i];
        for (int j = 1; j <= target; j++) {
            if (j >= num) {
                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[numsSize - 1][target];
}
```

```Python [sol0-Python3]
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        maxNum = max(nums)
        if total & 1:
            return False
        
        target = total // 2
        if maxNum > target:
            return False
        
        dp = [[False] * (target + 1) for _ in range(n)]
        for i in range(n):
            dp[i][0] = True
        
        dp[0][nums[0]] = True
        for i in range(1, n):
            num = nums[i]
            for j in range(1, target + 1):
                if j >= num:
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]
                else:
                    dp[i][j] = dp[i - 1][j]
        
        return dp[n - 1][target]
```

ä¸Šè¿°ä»£ç çš„ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n \times \textit{target})$ã€‚ä½†æ˜¯å¯ä»¥å‘ç°åœ¨è®¡ç®— $\textit{dp}$ çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€è¡Œçš„ $dp$ å€¼éƒ½åªä¸ä¸Šä¸€è¡Œçš„ $dp$ å€¼æœ‰å…³ï¼Œå› æ­¤åªéœ€è¦ä¸€ä¸ªä¸€ç»´æ•°ç»„å³å¯å°†ç©ºé—´å¤æ‚åº¦é™åˆ° $O(\textit{target})$ã€‚æ­¤æ—¶çš„è½¬ç§»æ–¹ç¨‹ä¸ºï¼š
$$
\textit{dp}[j]=\textit{dp}[j]\ |\ dp[j-\textit{nums}[i]]
$$
ä¸”éœ€è¦æ³¨æ„çš„æ˜¯ç¬¬äºŒå±‚çš„å¾ªç¯æˆ‘ä»¬éœ€è¦**ä»å¤§åˆ°å°è®¡ç®—**ï¼Œå› ä¸ºå¦‚æœæˆ‘ä»¬ä»å°åˆ°å¤§æ›´æ–° $\textit{dp}$ å€¼ï¼Œé‚£ä¹ˆåœ¨è®¡ç®— $\textit{dp}[j]$ å€¼çš„æ—¶å€™ï¼Œ$\textit{dp}[j-\textit{nums}[i]]$ å·²ç»æ˜¯è¢«æ›´æ–°è¿‡çš„çŠ¶æ€ï¼Œä¸å†æ˜¯ä¸Šä¸€è¡Œçš„ $\textit{dp}$ å€¼ã€‚

**ä»£ç **

```Java [sol1-Java]
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            for (int j = target; j >= num; --j) {
                dp[j] |= dp[j - num];
            }
        }
        return dp[target];
    }
}
```

```C++ [sol1-C++]
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for (auto& num : nums) {
            sum += num;
            maxNum = max(maxNum, num);
        }
        if (sum & 1) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        vector<int> dp(target + 1, 0);
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            for (int j = target; j >= num; --j) {
                dp[j] |= dp[j - num];
            }
        }
        return dp[target];
    }
};
```

```JavaScript [sol1-JavaScript]
var canPartition = function(nums) {
    const n = nums.length;
    if (n < 2) {
        return false;
    }
    let sum = 0, maxNum = 0;
    for (const num of nums) {
        sum += num;
        maxNum = maxNum > num ? maxNum : num;
    }
    if (sum & 1) {
        return false;
    }
    const target = Math.floor(sum / 2);
    if (maxNum > target) {
        return false;
    }
    const dp = new Array(target + 1).fill(false);
    dp[0] = true;
    for (const num of nums) {
        for (let j = target; j >= num; --j) {
            dp[j] |= dp[j - num];
        }
    }
    return dp[target];
};
```

```Golang [sol1-Golang]
func canPartition(nums []int) bool {
    n := len(nums)
    if n < 2 {
        return false
    }

    sum, max := 0, 0
    for _, v := range nums {
        sum += v
        if v > max {
            max = v
        }
    }
    if sum%2 != 0 {
        return false
    }

    target := sum / 2
    if max > target {
        return false
    }

    dp := make([]bool, target+1)
    dp[0] = true
    for i := 0; i < n; i++ {
        v := nums[i]
        for j := target; j >= v; j-- {
            dp[j] = dp[j] || dp[j-v]
        }
    }
    return dp[target]
}
```

```C [sol1-C]
bool canPartition(int* nums, int numsSize) {
    if (numsSize < 2) {
        return false;
    }
    int sum = 0, maxNum = 0;
    for (int i = 0; i < numsSize; ++i) {
        sum += nums[i];
        maxNum = fmax(maxNum, nums[i]);
    }
    if (sum & 1) {
        return false;
    }
    int target = sum / 2;
    if (maxNum > target) {
        return false;
    }
    int dp[target + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = true;
    for (int i = 0; i < numsSize; i++) {
        int num = nums[i];
        for (int j = target; j >= num; --j) {
            dp[j] |= dp[j - num];
        }
    }
    return dp[target];
}
```

```Python [sol1-Python3]
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
        
        return dp[target]
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \times \textit{target})$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œ$\textit{target}$ æ˜¯æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚éœ€è¦è®¡ç®—å‡ºæ‰€æœ‰çš„çŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€åœ¨è¿›è¡Œè½¬ç§»æ—¶çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(\textit{target})$ï¼Œå…¶ä¸­ $\textit{target}$ æ˜¯æ•´ä¸ªæ•°ç»„çš„å…ƒç´ å’Œçš„ä¸€åŠã€‚ç©ºé—´å¤æ‚åº¦å–å†³äº $\textit{dp}$ æ•°ç»„ï¼Œåœ¨ä¸è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ $O(n \times \textit{target})$ï¼Œåœ¨è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œç©ºé—´å¤æ‚åº¦å¯ä»¥é™åˆ° $O(\textit{target})$ã€‚