## [375.猜数字大小 II 中文热门题解1](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/solutions/100000/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2)

作者：[smilyt_](https://leetcode.cn/u/smilyt_)

### 1.为什么使用动态规划，不使用二分？
动态规划与二分的区别在哪里呢？
使用动态规划的好处在于我可以穷举所有的情况，对于这个题来说，就是指动态规划的方法可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。
举个例子：
当n=5：

    动态规划：1 2 3 4 5 在第一次猜数时，我们可以猜1,2,3,4,5
    二分查找：1 2 3 4 5 在第一次猜数时，我们只能猜3
为什么要使用动态规划猜所有的数字呢？
当n=5，假如我第一次猜3，那么需要7；假如我第一次猜4，只需要6.
很显然6才是正确答案，使用二分法虽然方便，但是是错误的。所以我使用动态规划穷举所有情况。

### 2.对于二维数组dp[i][j]的理解
动态规划需要使用内存储存计算过的结果，在这里我使用一个二维数组dp[n+1][n+1]

对于动态规划来说，需要明白dp[i][j]的含义，所以接下来我尝试解释dp[i][j]的含义:
dp[i][j]是说依次以从i到j的数字作为分割点(猜的数)，必定赢的游戏所用钱的最小值。
这样看起来似乎很难理解。

(1)解释dp[1][1]:
dp[1][1]是指只有一个数字1，我们以1作为分割点(猜的数)，赢得游戏所用钱的最小值，一看就知道，dp[1][1]=0。因为我们只能猜1，答案也只能是1，不用花钱

(2)解释dp[1][2]:
dp[1][2]是指只有两个数字1，2
我们先以1作为分割点(猜的数):

    猜1：    
    答案是1，花费0元
    答案是2，花费1元
    必定赢得游戏，最多花费1元
我们再以2作为分割点(猜的数):

    猜2：
    答案是1，花费2元
    答案是2，花费0元
    必定赢得游戏，最多花费2元
综上，只要进入[1,2]这个区间，我们第一次猜1，只要花费1元，必定可以赢得游戏（假如看不懂，再看一次，细细的品）
所以dp[1][2]=1(只要花1元必定赢得游戏，当第一次猜1时)

(3)解释dp[2][3]:
dp[2][3]是指只有两个数字2，3

有一个小问题，为什么不是从1开始呢？(明白的不用看)
比如n=3，我们第一次猜了1，但是答案是2或者3，反正不是1，我们是不是要到[2,3]区间来寻找答案，即求        
dp[2][3]

我们先以2作为分割点(猜的数):

    猜2：    
    答案是2，花费0元
    答案是3，花费2元
    必定赢得游戏，最多花费2元
我们再以3作为分割点(猜的数):

    猜3：
    答案是2，花费3元
    答案是3，花费0元
    必定赢得游戏，最多花费3元
综上，只要进入[2,3]这个区间，我们第一次猜2，只要花费2元，必定可以赢得游戏
所以dp[2][3]=2(只要花2元必定赢得游戏，当第一次猜2时)

(4)解释dp[1][3]:
dp[1][3]是指只有三个数字1，2，3
我们先以1作为分割点(猜的数):

    猜1：
    答案是1，花费0元
    答案是2或者3，这个时候会进入另一个区间[2,3]，花费1+dp[2][3]元
    必定赢得游戏，最多花费max(0,1+dp[2][3])元
我们再以2作为分割点(猜的数):

    猜2：
    答案是1，花费2+dp[1][1]=2+0=2元
    答案是2，花费0元
    答案是3，花费2+dp[3][3]=2+0=2元
    必定赢得游戏，最多花费max(0,2+dp[1][1],2+dp[3][3])元
我们最后以3作为分割点(猜的数):

    猜3：
    答案是1或者2,花费3+dp[1][2]元
    答案是3，花费0元
    必定赢得游戏，最多花费max(0,3+dp[1][2])元
综上，只要进入[1][3]这个区间，我们只要花费min( max(0,1+dp[2][3]) , max(0,2+dp[1][1],2+dp[3][3]) , max(0,3+dp[1][2]) )元必定可以赢的游戏
而dp[1][3]也就等于那个min的值。

可以发现，只要找到dp[1][n]即可。
(假如不能明白dp[i][j]可以返回上面内容看例子，明白后再往下阅读)

### 3.状态转移方程
状态转移方程怎么写呢？
看第4个例子，dp[1][3]我们就可以发现：
对于每一个分割点，我们取它左右两边区间的最大值加上分割点本身作为取此分割点的dp[i][j]值
对于每一个区间，我们取所有分割点的dp[i][j]的最小值作为dp[i][j]的真正的值
特别地，对于以i作为分割点的dp[i][j]，只取i右边的区间；对于以j作为分割点的dp[i][j]，只取j左边的区间

这个我觉得看懂dp[1][3]不难理解，要是理解不了的话，我这样解释一下(明白的不用看)：

    i i+1 i+2 ... ... j-2 j-1 j
    以i+1为分割点对应的：dp1=max(dp[i][i],dp[i+2][j])+i+1
    以j-1为分割点对应的: dp2=max(dp[i][j-2],dp[j][j])+j-1
    特别地,以i为分割点：dp0=i+dp[i+1][j];以j为分割点: dp3=j+dp[i][j-1]
    dp[i][j]=min(dp0,dp1,dp2,dp3)

### 4.数组填充
给出一个dp二维数组来用代码填充它，“\”表示正无穷

    (1)初始化：         (2)易知dp[i][i]=0   
    | \ \ \ \ |         | 0 \ \ \ |
    | \ \ \ \ |         | \ 0 \ \ |
    | \ \ \ \ |         | \ \ 0 \ |
    | \ \ \ \ |         | \ \ \ 0 |
接下来要考虑怎么填充矩阵以得到dp[1][n]:
很容易我们发现可以用一个位置左边和下边地数据来计算它本身，因此可以这样填充

    (3)填充1列：
    | 0 1 \ \ |  dp[1][2]计算步骤向上看
    | \ 0 \ \ |
    | \ \ 0 \ |
    | \ \ \ 0 |
    (4)再填充1列：
    | 0 1 x \ |  dp[1][3]计算步骤向上看
    | \ 0 2 \ |  dp[2][3]计算步骤向上看(先填充)
    | \ \ 0 \ |
    | \ \ \ 0 |
    (5)再填充最后一列:
    | 0 1 x x |  dp[1][4]计算步骤向上看
    | \ 0 2 x |  dp[2][4]计算步骤向上看(然后填充)
    | \ \ 0 x |  dp[3][4]计算步骤向上看(先填充)
    | \ \ \ 0 |
    x都是因为我懒得算了... ... 偷个懒，有兴趣可以自己算

### 5.代码实现
上述问题搞清楚就可以来写代码了

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        if(n==1)
            return 0;
        //定义矩阵
        int dp[n+1][n+1];
        //初始化“\”
        for(int i=0;i<=n;i++){
            for(int j=0;j<=n;j++){
                dp[i][j]=INT_MAX;
            }
        }
        //定义基础值dp[i][i]
        for(int i=0;i<=n;i++){
            dp[i][i]=0;
        }

        //按列来，从第2列开始
        for(int j=2;j<=n;j++){
            //按行来，从下往上
            for(int i=j-1;i>=1;i--){
                //算除了两端的每一个分割点
                for(int k=i+1;k<=j-1;k++){
                    dp[i][j]=min(k+max(dp[i][k-1],dp[k+1][j]),dp[i][j]);
                }
                //算两端
                dp[i][j]=min(dp[i][j],i+dp[i+1][j]);
                dp[i][j]=min(dp[i][j],j+dp[i][j-1]);
            }
        }
        return dp[1][n];
    }
};
```

### 6.反思
第一次写题解，可能写的不好，有问题可以评论我，希望大家看明白，能帮助到大家！  
点个赞呗亲