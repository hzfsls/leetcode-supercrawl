## [1825.æ±‚å‡º MK å¹³å‡å€¼ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/finding-mk-average/solutions/100000/by-lcbin-bonb)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)



**æ–¹æ³•ä¸€ï¼šæœ‰åºé›†åˆ + é˜Ÿåˆ—**

æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä»¥ä¸‹æ•°æ®ç»“æž„æˆ–å˜é‡ï¼š

-   ä¸€ä¸ªé•¿åº¦ä¸º $m$ çš„é˜Ÿåˆ— $q$ï¼Œå…¶ä¸­é˜Ÿé¦–å…ƒç´ ä¸ºæœ€æ—©åŠ å…¥çš„å…ƒç´ ï¼Œé˜Ÿå°¾å…ƒç´ ä¸ºæœ€è¿‘åŠ å…¥çš„å…ƒç´ 
-   ä¸‰ä¸ªæœ‰åºé›†åˆï¼Œåˆ†åˆ«ä¸º $lo$, $mid$, $hi$ï¼Œå…¶ä¸­ $lo$ å’Œ $hi$ åˆ†åˆ«å­˜å‚¨æœ€å°çš„ $k$ ä¸ªå…ƒç´ å’Œæœ€å¤§çš„ $k$ ä¸ªå…ƒç´ ï¼Œè€Œ $mid$ å­˜å‚¨å‰©ä½™çš„å…ƒç´ ï¼›
-   ä¸€ä¸ªå˜é‡ $s$ï¼Œç»´æŠ¤ $mid$ ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œã€‚
-   éƒ¨åˆ†ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Java, Goï¼‰é¢å¤–ç»´æŠ¤ä¸¤ä¸ªå˜é‡ $size1$ å’Œ $size3$ï¼Œåˆ†åˆ«è¡¨ç¤º $lo$ å’Œ $hi$ ä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚

è°ƒç”¨ $addElement(num)$ å‡½æ•°æ—¶ï¼Œé¡ºåºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1. å¦‚æžœ $lo$ ä¸ºç©ºï¼Œæˆ–è€… $num \leq max(lo)$ï¼Œåˆ™å°† $num$ åŠ å…¥ $lo$ ä¸­ï¼›å¦åˆ™å¦‚æžœ $hi$ ä¸ºç©ºï¼Œæˆ–è€… $num \geq min(hi)$ï¼Œåˆ™å°† $num$ åŠ å…¥ $hi$ ä¸­ï¼›å¦åˆ™å°† $num$ åŠ å…¥ $mid$ ä¸­ï¼ŒåŒæ—¶å°† $num$ çš„å€¼åŠ åˆ° $s$ ä¸­ã€‚
1. æŽ¥ä¸‹æ¥å°† $num$ åŠ å…¥é˜Ÿåˆ— $q$ ä¸­ï¼Œå¦‚æžœæ­¤æ—¶é˜Ÿåˆ— $q$ çš„é•¿åº¦å¤§äºŽ $m$ï¼Œåˆ™å°†é˜Ÿé¦–å…ƒç´  $x$ ä»Žé˜Ÿåˆ— $q$ ä¸­ç§»é™¤ï¼ŒæŽ¥ä¸‹æ¥ä»Ž $lo$, $mid$ æˆ– $hi$ ä¸­é€‰æ‹©å…¶ä¸­ä¸€ä¸ªåŒ…å« $x$ çš„é›†åˆï¼Œå°† $x$ ä»Žè¯¥é›†åˆä¸­ç§»é™¤ï¼Œå¦‚æžœè¯¥é›†åˆä¸º $mid$ï¼Œåˆ™å°† $s$ å‡åŽ» $x$ çš„å€¼ã€‚
1. å¦‚æžœ $lo$ çš„é•¿åº¦å¤§äºŽ $k$ï¼Œåˆ™å¾ªçŽ¯å°† $lo$ ä¸­çš„æœ€å¤§å€¼ $max(lo)$ ä»Ž $lo$ ä¸­ç§»é™¤ï¼Œå°† $max(lo)$ åŠ å…¥ $mid$ ä¸­ï¼ŒåŒæ—¶å°† $s$ åŠ ä¸Š $max(lo)$ çš„å€¼ã€‚
1. å¦‚æžœ $hi$ çš„é•¿åº¦å¤§äºŽ $k$ï¼Œåˆ™å¾ªçŽ¯å°† $hi$ ä¸­çš„æœ€å°å€¼ $min(hi)$ ä»Ž $hi$ ä¸­ç§»é™¤ï¼Œå°† $min(hi)$ åŠ å…¥ $mid$ ä¸­ï¼ŒåŒæ—¶å°† $s$ åŠ ä¸Š $min(hi)$ çš„å€¼ã€‚
1. å¦‚æžœ $lo$ çš„é•¿åº¦å°äºŽ $k$ï¼Œå¹¶ä¸” $mid$ ä¸ä¸ºç©ºï¼Œåˆ™å¾ªçŽ¯å°† $mid$ ä¸­çš„æœ€å°å€¼ $min(mid)$ ä»Ž $mid$ ä¸­ç§»é™¤ï¼Œå°† $min(mid)$ åŠ å…¥ $lo$ ä¸­ï¼ŒåŒæ—¶å°† $s$ å‡åŽ» $min(mid)$ çš„å€¼ã€‚
1. å¦‚æžœ $hi$ çš„é•¿åº¦å°äºŽ $k$ï¼Œå¹¶ä¸” $mid$ ä¸ä¸ºç©ºï¼Œåˆ™å¾ªçŽ¯å°† $mid$ ä¸­çš„æœ€å¤§å€¼ $max(mid)$ ä»Ž $mid$ ä¸­ç§»é™¤ï¼Œå°† $max(mid)$ åŠ å…¥ $hi$ ä¸­ï¼ŒåŒæ—¶å°† $s$ å‡åŽ» $max(mid)$ çš„å€¼ã€‚

è°ƒç”¨ $calculateMKAverage()$ å‡½æ•°æ—¶ï¼Œå¦‚æžœ $q$ çš„é•¿åº¦å°äºŽ $m$ï¼Œåˆ™è¿”å›ž $-1$ï¼Œå¦åˆ™è¿”å›ž $\frac{s}{m - 2k}$ã€‚


```python [sol1-Python3]
from sortedcontainers import SortedList


class MKAverage:

    def __init__(self, m: int, k: int):
        self.m = m
        self.k = k
        self.s = 0
        self.q = deque()
        self.lo = SortedList()
        self.mid = SortedList()
        self.hi = SortedList()

    def addElement(self, num: int) -> None:
        if not self.lo or num <= self.lo[-1]:
            self.lo.add(num)
        elif not self.hi or num >= self.hi[0]:
            self.hi.add(num)
        else:
            self.mid.add(num)
            self.s += num
        self.q.append(num)
        if len(self.q) > self.m:
            x = self.q.popleft()
            if x in self.lo:
                self.lo.remove(x)
            elif x in self.hi:
                self.hi.remove(x)
            else:
                self.mid.remove(x)
                self.s -= x
        while len(self.lo) > self.k:
            x = self.lo.pop()
            self.mid.add(x)
            self.s += x
        while len(self.hi) > self.k:
            x = self.hi.pop(0)
            self.mid.add(x)
            self.s += x
        while len(self.lo) < self.k and self.mid:
            x = self.mid.pop(0)
            self.lo.add(x)
            self.s -= x
        while len(self.hi) < self.k and self.mid:
            x = self.mid.pop()
            self.hi.add(x)
            self.s -= x

    def calculateMKAverage(self) -> int:
        return -1 if len(self.q) < self.m else self.s // (self.m - 2 * self.k)


# Your MKAverage object will be instantiated and called as such:
# obj = MKAverage(m, k)
# obj.addElement(num)
# param_2 = obj.calculateMKAverage()
```


```java [sol1-Java]
class MKAverage {

    private int m, k;
    private long s;
    private int size1, size3;
    private Deque<Integer> q = new ArrayDeque<>();
    private TreeMap<Integer, Integer> lo = new TreeMap<>();
    private TreeMap<Integer, Integer> mid = new TreeMap<>();
    private TreeMap<Integer, Integer> hi = new TreeMap<>();


    public MKAverage(int m, int k) {
        this.m = m;
        this.k = k;
    }

    public void addElement(int num) {
        if (lo.isEmpty() || num <= lo.lastKey()) {
            lo.merge(num, 1, Integer::sum);
            ++size1;
        } else if (hi.isEmpty() || num >= hi.firstKey()) {
            hi.merge(num, 1, Integer::sum);
            ++size3;
        } else {
            mid.merge(num, 1, Integer::sum);
            s += num;
        }
        q.offer(num);
        if (q.size() > m) {
            int x = q.poll();
            if (lo.containsKey(x)) {
                if (lo.merge(x, -1, Integer::sum) == 0) {
                    lo.remove(x);
                }
                --size1;
            } else if (hi.containsKey(x)) {
                if (hi.merge(x, -1, Integer::sum) == 0) {
                    hi.remove(x);
                }
                --size3;
            } else {
                if (mid.merge(x, -1, Integer::sum) == 0) {
                    mid.remove(x);
                }
                s -= x;
            }
        }
        for (; size1 > k; --size1) {
            int x = lo.lastKey();
            if (lo.merge(x, -1, Integer::sum) == 0) {
                lo.remove(x);
            }
            mid.merge(x, 1, Integer::sum);
            s += x;
        }
        for (; size3 > k; --size3) {
            int x = hi.firstKey();
            if (hi.merge(x, -1, Integer::sum) == 0) {
                hi.remove(x);
            }
            mid.merge(x, 1, Integer::sum);
            s += x;
        }
        for (; size1 < k && !mid.isEmpty(); ++size1) {
            int x = mid.firstKey();
            if (mid.merge(x, -1, Integer::sum) == 0) {
                mid.remove(x);
            }
            s -= x;
            lo.merge(x, 1, Integer::sum);
        }
        for (; size3 < k && !mid.isEmpty(); ++size3) {
            int x = mid.lastKey();
            if (mid.merge(x, -1, Integer::sum) == 0) {
                mid.remove(x);
            }
            s -= x;
            hi.merge(x, 1, Integer::sum);
        }
    }

    public int calculateMKAverage() {
        return q.size() < m ? -1 : (int) (s / (q.size() - k * 2));
    }
}

/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage obj = new MKAverage(m, k);
 * obj.addElement(num);
 * int param_2 = obj.calculateMKAverage();
 */
```



```cpp [sol1-C++]
class MKAverage {
public:
    MKAverage(int m, int k) {
        this->m = m;
        this->k = k;
    }

    void addElement(int num) {
        if (lo.empty() || num <= *lo.rbegin()) {
            lo.insert(num);
        } else if (hi.empty() || num >= *hi.begin()) {
            hi.insert(num);
        } else {
            mid.insert(num);
            s += num;
        }

        q.push(num);
        if (q.size() > m) {
            int x = q.front();
            q.pop();
            if (lo.find(x) != lo.end()) {
                lo.erase(lo.find(x));
            } else if (hi.find(x) != hi.end()) {
                hi.erase(hi.find(x));
            } else {
                mid.erase(mid.find(x));
                s -= x;
            }
        }
        while (lo.size() > k) {
            int x = *lo.rbegin();
            lo.erase(prev(lo.end()));
            mid.insert(x);
            s += x;
        }
        while (hi.size() > k) {
            int x = *hi.begin();
            hi.erase(hi.begin());
            mid.insert(x);
            s += x;
        }
        while (lo.size() < k && mid.size()) {
            int x = *mid.begin();
            mid.erase(mid.begin());
            s -= x;
            lo.insert(x);
        }
        while (hi.size() < k && mid.size()) {
            int x = *mid.rbegin();
            mid.erase(prev(mid.end()));
            s -= x;
            hi.insert(x);
        }
    }

    int calculateMKAverage() {
        return q.size() < m ? -1 : s / (q.size() - k * 2);
    }

private:
    int m, k;
    long long s = 0;
    queue<int> q;
    multiset<int> lo, mid, hi;
};

/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage* obj = new MKAverage(m, k);
 * obj->addElement(num);
 * int param_2 = obj->calculateMKAverage();
 */
```



```go [sol1-Go]
type MKAverage struct {
	lo, mid, hi  *redblacktree.Tree
	q            []int
	m, k, s      int
	size1, size3 int
}

func Constructor(m int, k int) MKAverage {
	lo := redblacktree.NewWithIntComparator()
	mid := redblacktree.NewWithIntComparator()
	hi := redblacktree.NewWithIntComparator()
	return MKAverage{lo, mid, hi, []int{}, m, k, 0, 0, 0}
}

func (this *MKAverage) AddElement(num int) {
	merge := func(rbt *redblacktree.Tree, key, value int) {
		if v, ok := rbt.Get(key); ok {
			nxt := v.(int) + value
			if nxt == 0 {
				rbt.Remove(key)
			} else {
				rbt.Put(key, nxt)
			}
		} else {
			rbt.Put(key, value)
		}
	}

	if this.lo.Empty() || num <= this.lo.Right().Key.(int) {
		merge(this.lo, num, 1)
		this.size1++
	} else if this.hi.Empty() || num >= this.hi.Left().Key.(int) {
		merge(this.hi, num, 1)
		this.size3++
	} else {
		merge(this.mid, num, 1)
		this.s += num
	}
	this.q = append(this.q, num)
	if len(this.q) > this.m {
		x := this.q[0]
		this.q = this.q[1:]
		if _, ok := this.lo.Get(x); ok {
			merge(this.lo, x, -1)
			this.size1--
		} else if _, ok := this.hi.Get(x); ok {
			merge(this.hi, x, -1)
			this.size3--
		} else {
			merge(this.mid, x, -1)
			this.s -= x
		}
	}
	for ; this.size1 > this.k; this.size1-- {
		x := this.lo.Right().Key.(int)
		merge(this.lo, x, -1)
		merge(this.mid, x, 1)
		this.s += x
	}
	for ; this.size3 > this.k; this.size3-- {
		x := this.hi.Left().Key.(int)
		merge(this.hi, x, -1)
		merge(this.mid, x, 1)
		this.s += x
	}
	for ; this.size1 < this.k && !this.mid.Empty(); this.size1++ {
		x := this.mid.Left().Key.(int)
		merge(this.mid, x, -1)
		this.s -= x
		merge(this.lo, x, 1)
	}
	for ; this.size3 < this.k && !this.mid.Empty(); this.size3++ {
		x := this.mid.Right().Key.(int)
		merge(this.mid, x, -1)
		this.s -= x
		merge(this.hi, x, 1)
	}
}

func (this *MKAverage) CalculateMKAverage() int {
	if len(this.q) < this.m {
		return -1
	}
	return this.s / (this.m - 2*this.k)
}

/**
 * Your MKAverage object will be instantiated and called as such:
 * obj := Constructor(m, k);
 * obj.AddElement(num);
 * param_2 := obj.CalculateMKAverage();
 */
```

æ—¶é—´å¤æ‚åº¦æ–¹é¢ï¼Œæ¯æ¬¡è°ƒç”¨ $addElement(num)$ å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log m)$ï¼Œæ¯æ¬¡è°ƒç”¨ $calculateMKAverage()$ å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ã€‚ç©ºé—´å¤æ‚åº¦ä¸º $O(m)$ã€‚


---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~