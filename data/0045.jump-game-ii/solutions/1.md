## [45.跳跃游戏 II 中文热门题解1](https://leetcode.cn/problems/jump-game-ii/solutions/100000/45-by-ikaruga)

作者：[ikaruga](https://leetcode.cn/u/ikaruga)
#### 思路
1. 如果某一个作为 **起跳点** 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 **起跳点**。
   11. 可以对每一个能作为 **起跳点** 的格子都尝试跳一次，把 **能跳到最远的距离** 不断更新。

2. 如果从这个 **起跳点** 起跳叫做第 1 次 **跳跃**，那么从后面 3 个格子起跳 **都** 可以叫做第 2 次 **跳跃**。

3. 所以，当一次 **跳跃** 结束时，从下一个格子开始，到现在 **能跳到最远的距离**，**都** 是下一次 **跳跃** 的 **起跳点**。
   31. 对每一次 **跳跃** 用 for 循环来模拟。
   32. 跳完一次之后，更新下一次 **起跳点** 的范围。
   33. 在新的范围内跳，更新 **能跳到最远的距离**。

4. 记录 **跳跃** 次数，如果跳到了终点，就得到了结果。

#### 图解
![图片.png](https://pic.leetcode-cn.com/9d5016c6e660a452991185d23b7b4d98853b7c300453d79715b5e9a206085e44-%E5%9B%BE%E7%89%87.png)


#### 代码
```C++ []
int jump(vector<int> &nums)
{
    int ans = 0;
    int start = 0;
    int end = 1;
    while (end < nums.size())
    {
        int maxPos = 0;
        for (int i = start; i < end; i++)
        {
            // 能跳到最远的距离
            maxPos = max(maxPos, i + nums[i]);
        }
        start = end;      // 下一次起跳点范围开始的格子
        end = maxPos + 1; // 下一次起跳点范围结束的格子
        ans++;            // 跳跃次数
    }
    return ans;
}
```

#### 优化
1. 从上面代码观察发现，其实被 while 包含的 for 循环中，i 是从头跑到尾的。

2. 只需要在一次 **跳跃** 完成时，更新下一次 **能跳到最远的距离**。

3. 并以此刻作为时机来更新 **跳跃** 次数。

4. 就可以在一次 for 循环中处理。

```C++ []
int jump(vector<int>& nums)
{
    int ans = 0;
    int end = 0;
    int maxPos = 0;
    for (int i = 0; i < nums.size() - 1; i++)
    {
        maxPos = max(nums[i] + i, maxPos);
        if (i == end)
        {
            end = maxPos;
            ans++;
        }
    }
    return ans;
}
```



#### 致谢
感谢您的观看，希望对您有帮助，欢迎热烈的交流！  
