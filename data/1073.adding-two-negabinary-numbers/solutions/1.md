## [1073.è´ŸäºŒè¿›åˆ¶æ•°ç›¸åŠ  ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/adding-two-negabinary-numbers/solutions/100000/python3javacgotypescript-yi-ti-yi-jie-mo-mg0a)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)



**æ–¹æ³•ä¸€ï¼šæ¨¡æ‹Ÿ**

æˆ‘ä»¬éå†ä¸¤ä¸ªæ•°ç»„ï¼Œä»æœ€ä½ä½å¼€å§‹ï¼Œè®°ä¸¤ä¸ªæ•°ç»„å½“å‰ä½çš„æ•°å­—ä¸º $a$ å’Œ $b$ï¼Œè¿›ä½ä¸º $c$ï¼Œä¸‰ä¸ªæ•°ç›¸åŠ çš„ç»“æœä¸º $x$ã€‚

-   å…ˆå°†è¿›ä½ $c$ ç½®ä¸º $0$ã€‚
-   å¦‚æœ $x \geq 2$ï¼Œé‚£ä¹ˆå°† $x$ å‡å» $2$ï¼Œå¹¶å‘é«˜ä½è¿›ä½ $-1$ã€‚å³é€¢ $2$ è¿›è´Ÿ $1$ã€‚
-   å¦‚æœ $x = -1$ï¼Œç”±äº $-(-2)^{i} = (-2)^{i} + (-2)^{i+1}$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°† $x$ ç½®ä¸º $1$ï¼Œå¹¶å‘é«˜ä½è¿›ä½ $1$ã€‚

ç„¶åï¼Œæˆ‘ä»¬å°† $x$ åŠ å…¥åˆ°ç­”æ¡ˆæ•°ç»„ä¸­ï¼Œç„¶åç»§ç»­å¤„ç†ä¸‹ä¸€ä½ã€‚

éå†ç»“æŸåï¼Œå»é™¤ç­”æ¡ˆæ•°ç»„ä¸­æœ«å°¾çš„ $0$ï¼Œå¹¶å°†æ•°ç»„åè½¬ï¼Œå³å¯å¾—åˆ°æœ€ç»ˆçš„ç­”æ¡ˆã€‚



```python [sol1-Python3]
class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        i, j = len(arr1) - 1, len(arr2) - 1
        c = 0
        ans = []
        while i >= 0 or j >= 0 or c:
            a = 0 if i < 0 else arr1[i]
            b = 0 if j < 0 else arr2[j]
            x = a + b + c
            c = 0
            if x >= 2:
                x -= 2
                c -= 1
            elif x == -1:
                x = 1
                c += 1
            ans.append(x)
            i, j = i - 1, j - 1
        while len(ans) > 1 and ans[-1] == 0:
            ans.pop()
        return ans[::-1]
```


```java [sol1-Java]
class Solution {
    public int[] addNegabinary(int[] arr1, int[] arr2) {
        int i = arr1.length - 1, j = arr2.length - 1;
        List<Integer> ans = new ArrayList<>();
        for (int c = 0; i >= 0 || j >= 0 || c != 0; --i, --j) {
            int a = i < 0 ? 0 : arr1[i];
            int b = j < 0 ? 0 : arr2[j];
            int x = a + b + c;
            c = 0;
            if (x >= 2) {
                x -= 2;
                c -= 1;
            } else if (x == -1) {
                x = 1;
                c += 1;
            }
            ans.add(x);
        }
        while (ans.size() > 1 && ans.get(ans.size() - 1) == 0) {
            ans.remove(ans.size() - 1);
        }
        Collections.reverse(ans);
        return ans.stream().mapToInt(x -> x).toArray();
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
        int i = arr1.size() - 1, j = arr2.size() - 1;
        vector<int> ans;
        for (int c = 0; i >= 0 || j >= 0 || c; --i, --j) {
            int a = i < 0 ? 0 : arr1[i];
            int b = j < 0 ? 0 : arr2[j];
            int x = a + b + c;
            c = 0;
            if (x >= 2) {
                x -= 2;
                c -= 1;
            } else if (x == -1) {
                x = 1;
                c += 1;
            }
            ans.push_back(x);
        }
        while (ans.size() > 1 && ans.back() == 0) {
            ans.pop_back();
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```



```go [sol1-Go]
func addNegabinary(arr1 []int, arr2 []int) (ans []int) {
	i, j := len(arr1)-1, len(arr2)-1
	for c := 0; i >= 0 || j >= 0 || c != 0; i, j = i-1, j-1 {
		x := c
		if i >= 0 {
			x += arr1[i]
		}
		if j >= 0 {
			x += arr2[j]
		}
		c = 0
		if x >= 2 {
			x -= 2
			c -= 1
		} else if x == -1 {
			x = 1
			c += 1
		}
		ans = append(ans, x)
	}
	for len(ans) > 1 && ans[len(ans)-1] == 0 {
		ans = ans[:len(ans)-1]
	}
	for i, j = 0, len(ans)-1; i < j; i, j = i+1, j-1 {
		ans[i], ans[j] = ans[j], ans[i]
	}
	return ans
}
```


```ts [sol1-TypeScript]
function addNegabinary(arr1: number[], arr2: number[]): number[] {
    let i = arr1.length - 1,
        j = arr2.length - 1;
    const ans: number[] = [];
    for (let c = 0; i >= 0 || j >= 0 || c; --i, --j) {
        const a = i < 0 ? 0 : arr1[i];
        const b = j < 0 ? 0 : arr2[j];
        let x = a + b + c;
        c = 0;
        if (x >= 2) {
            x -= 2;
            c -= 1;
        } else if (x === -1) {
            x = 1;
            c += 1;
        }
        ans.push(x);
    }
    while (ans.length > 1 && ans[ans.length - 1] === 0) {
        ans.pop();
    }
    return ans.reverse();
}
```

æ—¶é—´å¤æ‚åº¦ $O(\max(n, m))$ï¼Œå…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯ä¸¤ä¸ªæ•°ç»„çš„é•¿åº¦ã€‚å¿½ç•¥ç­”æ¡ˆçš„ç©ºé—´æ¶ˆè€—ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚



---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~