## [491.é€’å¢å­åºåˆ— ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/non-decreasing-subsequences/solutions/100000/491-di-zeng-zi-xu-lie-shen-sou-hui-su-xiang-jie-by)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)
# ç®—æ³•å…¬å¼€è¯¾

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[å›æº¯ç®—æ³•ç²¾è®²ï¼Œæ ‘å±‚å»é‡ä¸æ ‘æå»é‡ | LeetCodeï¼š491.é€’å¢å­åºåˆ—](https://www.bilibili.com/video/BV1EG4y1h78v/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚


## æ€è·¯

è¿™ä¸ªé€’å¢å­åºåˆ—æ¯”è¾ƒåƒæ˜¯å–æœ‰åºçš„å­é›†ã€‚è€Œä¸”æœ¬é¢˜ä¹Ÿè¦æ±‚ä¸èƒ½æœ‰ç›¸åŒçš„é€’å¢å­åºåˆ—ã€‚

è¿™åˆæ˜¯å­é›†ï¼Œåˆæ˜¯å»é‡ï¼Œæ˜¯ä¸æ˜¯ä¸ç”±è‡ªä¸»çš„æƒ³èµ·äº†åˆšåˆšè®²è¿‡çš„[90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)ã€‚

å°±æ˜¯å› ä¸ºå¤ªåƒäº†ï¼Œæ›´è¦æ³¨æ„å·®åˆ«æ‰€åœ¨ï¼Œè¦ä¸å°±æ‰å‘é‡Œäº†ï¼

åœ¨[90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)ä¸­æˆ‘ä»¬æ˜¯é€šè¿‡æ’åºï¼Œå†åŠ ä¸€ä¸ªæ ‡è®°æ•°ç»„æ¥è¾¾åˆ°å»é‡çš„ç›®çš„ã€‚

è€Œæœ¬é¢˜æ±‚è‡ªå¢å­åºåˆ—ï¼Œæ˜¯ä¸èƒ½å¯¹åŸæ•°ç»„è¿›è¡Œæ’åºçš„ï¼Œæ’å®Œåºçš„æ•°ç»„éƒ½æ˜¯è‡ªå¢å­åºåˆ—äº†ã€‚

**æ‰€ä»¥ä¸èƒ½ä½¿ç”¨ä¹‹å‰çš„å»é‡é€»è¾‘ï¼**

æœ¬é¢˜ç»™å‡ºçš„ç¤ºä¾‹ï¼Œè¿˜æ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„ [4, 6, 7, 7]ï¼Œè¿™æ›´å®¹æ˜“è¯¯å¯¼å¤§å®¶æŒ‰ç…§æ’åºçš„æ€è·¯å»åšäº†ã€‚

ä¸ºäº†æœ‰é²œæ˜çš„å¯¹æ¯”ï¼Œæˆ‘ç”¨[4, 7, 6, 7]è¿™ä¸ªæ•°ç»„æ¥ä¸¾ä¾‹ï¼ŒæŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„å¦‚å›¾ï¼š


![image.png](https://pic.leetcode.cn/1674875192-kXIWfU-image.png)



### å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‡½æ•°å‚æ•°

æœ¬é¢˜æ±‚å­åºåˆ—ï¼Œå¾ˆæ˜æ˜¾ä¸€ä¸ªå…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥éœ€è¦startIndexï¼Œè°ƒæ•´ä¸‹ä¸€å±‚é€’å½’çš„èµ·å§‹ä½ç½®ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& nums, int startIndex)
```

* ç»ˆæ­¢æ¡ä»¶

æœ¬é¢˜å…¶å®ç±»ä¼¼æ±‚å­é›†é—®é¢˜ï¼Œä¹Ÿæ˜¯è¦éå†æ ‘å½¢ç»“æ„æ‰¾æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œ[å›æº¯ç®—æ³•ï¼šæ±‚å­é›†é—®é¢˜ï¼](https://programmercarl.com/0078.å­é›†.html)ä¸€æ ·ï¼Œå¯ä»¥ä¸åŠ ç»ˆæ­¢æ¡ä»¶ï¼ŒstartIndexæ¯æ¬¡éƒ½ä¼šåŠ 1ï¼Œå¹¶ä¸ä¼šæ— é™é€’å½’ã€‚

ä½†æœ¬é¢˜æ”¶é›†ç»“æœæœ‰æ‰€ä¸åŒï¼Œé¢˜ç›®è¦æ±‚é€’å¢å­åºåˆ—å¤§å°è‡³å°‘ä¸º2ï¼Œæ‰€ä»¥ä»£ç å¦‚ä¸‹ï¼š

```cpp
if (path.size() > 1) {
    result.push_back(path);
    // æ³¨æ„è¿™é‡Œä¸è¦åŠ returnï¼Œå› ä¸ºè¦å–æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
}
```

* å•å±‚æœç´¢é€»è¾‘


![image.png](https://pic.leetcode.cn/1674875192-kXIWfU-image.png)

åœ¨å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œ**åŒä¸€çˆ¶èŠ‚ç‚¹ä¸‹çš„åŒå±‚ä¸Šä½¿ç”¨è¿‡çš„å…ƒç´ å°±ä¸èƒ½å†ä½¿ç”¨äº†**

é‚£ä¹ˆå•å±‚æœç´¢ä»£ç å¦‚ä¸‹ï¼š

```cpp
unordered_set<int> uset; // ä½¿ç”¨setæ¥å¯¹æœ¬å±‚å…ƒç´ è¿›è¡Œå»é‡
for (int i = startIndex; i < nums.size(); i++) {
    if ((!path.empty() && nums[i] < path.back())
            || uset.find(nums[i]) != uset.end()) {
            continue;
    }
    uset.insert(nums[i]); // è®°å½•è¿™ä¸ªå…ƒç´ åœ¨æœ¬å±‚ç”¨è¿‡äº†ï¼Œæœ¬å±‚åé¢ä¸èƒ½å†ç”¨äº†
    path.push_back(nums[i]);
    backtracking(nums, i + 1);
    path.pop_back();
}
```

**å¯¹äºå·²ç»ä¹ æƒ¯å†™å›æº¯çš„åŒå­¦ï¼Œçœ‹åˆ°é€’å½’å‡½æ•°ä¸Šé¢çš„`uset.insert(nums[i]);`ï¼Œä¸‹é¢å´æ²¡æœ‰å¯¹åº”çš„popä¹‹ç±»çš„æ“ä½œï¼Œåº”è¯¥å¾ˆä¸ä¹ æƒ¯å§ï¼Œå“ˆå“ˆ**

**è¿™ä¹Ÿæ˜¯éœ€è¦æ³¨æ„çš„ç‚¹ï¼Œ`unordered_set<int> uset;` æ˜¯è®°å½•æœ¬å±‚å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨ï¼Œæ–°çš„ä¸€å±‚usetéƒ½ä¼šé‡æ–°å®šä¹‰ï¼ˆæ¸…ç©ºï¼‰ï¼Œæ‰€ä»¥è¦çŸ¥é“usetåªè´Ÿè´£æœ¬å±‚ï¼**


æœ€åæ•´ä½“C++ä»£ç å¦‚ä¸‹ï¼š

```CPP
// ç‰ˆæœ¬ä¸€
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
            // æ³¨æ„è¿™é‡Œä¸è¦åŠ returnï¼Œè¦å–æ ‘ä¸Šçš„èŠ‚ç‚¹
        }
        unordered_set<int> uset; // ä½¿ç”¨setå¯¹æœ¬å±‚å…ƒç´ è¿›è¡Œå»é‡
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back())
                    || uset.find(nums[i]) != uset.end()) {
                    continue;
            }
            uset.insert(nums[i]); // è®°å½•è¿™ä¸ªå…ƒç´ åœ¨æœ¬å±‚ç”¨è¿‡äº†ï¼Œæœ¬å±‚åé¢ä¸èƒ½å†ç”¨äº†
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

## ä¼˜åŒ–

ä»¥ä¸Šä»£ç ç”¨æˆ‘ç”¨äº†`unordered_set<int>`æ¥è®°å½•æœ¬å±‚å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨ã€‚

**å…¶å®ç”¨æ•°ç»„æ¥åšå“ˆå¸Œï¼Œæ•ˆç‡å°±é«˜äº†å¾ˆå¤š**ã€‚

æ³¨æ„é¢˜ç›®ä¸­è¯´äº†ï¼Œæ•°å€¼èŒƒå›´[-100,100]ï¼Œæ‰€ä»¥å®Œå…¨å¯ä»¥ç”¨æ•°ç»„æ¥åšå“ˆå¸Œã€‚

ç¨‹åºè¿è¡Œçš„æ—¶å€™å¯¹unordered_set é¢‘ç¹çš„insertï¼Œunordered_setéœ€è¦åšå“ˆå¸Œæ˜ å°„ï¼ˆä¹Ÿå°±æ˜¯æŠŠkeyé€šè¿‡hash functionæ˜ å°„ä¸ºå”¯ä¸€çš„å“ˆå¸Œå€¼ï¼‰ç›¸å¯¹è´¹æ—¶é—´ï¼Œè€Œä¸”æ¯æ¬¡é‡æ–°å®šä¹‰setï¼Œinsertçš„æ—¶å€™å…¶åº•å±‚çš„ç¬¦å·è¡¨ä¹Ÿè¦åšç›¸åº”çš„æ‰©å……ï¼Œä¹Ÿæ˜¯è´¹äº‹çš„ã€‚

é‚£ä¹ˆä¼˜åŒ–åçš„ä»£ç å¦‚ä¸‹ï¼š

```CPP
// ç‰ˆæœ¬äºŒ
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        int used[201] = {0}; // è¿™é‡Œä½¿ç”¨æ•°ç»„æ¥è¿›è¡Œå»é‡æ“ä½œï¼Œé¢˜ç›®è¯´æ•°å€¼èŒƒå›´[-100, 100]
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back())
                    || used[nums[i] + 100] == 1) {
                    continue;
            }
            used[nums[i] + 100] = 1; // è®°å½•è¿™ä¸ªå…ƒç´ åœ¨æœ¬å±‚ç”¨è¿‡äº†ï¼Œæœ¬å±‚åé¢ä¸èƒ½å†ç”¨äº†
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

è¿™ä»½ä»£ç åœ¨leetcodeä¸Šæäº¤ï¼Œè¦æ¯”ç‰ˆæœ¬ä¸€è€—æ—¶è¦å¥½çš„å¤šã€‚

**æ‰€ä»¥æ­£å¦‚åœ¨[å“ˆå¸Œè¡¨ï¼šæ€»ç»“ç¯‡ï¼ï¼ˆæ¯é€¢æ€»ç»“å¿…ç»å…¸ï¼‰](https://programmercarl.com/å“ˆå¸Œè¡¨æ€»ç»“.html)ä¸­è¯´çš„é‚£æ ·ï¼Œæ•°ç»„ï¼Œsetï¼Œmapéƒ½å¯ä»¥åšå“ˆå¸Œè¡¨ï¼Œè€Œä¸”æ•°ç»„å¹²çš„æ´»ï¼Œmapå’Œsetéƒ½èƒ½å¹²ï¼Œä½†å¦‚æœæ•°å€¼èŒƒå›´å°çš„è¯èƒ½ç”¨æ•°ç»„å°½é‡ç”¨æ•°ç»„**ã€‚


## æ€»ç»“

æœ¬é¢˜é¢˜è§£æ¸…ä¸€è‰²éƒ½è¯´æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œä½†æˆ‘æ›´å€¾å‘äºè¯´å®ƒç”¨å›æº¯æ³•ï¼Œè€Œä¸”æœ¬é¢˜æˆ‘ä¹Ÿæ˜¯å®Œå…¨ä½¿ç”¨å›æº¯æ³•çš„é€»è¾‘æ¥åˆ†æçš„ã€‚

ç›¸ä¿¡å¤§å®¶åœ¨æœ¬é¢˜ä¸­å¤„å¤„éƒ½èƒ½çœ‹åˆ°æ˜¯[å›æº¯ç®—æ³•ï¼šæ±‚å­é›†é—®é¢˜ï¼ˆäºŒï¼‰](https://programmercarl.com/0090.å­é›†II.html)çš„èº«å½±ï¼Œä½†å¤„å¤„åˆéƒ½æ˜¯é™·é˜±ã€‚

**å¯¹äºå…»æˆæ€ç»´å®šå¼æˆ–è€…å¥—æ¨¡æ¿å¥—å—¨äº†çš„åŒå­¦ï¼Œè¿™é“é¢˜èµ·åˆ°äº†å¾ˆå¥½çš„è­¦é†’ä½œç”¨ã€‚æ›´é‡è¦çš„æ˜¯æ‹“å±•äº†å¤§å®¶çš„æ€è·¯ï¼**



## å…¶ä»–è¯­è¨€ç‰ˆæœ¬



```java []
class Solution {
    private List<Integer> path = new ArrayList<>();
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums,0);
        return res;
    }

    private void backtracking (int[] nums, int start) {
        if (path.size() > 1) {
            res.add(new ArrayList<>(path));
        }

        int[] used = new int[201];
        for (int i = start; i < nums.length; i++) {
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1) ||
                    (used[nums[i] + 100] == 1)) continue;
            used[nums[i] + 100] = 1;
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}

//æ³•äºŒï¼šä½¿ç”¨map
class Solution {
    //ç»“æœé›†åˆ
    List<List<Integer>> res = new ArrayList<>();
    //è·¯å¾„é›†åˆ
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        getSubsequences(nums,0);
        return res;
    }
    private void getSubsequences( int[] nums, int start ) {
        if(path.size()>1 ){
            res.add( new ArrayList<>(path) );
            // æ³¨æ„è¿™é‡Œä¸è¦åŠ returnï¼Œè¦å–æ ‘ä¸Šçš„èŠ‚ç‚¹
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=start ;i < nums.length ;i++){
            if(!path.isEmpty() && nums[i]< path.getLast()){
                continue;
            }
            // ä½¿ç”¨è¿‡äº†å½“å‰æ•°å­—
            if ( map.getOrDefault( nums[i],0 ) >=1 ){
                continue;
            }
            map.put(nums[i],map.getOrDefault( nums[i],0 )+1);
            path.add( nums[i] );
            getSubsequences( nums,i+1 );
            path.removeLast();
        }
    }
}
```




```python []
# python3  **å›æº¯**
class Solution:
    def __init__(self):
        self.paths = []
        self.path = []

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        '''
        æœ¬é¢˜æ±‚è‡ªå¢å­åºåˆ—ï¼Œæ‰€ä»¥ä¸èƒ½æ”¹å˜åŸæ•°ç»„é¡ºåº
        '''
        self.backtracking(nums, 0)
        return self.paths

    def backtracking(self, nums: List[int], start_index: int):
        # æ”¶é›†ç»“æœï¼ŒåŒ78.å­é›†ï¼Œä»è¦ç½®äºç»ˆæ­¢æ¡ä»¶ä¹‹å‰
        if len(self.path) >= 2:
            # æœ¬é¢˜è¦æ±‚æ‰€æœ‰çš„èŠ‚ç‚¹
            self.paths.append(self.path[:])
        
        # Base Caseï¼ˆå¯å¿½ç•¥ï¼‰
        if start_index == len(nums):
            return

        # å•å±‚é€’å½’é€»è¾‘
        # æ·±åº¦éå†ä¸­æ¯ä¸€å±‚éƒ½ä¼šæœ‰ä¸€ä¸ªå…¨æ–°çš„usage_listç”¨äºè®°å½•æœ¬å±‚å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨
        usage_list = set()
        # åŒå±‚æ¨ªå‘éå†
        for i in range(start_index, len(nums)):
            # è‹¥å½“å‰å…ƒç´ å€¼å°äºå‰ä¸€ä¸ªæ—¶ï¼ˆéé€’å¢ï¼‰æˆ–è€…æ›¾ç”¨è¿‡ï¼Œè·³å…¥ä¸‹ä¸€å¾ªç¯
            if (self.path and nums[i] < self.path[-1]) or nums[i] in usage_list:
                continue
            usage_list.add(nums[i])
            self.path.append(nums[i])
            self.backtracking(nums, i+1)
            self.path.pop() 

# **å›æº¯+å“ˆå¸Œè¡¨å»é‡**
class Solution:
    def __init__(self):
        self.paths = []
        self.path = []

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        '''
        æœ¬é¢˜æ±‚è‡ªå¢å­åºåˆ—ï¼Œæ‰€ä»¥ä¸èƒ½æ”¹å˜åŸæ•°ç»„é¡ºåº
        '''
        self.backtracking(nums, 0)
        return self.paths

    def backtracking(self, nums: List[int], start_index: int):
        # æ”¶é›†ç»“æœï¼ŒåŒ78.å­é›†ï¼Œä»è¦ç½®äºç»ˆæ­¢æ¡ä»¶ä¹‹å‰
        if len(self.path) >= 2:
            # æœ¬é¢˜è¦æ±‚æ‰€æœ‰çš„èŠ‚ç‚¹
            self.paths.append(self.path[:])
        
        # Base Caseï¼ˆå¯å¿½ç•¥ï¼‰
        if start_index == len(nums):
            return

        # å•å±‚é€’å½’é€»è¾‘
        # æ·±åº¦éå†ä¸­æ¯ä¸€å±‚éƒ½ä¼šæœ‰ä¸€ä¸ªå…¨æ–°çš„usage_listç”¨äºè®°å½•æœ¬å±‚å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨
        usage_list = [False] * 201  # ä½¿ç”¨åˆ—è¡¨å»é‡ï¼Œé¢˜ä¸­å–å€¼èŒƒå›´[-100, 100]
        # åŒå±‚æ¨ªå‘éå†
        for i in range(start_index, len(nums)):
            # è‹¥å½“å‰å…ƒç´ å€¼å°äºå‰ä¸€ä¸ªæ—¶ï¼ˆéé€’å¢ï¼‰æˆ–è€…æ›¾ç”¨è¿‡ï¼Œè·³å…¥ä¸‹ä¸€å¾ªç¯
            if (self.path and nums[i] < self.path[-1]) or usage_list[nums[i]+100] == True:
                continue
            usage_list[nums[i]+100] = True
            self.path.append(nums[i])
            self.backtracking(nums, i+1)
            self.path.pop() 
```


```go []
var (
    res [][]int
    path  []int
)
func findSubsequences(nums []int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(nums))
    dfs(nums, 0)
    return res
}
func dfs(nums []int, start int) {
    if len(path) >= 2 {
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
    }
    used := make(map[int]bool, len(nums))   // åˆå§‹åŒ–usedå­—å…¸ï¼Œç”¨ä»¥å¯¹åŒå±‚å…ƒç´ å»é‡
    for i := start; i < len(nums); i++ {
        if used[nums[i]] {   // å»é‡
            continue
        }
        if len(path) == 0 || nums[i] >= path[len(path)-1] {
            path = append(path, nums[i])
            used[nums[i]] = true
            dfs(nums, i+1)
            path = path[:len(path)-1]
        }
    }
}
```


```Javascript []

var findSubsequences = function(nums) {
    let result = []
    let path = []
    function backtracing(startIndex) {
        if(path.length > 1) {
            result.push(path.slice())
        }
        let uset = []
        for(let i = startIndex; i < nums.length; i++) {
            if((path.length > 0 && nums[i] < path[path.length - 1]) || uset[nums[i] + 100]) {
                continue
            }
            uset[nums[i] + 100] = true
            path.push(nums[i])
            backtracing(i + 1)
            path.pop()
        }
    }
    backtracing(0)
    return result
};

```


```typescript []
function findSubsequences(nums: number[]): number[][] {
    const resArr: number[][] = [];
    backTracking(nums, 0, []);
    return resArr;
    function backTracking(nums: number[], startIndex: number, route: number[]): void {
        let length: number = nums.length;
        if (route.length >= 2) {
            resArr.push(route.slice());
        }
        const usedSet: Set<number> = new Set();
        for (let i = startIndex; i < length; i++) {
            if (
                nums[i] < route[route.length - 1] ||
                usedSet.has(nums[i])
            ) continue;
            usedSet.add(nums[i]);
            route.push(nums[i]);
            backTracking(nums, i + 1, route);
            route.pop();
        }
    }
};
```

```Rust []
 // **å›æº¯+å“ˆå¸Œ**
use std::collections::HashSet;
impl Solution {
    fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, nums: &Vec<i32>, start_index: usize) {
        if path.len() > 1 { result.push(path.clone()); }
        let len = nums.len();
        let mut uset: HashSet<i32> = HashSet::new();
        for i in start_index..len {
            if (!path.is_empty() && nums[i] < *path.last().unwrap()) || uset.contains(&nums[i]) { continue; }
            uset.insert(nums[i]);
            path.push(nums[i]);
            Self::backtracking(result, path, nums, i + 1);
            path.pop();
        }
    }

    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        Self::backtracking(&mut result, &mut path, &nums, 0);
        result
    }
}

// **å›æº¯+æ•°ç»„**
impl Solution {
    fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, nums: &Vec<i32>, start_index: usize) {
        if path.len() > 1 { result.push(path.clone()); }
        let len = nums.len();
        let mut used = [0; 201];
        for i in start_index..len {
            if (!path.is_empty() && nums[i] < *path.last().unwrap()) || used[(nums[i] + 100) as usize] == 1 { continue; }
            used[(nums[i] + 100) as usize] = 1;
            path.push(nums[i]);
            Self::backtracking(result, path, nums, i + 1);
            path.pop();
        }
    }

    pub fn find_subsequences(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        Self::backtracking(&mut result, &mut path, &nums, 0);
        result
    }
}
```


```c []
int* path;
int pathTop;
int** ans;
int ansTop;
int* length;
//å°†å½“å‰pathä¸­çš„å†…å®¹å¤åˆ¶åˆ°ansä¸­
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    memcpy(tempPath, path, pathTop * sizeof(int));
    length[ansTop] = pathTop;
    ans[ansTop++] = tempPath;
}

//æŸ¥æ‰¾usetä¸­æ˜¯å¦å­˜åœ¨å€¼ä¸ºkeyçš„å…ƒç´ 
int find(int* uset, int usetSize, int key) {
    int i;
    for(i = 0; i < usetSize; i++) {
        if(uset[i] == key)
            return 1;
    }
    return 0;
}

void backTracking(int* nums, int numsSize, int startIndex) {
    //å½“pathä¸­å…ƒç´ å¤§äº1ä¸ªæ—¶ï¼Œå°†pathæ‹·è´åˆ°ansä¸­
    if(pathTop > 1) {
        copy();
    }
    int* uset = (int*)malloc(sizeof(int) * numsSize);
    int usetTop = 0;
    int i;
    for(i = startIndex; i < numsSize; i++) {
        //è‹¥å½“å‰å…ƒç´ å°äºpathä¸­æœ€åä¸€ä½å…ƒç´  || åœ¨æ ‘çš„åŒä¸€å±‚æ‰¾åˆ°äº†ç›¸åŒçš„å…ƒç´ ï¼Œåˆ™continue
        if((pathTop > 0 && nums[i] < path[pathTop - 1]) || find(uset, usetTop, nums[i]))
            continue;
        //å°†å½“å‰å…ƒç´ æ”¾å…¥uset
        uset[usetTop++] = nums[i];
        //å°†å½“å‰å…ƒç´ æ”¾å…¥path
        path[pathTop++] = nums[i];
        backTracking(nums, numsSize, i + 1);
        //å›æº¯
        pathTop--;
    }
}

int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //è¾…åŠ©æ•°ç»„åˆå§‹åŒ–
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(sizeof(int*) * 33000);
    length = (int*)malloc(sizeof(int*) * 33000);
    pathTop = ansTop = 0;

    backTracking(nums, numsSize, 0);

    //è®¾ç½®æ•°ç»„ä¸­è¿”å›å…ƒç´ ä¸ªæ•°ï¼Œä»¥åŠæ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```


```swift []
func findSubsequences(_ nums: [Int]) -> [[Int]] {
    var result = [[Int]]()
    var path = [Int]()
    func backtracking(startIndex: Int) {
        // æ”¶é›†ç»“æœï¼Œä½†ä¸è¿”å›ï¼Œå› ä¸ºåç»­è¿˜è¦ä»¥æ­¤åŸºç¡€æ‹¼æ¥
        if path.count > 1 {
            result.append(path)
        }

        var uset = Set<Int>()
        let end = nums.count
        guard startIndex < end else { return } // ç»ˆæ­¢æ¡ä»¶
        for i in startIndex ..< end {
            let num = nums[i]
            if uset.contains(num) { continue } // è·³è¿‡é‡å¤å…ƒç´ 
            if !path.isEmpty, num < path.last! { continue } // ç¡®ä¿é€’å¢
            uset.insert(num) // é€šè¿‡setè®°å½•
            path.append(num) // å¤„ç†ï¼šæ”¶é›†å…ƒç´ 
            backtracking(startIndex: i + 1) // å…ƒç´ ä¸é‡å¤è®¿é—®
            path.removeLast() // å›æº¯
        }
    }
    backtracking(startIndex: 0)
    return result
}
```


```scala []
object Solution {
  import scala.collection.mutable
  def findSubsequences(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()

    def backtracking(startIndex: Int): Unit = {
      // é›†åˆå…ƒç´ å¤§äº1ï¼Œæ·»åŠ åˆ°ç»“æœé›†
      if (path.size > 1) {
        result.append(path.toList)
      }

      var used = new Array[Boolean](201)
      // ä½¿ç”¨å¾ªç¯å®ˆå«ï¼Œå½“å‰å±‚æ²¡æœ‰ç”¨è¿‡çš„å…ƒç´ æ‰æœ‰èµ„æ ¼è¿›å…¥å›æº¯
      for (i <- startIndex until nums.size if !used(nums(i) + 100)) {
        // å¦‚æœpathæ²¡å…ƒç´ æˆ– å½“å‰å¾ªç¯çš„å…ƒç´ æ¯”pathçš„æœ€åä¸€ä¸ªå…ƒç´ å¤§ï¼Œåˆ™å¯ä»¥è¿›å…¥å›æº¯
        if (path.size == 0 || (!path.isEmpty && nums(i) >= path(path.size - 1))) {
          used(nums(i) + 100) = true
          path.append(nums(i))
          backtracking(i + 1)
          path.remove(path.size - 1)
        }
      }
    }

    backtracking(0)
    result.toList
  }
}
```

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
    * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
    * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
    * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
    * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
    * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
    * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
    * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜ 
    * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
    * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
    * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
    * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
    * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
    * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»– 
    * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
    * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

-----------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**


