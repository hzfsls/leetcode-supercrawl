## [1096.èŠ±æ‹¬å·å±•å¼€ II ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/brace-expansion-ii/solutions/100000/python3javacgotypescript-yi-ti-yi-jie-di-gs64)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)


**æ–¹æ³•ä¸€ï¼šé€’å½’**

æˆ‘ä»¬è®¾è®¡ä¸€ä¸ªé€’å½’å‡½æ•° $dfs(exp)$ï¼Œç”¨äºå¤„ç†è¡¨è¾¾å¼ $exp$ï¼Œå¹¶å°†ç»“æœå­˜å…¥é›†åˆ $s$ ä¸­ã€‚

å¯¹äºè¡¨è¾¾å¼ $exp$ï¼Œæˆ‘ä»¬é¦–å…ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªå³èŠ±æ‹¬å·çš„ä½ç½® $j$ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œè¯´æ˜ $exp$ ä¸­æ²¡æœ‰å³èŠ±æ‹¬å·ï¼Œå³ $exp$ ä¸ºå•ä¸€å…ƒç´ ï¼Œç›´æ¥å°† $exp$ åŠ å…¥é›†åˆ $s$ ä¸­å³å¯ã€‚

å¦åˆ™ï¼Œæˆ‘ä»¬ä»ä½ç½® $j$ å¼€å§‹å¾€å·¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå·¦èŠ±æ‹¬å·çš„ä½ç½® $i$ï¼Œæ­¤æ—¶ $exp[:i]$ å’Œ $exp[j + 1:]$ åˆ†åˆ«ä¸º $exp$ çš„å‰ç¼€å’Œåç¼€ï¼Œè®°ä¸º $a$ å’Œ $c$ã€‚è€Œ $exp[i + 1: j]$ ä¸º $exp$ ä¸­èŠ±æ‹¬å·å†…çš„éƒ¨åˆ†ï¼Œå³ $exp$ ä¸­çš„å­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°†å…¶æŒ‰ç…§é€—å·åˆ†å‰²æˆå¤šä¸ªå­—ç¬¦ä¸² $b_1, b_2, \cdots, b_k$ï¼Œç„¶åå¯¹æ¯ä¸ª $b_i$ï¼Œæˆ‘ä»¬å°† $a + b_i + c$ æ‹¼æ¥æˆæ–°çš„è¡¨è¾¾å¼ï¼Œé€’å½’è°ƒç”¨ $dfs$ å‡½æ•°å¤„ç†æ–°çš„è¡¨è¾¾å¼ï¼Œå³ $dfs(a + b_i + c)$ã€‚

æœ€åï¼Œæˆ‘ä»¬å°†é›†åˆ $s$ ä¸­çš„å…ƒç´ æŒ‰ç…§å­—å…¸åºæ’åºï¼Œå³å¯å¾—åˆ°ç­”æ¡ˆã€‚

```python [sol1-Python3]
class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        def dfs(exp):
            j = exp.find('}')
            if j == -1:
                s.add(exp)
                return
            i = exp.rfind('{', 0, j - 1)
            a, c = exp[:i], exp[j + 1:]
            for b in exp[i + 1: j].split(','):
                dfs(a + b + c)

        s = set()
        dfs(expression)
        return sorted(s)
```


```java [sol1-Java]
class Solution {
    private TreeSet<String> s = new TreeSet<>();

    public List<String> braceExpansionII(String expression) {
        dfs(expression);
        return new ArrayList<>(s);
    }

    private void dfs(String exp) {
        int j = exp.indexOf('}');
        if (j == -1) {
            s.add(exp);
            return;
        }
        int i = j;
        while (exp.charAt(i) != '{') {
            --i;
        }
        String a = exp.substring(0, i);
        String c = exp.substring(j + 1);
        for (String b : exp.substring(i + 1, j).split(",")) {
            dfs(a + b + c);
        }
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    vector<string> braceExpansionII(string expression) {
        dfs(expression);
        return vector<string>(s.begin(), s.end());
    }

private:
    set<string> s;

    void dfs(string exp) {
        int j = exp.find_first_of('}');
        if (j == string::npos) {
            s.insert(exp);
            return;
        }
        int i = exp.rfind('{', j);
        string a = exp.substr(0, i);
        string c = exp.substr(j + 1);
        stringstream ss(exp.substr(i + 1, j - i - 1));
        string b;
        while (getline(ss, b, ',')) {
            dfs(a + b + c);
        }
    }
};
```


```go [sol1-Go]
func braceExpansionII(expression string) []string {
	s := map[string]struct{}{}
	var dfs func(string)
	dfs = func(exp string) {
		j := strings.Index(exp, "}")
		if j == -1 {
			s[exp] = struct{}{}
			return
		}
		i := strings.LastIndex(exp[:j], "{")
		a, c := exp[:i], exp[j+1:]
		for _, b := range strings.Split(exp[i+1:j], ",") {
			dfs(a + b + c)
		}
	}
	dfs(expression)
	ans := make([]string, 0, len(s))
	for k := range s {
		ans = append(ans, k)
	}
	sort.Strings(ans)
	return ans
}
```


```ts [sol1-TypeScript]
function braceExpansionII(expression: string): string[] {
    const dfs = (exp: string) => {
        let j = exp.indexOf('}');
        if (j === -1) {
            s.add(exp);
            return;
        }
        let i = j;
        while (exp.charAt(i) !== '{') {
            --i;
        }
        let a = exp.substring(0, i);
        let c = exp.substring(j + 1);
        for (const b of exp.substring(i + 1, j).split(',')) {
            dfs(a + b + c);
        }
    };
    const s: Set<string> = new Set();
    dfs(expression);
    return Array.from(s).sort();
}
```

æ—¶é—´å¤æ‚åº¦çº¦ä¸º $O(n \times 2^{n / 4})$ï¼Œå…¶ä¸­ $n$ ä¸ºè¡¨è¾¾å¼ $expression$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~