## [164.最大间距 中文热门题解1](https://leetcode.cn/problems/maximum-gap/solutions/100000/python3-tong-pai-xu-by-yanghk)

作者：[musiala](https://leetcode.cn/u/musiala)

**前言**：这道题的难点在于如何用线性的时空复杂度来解决。直接sort然后遍历数组当然可以解决问题，但是面试的时候这种解法肯定是不能让面试官满意的。

### 正文
桶排序的两个核心问题：
1. 每个桶的长度是多少？换句话说，每个桶放置元素的范围是什么？
2. 一共要准备多少个桶？

分析和解答：
1. 我们期望将数组中的各个数等距离分配，也就是每个桶的长度相同，也就是对于所有桶来说，桶内最大值减去桶内最小值都是一样的。可以当成公式来记。

$$每个桶的长度 = \max(1,\lfloor{{\max(nums) - \min(nums)} \over {len(nums) - 1}}\rfloor)\tag{1}$$ 

2. 确定桶的数量，最后的加一保证了数组的最大值也能分到一个桶。
$$桶的数量 = \lfloor{{\max(nums) - \min(nums)} \over {每个桶的长度}}\rfloor + 1\tag{2}$$



3. 我们的做法是要将数组中的数放到一个个桶里面，不断更新更大的（后一个桶内元素的最小值 - 前一个桶内元素的最大值），最后就得到了答案。

4. 如何确定每个数应该对应哪个桶？
$$location = {{nums[i] - \min(nums)} \over {每个桶的长度}}\tag3$$

### 举个栗子
nums = [1,3,4,5,6,10,11,12,17]
每个桶的长度 = （17 - 1） / (9-1) = 2
桶的个数 = （17-1）/ 2 + 1 = 9
所以我们的桶为（左闭右开）：
| 区间 | [1,3) | [3,5) | [5,7) | [7,9) | [9,11) | [11,13) | [13,15) | [15,17) | [17,19) |
|------|-------|-------|-------|-------|--------|---------|---------|---------|---------|
| 元素 | 1     | 3,4   | 5,6   |       | 10     | 11,12   |         |         | 17      |

| 差值 | 3-1 = 2 | 5-4 = 1 | 10-6 = 4 | 11-10 = 1 | 17-12 = 5 | 
|------|-------|-------|-------|-------|--------|
答案 = max（差值） = 5

### 更新：
就大家在评论区的讨论做一些说明：
1. 有同学提到可以将（1）式代入到（2）中从而化简得到桶的数量就是数组长度的这一结论，这里是不可以代入化简的，因为我们在这里进行了取整操作。上面的两个公式也相应更新成更严谨的数学表达。
2. 在桶长度这里我们进行了和1取max的操作，这是为了一些边界条件的情况，比如数组是`[1,1,1,1]`。当然我们也可以不取max，把向下取整改为向上取整。
2. 对第一点补充：如果我们把上面栗子的最后一个数改成16，那么每个桶的长度就是1，桶的个数就变成了16，于是出现了7个空桶。
3. 在所有排序算法里，我们一般认为快速排序是速度相对较快的，然而桶排序在大多数情况下比快速排序还要快，但是它付出的代价就是牺牲$O(n)$空间的复杂度，且比归并排序的空间占用要多一点点，多出来的一点点就是可能出现的空桶。

```
class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2: return 0
        
        # 一些初始化
        max_ = max(nums)
        min_ = min(nums)
        max_gap = 0
        
        each_bucket_len = max(1,(max_-min_) // (len(nums)-1))
        buckets =[[] for _ in range((max_-min_) // each_bucket_len + 1)]
        
        # 把数字放入桶中
        for i in range(len(nums)):
            loc = (nums[i] - min_) // each_bucket_len
            buckets[loc].append(nums[i])
        
        # 遍历桶更新答案
        prev_max = float('inf')
        for i in range(len(buckets)):
            if buckets[i] and prev_max != float('inf'):
                max_gap = max(max_gap, min(buckets[i])-prev_max)
            
            if buckets[i]:
                prev_max = max(buckets[i])
                
        return max_gap
```
