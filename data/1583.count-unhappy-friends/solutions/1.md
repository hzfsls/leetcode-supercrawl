## [1583.ç»Ÿè®¡ä¸å¼€å¿ƒçš„æœ‹å‹ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/count-unhappy-friends/solutions/100000/gong-shui-san-xie-ha-xi-biao-mo-ni-ti-by-2qy0)

ä½œè€…ï¼š[AC_OIer](https://leetcode.cn/u/AC_OIer)

## æ¨¡æ‹Ÿ

å¤§å‘¨æœ«çš„ï¼Œè¿™æœ‰å•¥ä¸å¼€å¿ƒçš„ ğŸ¤£

æ¨¡æ‹Ÿé¢˜ï¼Œå…ˆå°†æ‰€æœ‰çš„ $preferences$ ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨å¥—å“ˆå¸Œè¡¨ã€çš„å½¢å¼è¿›è¡Œå­˜å‚¨ï¼Œå­˜å‚¨æ ¼å¼ä¸º `{x : {y : score1}, {z : score2}, ... }`ã€‚

å¦‚æœ $x$ å’Œ $y$ çš„äº²å¯†åº¦è¦æ¯” $x$ å’Œ $z$ çš„äº²å¯†åº¦è¦é«˜ï¼Œåˆ™æœ‰ $score1 > score2$ã€‚åˆ©ç”¨åŸæœ¬ $preferences[i]$ å°±æ˜¯æŒ‰ç…§äº²å¯†åº¦è¿›è¡Œæ’åºï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸‹æ ‡è¿›è¡Œè½¬æ¢ä½œä¸ºäº²å¯†æ•°å¾—åˆ†å³å¯ã€‚

ç„¶åå¯¹æ‰€æœ‰çš„ $pairs$ è¿›è¡Œéå†ï¼Œç»Ÿè®¡æ‰€æœ‰çš„ç­”æ¡ˆï¼Œæ³¨æ„ä¸€ä¸ªå°æœ‹å‹åªèƒ½è¢«ç»Ÿè®¡ä¸€æ¬¡ã€‚

> å½“ç„¶åˆ©ç”¨ $n$ çš„æ•°æ®èŒƒå›´ï¼Œç›´æ¥ä½¿ç”¨äºŒç»´æ•°ç»„å……å½“å“ˆå¸Œè¡¨ä¹Ÿæ˜¯å¯ä»¥çš„ï¼ˆè§ $P2$ï¼‰

ä»£ç ï¼š
```Java []
class Solution {
    Map<Integer, Map<Integer, Integer>> map = new HashMap<>();
    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {
        int m = pairs.length;
        for (int i = 0; i < n; i++) {
            int[] p = preferences[i];
            Map<Integer, Integer> cur = new HashMap<>();
            for (int j = 0; j < n - 1; j++) cur.put(p[j], n - j);
            map.put(i, cur);
        }
        int ans = 0;
        for (int i = 0; i < m; i++) {
            int x = pairs[i][0], y = pairs[i][1];
            boolean xok = false, yok = false;
            for (int j = 0; j < m; j++) {
                if (i == j) continue;
                int u = pairs[j][0], v = pairs[j][1];
                if (!xok && check(x, y, u, v)) xok = true;
                if (!yok && check(y, x, u, v)) yok = true;
                if (xok && yok) break;
            }
            if (xok) ans++;
            if (yok) ans++;
        }
        return ans;
    }
    boolean check(int x, int y, int u, int v) {
        Map<Integer, Integer> xmap = map.get(x), ymap = map.get(y);
        Map<Integer, Integer> umap = map.get(u), vmap = map.get(v);
        if (xmap.get(u) > xmap.get(y) && umap.get(x) > umap.get(v)) return true;
        if (xmap.get(v) > xmap.get(y) && vmap.get(x) > vmap.get(u)) return true;
        return false;
    }
}
```
```Java []
class Solution {
    int N = 510;
    int[][] map = new int[N][N];
    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {
        int m = pairs.length;
        for (int i = 0; i < n; i++) {
            int[] p = preferences[i];
            for (int j = 0; j < n - 1; j++) map[i][p[j]] = n - j;
        }
        int ans = 0;
        for (int i = 0; i < m; i++) {
            int x = pairs[i][0], y = pairs[i][1];
            boolean xok = false, yok = false;
            for (int j = 0; j < m; j++) {
                if (i == j) continue;
                int u = pairs[j][0], v = pairs[j][1];
                if (!xok && check(x, y, u, v)) xok = true;
                if (!yok && check(y, x, u, v)) yok = true;
                if (xok && yok) break;
            }
            if (xok) ans++;
            if (yok) ans++;
        }
        return ans;
    }
    boolean check(int x, int y, int u, int v) {
        if (map[x][u] > map[x][y] && map[u][x] > map[u][v]) return true;
        if (map[x][v] > map[x][y] && map[v][x] > map[v][u]) return true;
        return false;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼šé¢„å¤„ç†å‡º `map` çš„å¤æ‚åº¦ä¸º $O(n^2)$ï¼›éå†ç»Ÿè®¡ç­”æ¡ˆçš„å¤æ‚åº¦ä¸º $O(n^2)$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$