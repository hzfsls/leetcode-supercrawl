## [1637.ä¸¤ç‚¹ä¹‹é—´ä¸åŒ…å«ä»»ä½•ç‚¹çš„æœ€å®½å‚ç›´åŒºåŸŸ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/solutions/100000/python3javacgo-yi-ti-shuang-jie-pai-xu-t-pc0a)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)


**æ–¹æ³•ä¸€ï¼šæ’åº**

æˆ‘ä»¬å¯ä»¥å¯¹æ•°ç»„ $points$ æŒ‰ç…§ $x$ å‡åºæ’åˆ—ï¼Œè·å–ç›¸é‚»ç‚¹ä¹‹é—´ $x$ çš„å·®å€¼çš„æœ€å¤§å€¼ã€‚


```python [sol1-Python3]
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        points.sort()
        return max(b[0] - a[0] for a, b in pairwise(points))
```


```java [sol1-Java]
class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        Arrays.sort(points, (a, b) -> a[0] - b[0]);
        int ans = 0;
        for (int i = 0; i < points.length - 1; ++i) {
            ans = Math.max(ans, points[i + 1][0] - points[i][0]);
        }
        return ans;
    }
}
```


```cpp [sol1-C++]
class Solution {
public:
    int maxWidthOfVerticalArea(vector<vector<int>>& points) {
        sort(points.begin(), points.end());
        int ans = 0;
        for (int i = 0; i < points.size() - 1; ++i) {
            ans = max(ans, points[i + 1][0] - points[i][0]);
        }
        return ans;
    }
};
```



```go [sol1-Go]
func maxWidthOfVerticalArea(points [][]int) (ans int) {
	sort.Slice(points, func(i, j int) bool { return points[i][0] < points[j][0] })
	for i, p := range points[1:] {
		ans = max(ans, p[0]-points[i][0])
	}
	return
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ $points$ çš„é•¿åº¦ã€‚

---

**æ–¹æ³•äºŒï¼šæ¡¶æ’åºï¼ˆçº¿æ€§å¤æ‚åº¦ï¼‰**

æ–¹æ³•ä¸€ä¸­æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \times \log n)$ï¼Œå…¶å®æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ¡¶æ’åºçš„æ€æƒ³ï¼Œå°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° $O(n)$ã€‚

æˆ‘ä»¬å°†æ•°ç»„ $points$ çš„æ¨ªåæ ‡æ”¾å…¥æ•°ç»„ $nums$ ä¸­ã€‚

å‡è®¾æ•°ç»„ $nums$ æœ‰ $n$ ä¸ªå…ƒç´ ï¼Œæ‰€æœ‰å…ƒç´ ä»å°åˆ°å¤§ä¾æ¬¡æ˜¯ $nums_0$ åˆ° $nums_{n - 1}$ï¼Œæœ€å¤§é—´è·æ˜¯ $maxGap$ã€‚è€ƒè™‘æ•°ç»„ä¸­çš„æœ€å¤§å…ƒç´ å’Œæœ€å°å…ƒç´ ä¹‹å·®ï¼š

$$
nums_{n - 1} - nums_0 = \sum_{i = 1}^{n - 1} (nums_i - nums_{i - 1}) \le{maxGap} \times (n - 1)
$$

å› æ­¤ $maxGap \ge \dfrac{nums_{n - 1} - nums_0}{n - 1}$ï¼Œå³æœ€å¤§é—´è·è‡³å°‘ä¸º $\dfrac{nums_{n - 1} - nums_0}{n - 1}$ã€‚

å¯ä»¥åˆ©ç”¨æ¡¶æ’åºçš„æ€æƒ³ï¼Œè®¾å®šæ¡¶çš„å¤§å°ï¼ˆå³æ¯ä¸ªæ¡¶æœ€å¤šåŒ…å«çš„ä¸åŒå…ƒç´ ä¸ªæ•°ï¼‰ä¸º $\dfrac{nums_{n - 1} - nums_0}{n - 1}$ï¼Œå°†å…ƒç´ æŒ‰ç…§å…ƒç´ å€¼å‡åŒ€åˆ†å¸ƒåˆ°å„ä¸ªæ¡¶å†…ï¼Œåˆ™åŒä¸€ä¸ªæ¡¶å†…çš„ä»»æ„ä¸¤ä¸ªå…ƒç´ ä¹‹å·®å°äº ${maxGap}$ï¼Œå·®ä¸º ${maxGap}$ çš„ä¸¤ä¸ªå…ƒç´ ä¸€å®šåœ¨ä¸¤ä¸ªä¸åŒçš„æ¡¶å†…ã€‚å¯¹äºæ¯ä¸ªæ¡¶ï¼Œç»´æŠ¤æ¡¶å†…çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œåˆå§‹æ—¶æ¯ä¸ªæ¡¶å†…çš„æœ€å°å€¼å’Œæœ€å¤§å€¼åˆ†åˆ«æ˜¯æ­£æ— ç©·å’Œè´Ÿæ— ç©·ï¼Œè¡¨ç¤ºæ¡¶å†…æ²¡æœ‰å…ƒç´ ã€‚

éå†æ•°ç»„ ${nums}$ ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚å¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œæ ¹æ®è¯¥å…ƒç´ ä¸æœ€å°å…ƒç´ ä¹‹å·®ä»¥åŠæ¡¶çš„å¤§å°è®¡ç®—è¯¥å…ƒç´ åº”è¯¥åˆ†åˆ°çš„æ¡¶çš„ç¼–å·ï¼Œå¯ä»¥ç¡®ä¿ç¼–å·å°çš„æ¡¶å†…çš„å…ƒç´ éƒ½å°äºç¼–å·å¤§çš„æ¡¶å†…çš„å…ƒç´ ï¼Œä½¿ç”¨å…ƒç´ å€¼æ›´æ–°å…ƒç´ æ‰€åœ¨çš„æ¡¶å†…çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚

éå†æ•°ç»„ç»“æŸä¹‹åï¼Œæ¯ä¸ªéç©ºçš„æ¡¶å†…çš„æœ€å°å€¼å’Œæœ€å¤§å€¼éƒ½å¯ä»¥ç¡®å®šã€‚æŒ‰ç…§æ¡¶çš„ç¼–å·ä»å°åˆ°å¤§çš„é¡ºåºä¾æ¬¡éå†æ¯ä¸ªæ¡¶ï¼Œå½“å‰çš„æ¡¶çš„æœ€å°å€¼å’Œä¸Šä¸€ä¸ªéç©ºçš„æ¡¶çš„æœ€å¤§å€¼æ˜¯æ’åºåçš„ç›¸é‚»å…ƒç´ ï¼Œè®¡ç®—ä¸¤ä¸ªç›¸é‚»å…ƒç´ ä¹‹å·®ï¼Œå¹¶æ›´æ–°æœ€å¤§é—´è·ã€‚éå†æ¡¶ç»“æŸä¹‹åå³å¯å¾—åˆ°æœ€å¤§é—´è·ã€‚


```python [sol2-Python]
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        nums = [x for x, _ in points]
        n = len(nums)
        mi, mx = min(nums), max(nums)
        bucket_size = max(1, (mx - mi) // (n - 1))
        bucket_count = (mx - mi) // bucket_size + 1
        buckets = [[inf, -inf] for _ in range(bucket_count)]
        for x in nums:
            i = (x - mi) // bucket_size
            buckets[i][0] = min(buckets[i][0], x)
            buckets[i][1] = max(buckets[i][1], x)
        ans = 0
        prev = inf
        for curmin, curmax in buckets:
            if curmin > curmax:
                continue
            ans = max(ans, curmin - prev)
            prev = curmax
        return ans
```




```java [sol2-Java]
class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        int n = points.length;
        int[] nums = new int[n];
        for (int i = 0; i < n; ++i) {
            nums[i] = points[i][0];
        }
        final int inf = 1 << 30;
        int mi = inf, mx = -inf;
        for (int v : nums) {
            mi = Math.min(mi, v);
            mx = Math.max(mx, v);
        }
        int bucketSize = Math.max(1, (mx - mi) / (n - 1));
        int bucketCount = (mx - mi) / bucketSize + 1;
        int[][] buckets = new int[bucketCount][2];
        for (var bucket : buckets) {
            bucket[0] = inf;
            bucket[1] = -inf;
        }
        for (int v : nums) {
            int i = (v - mi) / bucketSize;
            buckets[i][0] = Math.min(buckets[i][0], v);
            buckets[i][1] = Math.max(buckets[i][1], v);
        }
        int prev = inf;
        int ans = 0;
        for (var bucket : buckets) {
            if (bucket[0] > bucket[1]) {
                continue;
            }
            ans = Math.max(ans, bucket[0] - prev);
            prev = bucket[1];
        }
        return ans;
    }
}
```



```cpp [sol2-C++]
class Solution {
public:
    int maxWidthOfVerticalArea(vector<vector<int>>& points) {
        int n = points.size();
        vector<int> nums;
        for (auto& p : points) {
            nums.push_back(p[0]);
        }
        const int inf = 1 << 30;
        int mi = inf, mx = -inf;
        for (int v : nums) {
            mi = min(mi, v);
            mx = max(mx, v);
        }
        int bucketSize = max(1, (mx - mi) / (n - 1));
        int bucketCount = (mx - mi) / bucketSize + 1;
        vector<pair<int, int>> buckets(bucketCount, {inf, -inf});
        for (int v : nums) {
            int i = (v - mi) / bucketSize;
            buckets[i].first = min(buckets[i].first, v);
            buckets[i].second = max(buckets[i].second, v);
        }
        int ans = 0;
        int prev = inf;
        for (auto [curmin, curmax] : buckets) {
            if (curmin > curmax) continue;
            ans = max(ans, curmin - prev);
            prev = curmax;
        }
        return ans;
    }
};
```



```go [sol2-Go]
func maxWidthOfVerticalArea(points [][]int) (ans int) {
	n := len(points)
	nums := make([]int, 0, n)
	for _, p := range points {
		nums = append(nums, p[0])
	}
	const inf = 1 << 30
	mi, mx := inf, -inf
	for _, v := range nums {
		mi = min(mi, v)
		mx = max(mx, v)
	}
	bucketSize := max(1, (mx-mi)/(n-1))
	bucketCount := (mx-mi)/bucketSize + 1
	buckets := make([][]int, bucketCount)
	for i := range buckets {
		buckets[i] = []int{inf, -inf}
	}
	for _, v := range nums {
		i := (v - mi) / bucketSize
		buckets[i][0] = min(buckets[i][0], v)
		buckets[i][1] = max(buckets[i][1], v)
	}
	prev := inf
	for _, bucket := range buckets {
		if bucket[0] > bucket[1] {
			continue
		}
		ans = max(ans, bucket[0]-prev)
		prev = bucket[1]
	}
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ $points$ çš„é•¿åº¦ã€‚



---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~