## [37.è§£æ•°ç‹¬ ä¸­æ–‡çƒ­é—¨é¢˜è§£2](https://leetcode.cn/problems/sudoku-solver/solutions/100000/37-jie-shu-du-hui-su-sou-suo-suan-fa-xiang-jie-by-)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)
# ç®—æ³•å…¬å¼€è¯¾

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[å›æº¯ç®—æ³•äºŒç»´é€’å½’ï¼Ÿè§£æ•°ç‹¬ä¸è¿‡å¦‚æ­¤ï¼| LeetCodeï¼š37. è§£æ•°ç‹¬](https://www.bilibili.com/video/BV1TW4y1471V/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚



## æ€è·¯

æ£‹ç›˜æœç´¢é—®é¢˜å¯ä»¥ä½¿ç”¨å›æº¯æ³•æš´åŠ›æœç´¢ï¼Œåªä¸è¿‡è¿™æ¬¡æˆ‘ä»¬è¦åšçš„æ˜¯**äºŒç»´é€’å½’**ã€‚

æ€ä¹ˆåšäºŒç»´é€’å½’å‘¢ï¼Ÿ

å¤§å®¶å·²ç»è·Ÿç€ã€Œä»£ç éšæƒ³å½•ã€åˆ·è¿‡äº†å¦‚ä¸‹å›æº¯æ³•é¢˜ç›®ï¼Œä¾‹å¦‚ï¼š[77.ç»„åˆï¼ˆç»„åˆé—®é¢˜ï¼‰](https://programmercarl.com/0077.ç»„åˆ.html)ï¼Œ[131.åˆ†å‰²å›æ–‡ä¸²ï¼ˆåˆ†å‰²é—®é¢˜ï¼‰](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)ï¼Œ[78.å­é›†ï¼ˆå­é›†é—®é¢˜ï¼‰](https://programmercarl.com/0078.å­é›†.html)ï¼Œ[46.å…¨æ’åˆ—ï¼ˆæ’åˆ—é—®é¢˜ï¼‰](https://programmercarl.com/0046.å…¨æ’åˆ—.html)ï¼Œä»¥åŠ[51.Nçš‡åï¼ˆNçš‡åé—®é¢˜ï¼‰](https://programmercarl.com/0051.Nçš‡å.html)ï¼Œå…¶å®è¿™äº›é¢˜ç›®éƒ½æ˜¯ä¸€ç»´é€’å½’ã€‚

**å¦‚æœä»¥ä¸Šè¿™å‡ é“é¢˜ç›®æ²¡æœ‰åšè¿‡çš„è¯ï¼Œä¸å»ºè®®ä¸Šæ¥å°±åšè¿™é“é¢˜å“ˆï¼**

[Nçš‡åé—®é¢˜](https://programmercarl.com/0051.Nçš‡å.html)æ˜¯å› ä¸ºæ¯ä¸€è¡Œæ¯ä¸€åˆ—åªæ”¾ä¸€ä¸ªçš‡åï¼Œåªéœ€è¦ä¸€å±‚forå¾ªç¯éå†ä¸€è¡Œï¼Œé€’å½’æ¥éå†åˆ—ï¼Œç„¶åä¸€è¡Œä¸€åˆ—ç¡®å®šçš‡åçš„å”¯ä¸€ä½ç½®ã€‚

æœ¬é¢˜å°±ä¸ä¸€æ ·äº†ï¼Œ**æœ¬é¢˜ä¸­æ£‹ç›˜çš„æ¯ä¸€ä¸ªä½ç½®éƒ½è¦æ”¾ä¸€ä¸ªæ•°å­—ï¼ˆè€ŒNçš‡åæ˜¯ä¸€è¡Œåªæ”¾ä¸€ä¸ªçš‡åï¼‰ï¼Œå¹¶æ£€æŸ¥æ•°å­—æ˜¯å¦åˆæ³•ï¼Œè§£æ•°ç‹¬çš„æ ‘å½¢ç»“æ„è¦æ¯”Nçš‡åæ›´å®½æ›´æ·±**ã€‚

å› ä¸ºè¿™ä¸ªæ ‘å½¢ç»“æ„å¤ªå¤§äº†ï¼Œæˆ‘æŠ½å–ä¸€éƒ¨åˆ†ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š



![image.png](https://pic.leetcode.cn/1674878011-YOhThd-image.png)



### å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‡½æ•°ä»¥åŠå‚æ•°

**é€’å½’å‡½æ•°çš„è¿”å›å€¼éœ€è¦æ˜¯boolç±»å‹ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿ**

å› ä¸ºè§£æ•°ç‹¬æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆçš„æ¡ä»¶ï¼ˆå°±åœ¨æ ‘çš„å¶å­èŠ‚ç‚¹ä¸Šï¼‰ç«‹åˆ»å°±è¿”å›ï¼Œç›¸å½“äºæ‰¾ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ä¸€æ¡å”¯ä¸€è·¯å¾„ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨boolè¿”å›å€¼ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```cpp
bool backtracking(vector<vector<char>>& board)
```

* é€’å½’ç»ˆæ­¢æ¡ä»¶

æœ¬é¢˜é€’å½’ä¸ç”¨ç»ˆæ­¢æ¡ä»¶ï¼Œè§£æ•°ç‹¬æ˜¯è¦éå†æ•´ä¸ªæ ‘å½¢ç»“æ„å¯»æ‰¾å¯èƒ½çš„å¶å­èŠ‚ç‚¹å°±ç«‹åˆ»è¿”å›ã€‚

**ä¸ç”¨ç»ˆæ­¢æ¡ä»¶ä¼šä¸ä¼šæ­»å¾ªç¯ï¼Ÿ**

é€’å½’çš„ä¸‹ä¸€å±‚çš„æ£‹ç›˜ä¸€å®šæ¯”ä¸Šä¸€å±‚çš„æ£‹ç›˜å¤šä¸€ä¸ªæ•°ï¼Œç­‰æ•°å¡«æ»¡äº†æ£‹ç›˜è‡ªç„¶å°±ç»ˆæ­¢ï¼ˆå¡«æ»¡å½“ç„¶å¥½äº†ï¼Œè¯´æ˜æ‰¾åˆ°ç»“æœäº†ï¼‰ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»ˆæ­¢æ¡ä»¶ï¼

**é‚£ä¹ˆæœ‰æ²¡æœ‰æ°¸è¿œå¡«ä¸æ»¡çš„æƒ…å†µå‘¢ï¼Ÿ**

è¿™ä¸ªé—®é¢˜æˆ‘åœ¨é€’å½’å•å±‚æœç´¢é€»è¾‘é‡Œå†æ¥è®²ï¼

* é€’å½’å•å±‚æœç´¢é€»è¾‘



![image.png](https://pic.leetcode.cn/1674878011-YOhThd-image.png)

åœ¨æ ‘å½¢å›¾ä¸­å¯ä»¥çœ‹å‡ºæˆ‘ä»¬éœ€è¦çš„æ˜¯ä¸€ä¸ªäºŒç»´çš„é€’å½’ï¼ˆä¹Ÿå°±æ˜¯ä¸¤ä¸ªforå¾ªç¯åµŒå¥—ç€é€’å½’ï¼‰

**ä¸€ä¸ªforå¾ªç¯éå†æ£‹ç›˜çš„è¡Œï¼Œä¸€ä¸ªforå¾ªç¯éå†æ£‹ç›˜çš„åˆ—ï¼Œä¸€è¡Œä¸€åˆ—ç¡®å®šä¸‹æ¥ä¹‹åï¼Œé€’å½’éå†è¿™ä¸ªä½ç½®æ”¾9ä¸ªæ•°å­—çš„å¯èƒ½æ€§ï¼**


ä»£ç å¦‚ä¸‹ï¼šï¼ˆ**è¯¦ç»†çœ‹æ³¨é‡Š**ï¼‰

```CPP
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // éå†è¡Œ
        for (int j = 0; j < board[0].size(); j++) { // éå†åˆ—
            if (board[i][j] != '.') continue;
            for (char k = '1'; k <= '9'; k++) {     // (i, j) è¿™ä¸ªä½ç½®æ”¾kæ˜¯å¦åˆé€‚
                if (isValid(i, j, k, board)) {
                    board[i][j] = k;                // æ”¾ç½®k
                    if (backtracking(board)) return true; // å¦‚æœæ‰¾åˆ°åˆé€‚ä¸€ç»„ç«‹åˆ»è¿”å›
                    board[i][j] = '.';              // å›æº¯ï¼Œæ’¤é”€k
                }
            }
            return false;                           // 9ä¸ªæ•°éƒ½è¯•å®Œäº†ï¼Œéƒ½ä¸è¡Œï¼Œé‚£ä¹ˆå°±è¿”å›false
        }
    }
    return true; // éå†å®Œæ²¡æœ‰è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚æ£‹ç›˜ä½ç½®äº†
}
```

**æ³¨æ„è¿™é‡Œreturn falseçš„åœ°æ–¹ï¼Œè¿™é‡Œæ”¾return false æ˜¯æœ‰è®²ç©¶çš„**ã€‚

å› ä¸ºå¦‚æœä¸€è¡Œä¸€åˆ—ç¡®å®šä¸‹æ¥äº†ï¼Œè¿™é‡Œå°è¯•äº†9ä¸ªæ•°éƒ½ä¸è¡Œï¼Œè¯´æ˜è¿™ä¸ªæ£‹ç›˜æ‰¾ä¸åˆ°è§£å†³æ•°ç‹¬é—®é¢˜çš„è§£ï¼

é‚£ä¹ˆä¼šç›´æ¥è¿”å›ï¼Œ **è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆæ²¡æœ‰ç»ˆæ­¢æ¡ä»¶ä¹Ÿä¸ä¼šæ°¸è¿œå¡«ä¸æ»¡æ£‹ç›˜è€Œæ— é™é€’å½’ä¸‹å»ï¼**

### åˆ¤æ–­æ£‹ç›˜æ˜¯å¦åˆæ³•

åˆ¤æ–­æ£‹ç›˜æ˜¯å¦åˆæ³•æœ‰å¦‚ä¸‹ä¸‰ä¸ªç»´åº¦ï¼š

* åŒè¡Œæ˜¯å¦é‡å¤
* åŒåˆ—æ˜¯å¦é‡å¤
* 9å®«æ ¼é‡Œæ˜¯å¦é‡å¤

ä»£ç å¦‚ä¸‹ï¼š

```CPP
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // åˆ¤æ–­è¡Œé‡Œæ˜¯å¦é‡å¤
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // åˆ¤æ–­åˆ—é‡Œæ˜¯å¦é‡å¤
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // åˆ¤æ–­9æ–¹æ ¼é‡Œæ˜¯å¦é‡å¤
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
```

æœ€åæ•´ä½“C++ä»£ç å¦‚ä¸‹ï¼š


```CPP
class Solution {
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // éå†è¡Œ
        for (int j = 0; j < board[0].size(); j++) { // éå†åˆ—
            if (board[i][j] == '.') {
                for (char k = '1'; k <= '9'; k++) {     // (i, j) è¿™ä¸ªä½ç½®æ”¾kæ˜¯å¦åˆé€‚
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;                // æ”¾ç½®k
                        if (backtracking(board)) return true; // å¦‚æœæ‰¾åˆ°åˆé€‚ä¸€ç»„ç«‹åˆ»è¿”å›
                        board[i][j] = '.';              // å›æº¯ï¼Œæ’¤é”€k
                    }
                }
                return false;  // 9ä¸ªæ•°éƒ½è¯•å®Œäº†ï¼Œéƒ½ä¸è¡Œï¼Œé‚£ä¹ˆå°±è¿”å›false 
            }                
        }
    }
    return true; // éå†å®Œæ²¡æœ‰è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚æ£‹ç›˜ä½ç½®äº†
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // åˆ¤æ–­è¡Œé‡Œæ˜¯å¦é‡å¤
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // åˆ¤æ–­åˆ—é‡Œæ˜¯å¦é‡å¤
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // åˆ¤æ–­9æ–¹æ ¼é‡Œæ˜¯å¦é‡å¤
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};

```

## æ€»ç»“

è§£æ•°ç‹¬å¯ä»¥è¯´æ˜¯éå¸¸éš¾çš„é¢˜ç›®äº†ï¼Œå¦‚æœè¿˜ä¸€ç›´åœç•™åœ¨å•å±‚é€’å½’çš„é€»è¾‘ä¸­ï¼Œè¿™é“é¢˜ç›®å¯ä»¥è®©å¤§å®¶ç¬é—´å´©æºƒã€‚

æ‰€ä»¥æˆ‘åœ¨å¼€ç¯‡å°±æåˆ°äº†**äºŒç»´é€’å½’**ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘è‡ªåˆ›è¯æ±‡ï¼Œå¸Œæœ›å¯ä»¥å¸®åŠ©å¤§å®¶ç†è§£è§£æ•°ç‹¬çš„æœç´¢è¿‡ç¨‹ã€‚

ä¸€æ³¢åˆ†æä¹‹åï¼Œå†çœ‹ä»£ç ä¼šå‘ç°å…¶å®ä¹Ÿä¸éš¾ï¼Œå”¯ä¸€éš¾ç‚¹å°±æ˜¯ç†è§£**äºŒç»´é€’å½’**çš„æ€ç»´é€»è¾‘ã€‚

**è¿™æ ·ï¼Œè§£æ•°ç‹¬è¿™ä¹ˆéš¾çš„é—®é¢˜ï¼Œä¹Ÿè¢«æˆ‘ä»¬æ”»å…‹äº†**ã€‚

**æ­å–œä¸€è·¯ä¸ŠåšæŒæ‰“å¡çš„å½•å‹ä»¬ï¼Œå›æº¯ç®—æ³•å·²ç»æ¥è¿‘å°¾å£°äº†ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è¦ä¸€æ³¢æ€»ç»“äº†**ã€‚


## å…¶ä»–è¯­è¨€ç‰ˆæœ¬


```java []
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board){
        //ã€Œä¸€ä¸ªforå¾ªç¯éå†æ£‹ç›˜çš„è¡Œï¼Œä¸€ä¸ªforå¾ªç¯éå†æ£‹ç›˜çš„åˆ—ï¼Œ
        // ä¸€è¡Œä¸€åˆ—ç¡®å®šä¸‹æ¥ä¹‹åï¼Œé€’å½’éå†è¿™ä¸ªä½ç½®æ”¾9ä¸ªæ•°å­—çš„å¯èƒ½æ€§ï¼ã€
        for (int i = 0; i < 9; i++){ // éå†è¡Œ
            for (int j = 0; j < 9; j++){ // éå†åˆ—
                if (board[i][j] != '.'){ // è·³è¿‡åŸå§‹æ•°å­—
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) è¿™ä¸ªä½ç½®æ”¾kæ˜¯å¦åˆé€‚
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (solveSudokuHelper(board)){ // å¦‚æœæ‰¾åˆ°åˆé€‚ä¸€ç»„ç«‹åˆ»è¿”å›
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9ä¸ªæ•°éƒ½è¯•å®Œäº†ï¼Œéƒ½ä¸è¡Œï¼Œé‚£ä¹ˆå°±è¿”å›false
                return false;
                // å› ä¸ºå¦‚æœä¸€è¡Œä¸€åˆ—ç¡®å®šä¸‹æ¥äº†ï¼Œè¿™é‡Œå°è¯•äº†9ä¸ªæ•°éƒ½ä¸è¡Œï¼Œè¯´æ˜è¿™ä¸ªæ£‹ç›˜æ‰¾ä¸åˆ°è§£å†³æ•°ç‹¬é—®é¢˜çš„è§£ï¼
                // é‚£ä¹ˆä¼šç›´æ¥è¿”å›ï¼Œ ã€Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆæ²¡æœ‰ç»ˆæ­¢æ¡ä»¶ä¹Ÿä¸ä¼šæ°¸è¿œå¡«ä¸æ»¡æ£‹ç›˜è€Œæ— é™é€’å½’ä¸‹å»ï¼ã€
            }
        }
        // éå†å®Œæ²¡æœ‰è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚æ£‹ç›˜ä½ç½®äº†
        return true;
    }

    /**
     * åˆ¤æ–­æ£‹ç›˜æ˜¯å¦åˆæ³•æœ‰å¦‚ä¸‹ä¸‰ä¸ªç»´åº¦:
     *     åŒè¡Œæ˜¯å¦é‡å¤
     *     åŒåˆ—æ˜¯å¦é‡å¤
     *     9å®«æ ¼é‡Œæ˜¯å¦é‡å¤
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // åŒè¡Œæ˜¯å¦é‡å¤
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // åŒåˆ—æ˜¯å¦é‡å¤
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9å®«æ ¼é‡Œæ˜¯å¦é‡å¤
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```

```python []
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.backtracking(board)

    def backtracking(self, board: List[List[str]]) -> bool:
        # è‹¥æœ‰è§£ï¼Œè¿”å›Trueï¼›è‹¥æ— è§£ï¼Œè¿”å›False
        for i in range(len(board)): # éå†è¡Œ
            for j in range(len(board[0])):  # éå†åˆ—
                # è‹¥ç©ºæ ¼å†…å·²æœ‰æ•°å­—ï¼Œè·³è¿‡
                if board[i][j] != '.': continue
                for k in range(1, 10):  
                    if self.is_valid(i, j, k, board):
                        board[i][j] = str(k)
                        if self.backtracking(board): return True
                        board[i][j] = '.'
                # è‹¥æ•°å­—1-9éƒ½ä¸èƒ½æˆåŠŸå¡«å…¥ç©ºæ ¼ï¼Œè¿”å›Falseæ— è§£
                return False
        return True # æœ‰è§£

    def is_valid(self, row: int, col: int, val: int, board: List[List[str]]) -> bool:
        # åˆ¤æ–­åŒä¸€è¡Œæ˜¯å¦å†²çª
        for i in range(9):
            if board[row][i] == str(val):
                return False
        # åˆ¤æ–­åŒä¸€åˆ—æ˜¯å¦å†²çª
        for j in range(9):
            if board[j][col] == str(val):
                return False
        # åˆ¤æ–­åŒä¸€ä¹å®«æ ¼æ˜¯å¦æœ‰å†²çª
        start_row = (row // 3) * 3
        start_col = (col // 3) * 3
        for i in range(start_row, start_row + 3):
            for j in range(start_col, start_col + 3):
                if board[i][j] == str(val):
                    return False
        return True
```


```go []
func solveSudoku(board [][]byte) {
	var backtracking func(board [][]byte) bool
	backtracking = func(board [][]byte) bool {
		for i := 0; i < 9; i++ {
			for j := 0; j < 9; j++ {
				//åˆ¤æ–­æ­¤ä½ç½®æ˜¯å¦é€‚åˆå¡«æ•°å­—
				if board[i][j] != '.' {
					continue
				}
				//å°è¯•å¡«1-9
				for k := '1'; k <= '9'; k++ {
					if isvalid(i, j, byte(k), board) == true { //å¦‚æœæ»¡è¶³è¦æ±‚å°±å¡«
						board[i][j] = byte(k)
						if backtracking(board) == true {
							return true
						}
						board[i][j] = '.'
					}
				}
				return false
			}
		}
		return true
	}
	backtracking(board)
}

//åˆ¤æ–­å¡«å…¥æ•°å­—æ˜¯å¦æ»¡è¶³è¦æ±‚
func isvalid(row, col int, k byte, board [][]byte) bool {
	for i := 0; i < 9; i++ { //è¡Œ
		if board[row][i] == k {
			return false
		}
	}
	for i := 0; i < 9; i++ { //åˆ—
		if board[i][col] == k {
			return false
		}
	}
	//æ–¹æ ¼
	startrow := (row / 3) * 3
	startcol := (col / 3) * 3
	for i := startrow; i < startrow+3; i++ {
		for j := startcol; j < startcol+3; j++ {
			if board[i][j] == k {
				return false
			}
		}
	}
	return true
}
```


```Javascript []
var solveSudoku = function(board) {
    function isValid(row, col, val, board) {
        let len = board.length
        // è¡Œä¸èƒ½é‡å¤
        for(let i = 0; i < len; i++) {
            if(board[row][i] === val) {
                return false
            }
        }
        // åˆ—ä¸èƒ½é‡å¤
        for(let i = 0; i < len; i++) {
            if(board[i][col] === val) {
                return false
            }
        }
        let startRow = Math.floor(row / 3) * 3
        let startCol = Math.floor(col / 3) * 3

        for(let i = startRow; i < startRow + 3; i++) {
            for(let j = startCol; j < startCol + 3; j++) {
                if(board[i][j] === val) {
                    return false
                }
            }
        }

        return true
    }

    function backTracking() {
        for(let i = 0; i < board.length; i++) {
            for(let j = 0; j < board[0].length; j++) {
                if(board[i][j] !== '.') continue
                for(let val = 1; val <= 9; val++) {
                    if(isValid(i, j, `${val}`, board)) {
                        board[i][j] = `${val}`
                        if (backTracking()) {
                            return true
                        }
                        
                        board[i][j] = `.`
                    }
                }
                return false
            }
        }
        return true
    }
    backTracking(board)
    return board
    
};
```


```typescript []
/**
 Do not return anything, modify board in-place instead.
 */
function isValid(col: number, row: number, val: string, board: string[][]): boolean {
    let n: number = board.length;
    // åˆ—å‘æ£€æŸ¥
    for (let rowIndex = 0; rowIndex < n; rowIndex++) {
        if (board[rowIndex][col] === val) return false;
    }
    // æ¨ªå‘æ£€æŸ¥
    for (let colIndex = 0; colIndex < n; colIndex++) {
        if (board[row][colIndex] === val) return false;
    }
    // ä¹å®«æ ¼æ£€æŸ¥
    const startX = Math.floor(col / 3) * 3;
    const startY = Math.floor(row / 3) * 3;
    for (let rowIndex = startY; rowIndex < startY + 3; rowIndex++) {
        for (let colIndex = startX; colIndex < startX + 3; colIndex++) {
            if (board[rowIndex][colIndex] === val) return false;
        }
    }
    return true;
}
function solveSudoku(board: string[][]): void {
    let n: number = 9;
    backTracking(n, board);
    function backTracking(n: number, board: string[][]): boolean {
        for (let row = 0; row < n; row++) {
            for (let col = 0; col < n; col++) {
                if (board[row][col] === '.') {
                    for (let i = 1; i <= n; i++) {
                        if (isValid(col, row, String(i), board)) {
                            board[row][col] = String(i);
                            if (backTracking(n, board) === true) return true;
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
};
```


```Rust []
impl Solution {
    fn is_valid(row: usize, col: usize, val: char, board: &mut Vec<Vec<char>>) -> bool{
        for i in 0..9 {
            if board[row][i] == val { return false; }
        }
        for j in 0..9 {
            if board[j][col] == val {
                return false;
            }
        }
        let  start_row = (row / 3) * 3;
        let  start_col = (col / 3) * 3;
        for i in start_row..(start_row + 3) {
            for j in start_col..(start_col + 3) {
                if board[i][j] == val { return false; }
            }
        }
        return true;
    }

    fn backtracking(board: &mut Vec<Vec<char>>) -> bool{
        for i in 0..board.len() {
            for j in 0..board[0].len() {
                if board[i][j] != '.' { continue; }
                for k in '1'..='9' {
                    if Self::is_valid(i, j, k, board) {
                        board[i][j] = k;
                        if Self::backtracking(board) { return true; }
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }

    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {
        Self::backtracking(board);
    }
}
```


```C []
bool isValid(char** board, int row, int col, int k) {
    /* åˆ¤æ–­å½“å‰è¡Œæ˜¯å¦æœ‰é‡å¤å…ƒç´  */
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == k) {
            return false;
        }
    }
    /* åˆ¤æ–­å½“å‰åˆ—æ˜¯å¦æœ‰é‡å¤å…ƒç´  */
    for (int j = 0; j < 9; j++) {
        if (board[row][j] == k) {
            return false;
        }
    }
    /* è®¡ç®—å½“å‰9å®«æ ¼å·¦ä¸Šè§’çš„ä½ç½® */
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    /* åˆ¤æ–­å½“å‰å…ƒç´ æ‰€åœ¨ä¹å®«æ ¼æ˜¯å¦æœ‰é‡å¤å…ƒç´  */
    for (int i = startRow; i < startRow + 3; i++) {
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == k) {
                return false;
            }
        }
    }
    /* æ»¡è¶³æ¡ä»¶ï¼Œè¿”å›true */
    return true;
}

bool backtracking(char** board, int boardSize, int* boardColSize) {
    /* ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³ä¾æ¬¡éå†è¾“å…¥æ•°ç»„ */
    for (int i = 0; i < boardSize; i++) {
        for (int j = 0; j < *boardColSize; j++) {
            /* é‡åˆ°æ•°å­—è·³è¿‡ */
            if (board[i][j] != '.') {
                continue;
            }
            /* ä¾æ¬¡å°†æ•°ç»„1åˆ°9å¡«å…¥å½“å‰ä½ç½® */
            for (int k = '1'; k <= '9'; k++) {
                /* åˆ¤æ–­å½“å‰ä½ç½®æ˜¯å¦ä¸æ»¡è¶³æ¡ä»¶ï¼Œæ˜¯åˆ™è¿›å…¥ä¸‹ä¸€å±‚ */
                if (isValid(board, i, j, k)) {
                    board[i][j] = k;
                    /* åˆ¤æ–­ä¸‹ä¸€å±‚é€’å½’ä¹‹åæ˜¯å¦æ‰¾åˆ°ä¸€ç§è§£æ³•ï¼Œæ˜¯åˆ™è¿”å›true */
                    if (backtracking(board, boardSize, boardColSize)) {
                        return true;
                    }
                    /* å›æº¯ï¼Œå°†å½“å‰ä½ç½®æ¸…é›¶ */
                    board[i][j] = '.';
                }
            }
            /* è‹¥å¡«å…¥çš„9ä¸ªæ•°å‡ä¸æ»¡è¶³æ¡ä»¶ï¼Œè¿”å›falseï¼Œè¯´æ˜æ­¤è§£æ³•æ— æ•ˆ */
            return false;
        }
    }
    /* éå†å®Œæ‰€æœ‰çš„æ£‹ç›˜ï¼Œæ²¡æœ‰è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†è§£æ³•ï¼Œè¿”å›true */
    return true;
}

void solveSudoku(char** board, int boardSize, int* boardColSize) {
    bool res = backtracking(board, boardSize, boardColSize);
}
```


```swift []
func solveSudoku(_ board: inout [[Character]]) {
    // åˆ¤æ–­å¯¹åº”æ ¼å­çš„å€¼æ˜¯å¦åˆæ³•
    func isValid(row: Int, col: Int, val: Character) -> Bool {
        // è¡Œä¸­æ˜¯å¦é‡å¤
        for i in 0 ..< 9 {
            if board[row][i] == val { return false }
        }

        // åˆ—ä¸­æ˜¯å¦é‡å¤
        for j in 0 ..< 9 {
            if board[j][col] == val { return false }
        }

        // 9æ–¹æ ¼å†…æ˜¯å¦é‡å¤
        let startRow = row / 3 * 3
        let startCol = col / 3 * 3
        for i in startRow ..< startRow + 3 {
            for j in startCol ..< startCol + 3 {
                if board[i][j] == val { return false }
            }
        }
        return true
    }

    @discardableResult
    func backtracking() -> Bool {
        for i in 0 ..< board.count { // iï¼šè¡Œåæ ‡
            for j in 0 ..< board[0].count { // jï¼šåˆ—åæ ‡
                guard board[i][j] == "." else { continue } // è·³è¿‡å·²å¡«å†™æ ¼å­
                // å¡«å†™æ ¼å­
                for val in 1 ... 9 {
                    let charVal = Character("\(val)")
                    guard isValid(row: i, col: j, val: charVal) else { continue } // è·³è¿‡ä¸åˆæ³•çš„
                    board[i][j] = charVal // å¡«å†™
                    if backtracking() { return true }
                    board[i][j] = "." // å›æº¯ï¼šæ“¦é™¤
                }
                return false // éå†å®Œæ•°å­—éƒ½ä¸è¡Œ
            }
        }
        return true // æ²¡æœ‰ä¸åˆæ³•çš„ï¼Œå¡«å†™æ­£ç¡®
    }
    backtracking()
}
```



```scala [] 
// è¯¦ç»†å†™æ³•ï¼š
object Solution {
  
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    backtracking(board)
  }

  def backtracking(board: Array[Array[Char]]): Boolean = {
    for (i <- 0 until 9) {
      for (j <- 0 until 9) {
        if (board(i)(j) == '.') { // å¿…é¡»æ˜¯ä¸º . çš„æ•°å­—æ‰æ”¾æ•°å­—
          for (k <- '1' to '9') { // è¿™ä¸ªä½ç½®æ”¾kæ˜¯å¦åˆé€‚
            if (isVaild(i, j, k, board)) {
              board(i)(j) = k
              if (backtracking(board)) return true // æ‰¾åˆ°äº†ç«‹åˆ»è¿”å›
              board(i)(j) = '.' // å›æº¯
            }
          }
          return false // 9ä¸ªæ•°éƒ½è¯•å®Œäº†ï¼Œéƒ½ä¸è¡Œå°±è¿”å›false
        }
      }
    }
    true // éå†å®Œæ‰€æœ‰çš„éƒ½æ²¡è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†
  }

  def isVaild(x: Int, y: Int, value: Char, board: Array[Array[Char]]): Boolean = {
    // è¡Œ
    for (i <- 0 until 9 ) {
      if (board(i)(y) == value) {
        return false
      }
    }
    
    // åˆ—
    for (j <- 0 until 9) {
      if (board(x)(j) == value) {
        return false
      }
    }

    // å®«
    var row = (x / 3) * 3
    var col = (y / 3) * 3
    for (i <- row until row + 3) {
      for (j <- col until col + 3) {
        if (board(i)(j) == value) {
          return false
        }
      }
    }

    true
  }
}

// éµå¾ªScalaè‡³ç®€åŸåˆ™å†™æ³•ï¼š
object Solution {
  
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    backtracking(board)
  }

  def backtracking(board: Array[Array[Char]]): Boolean = {
    // åŒé‡forå¾ªç¯ + å¾ªç¯å®ˆå«
    for (i <- 0 until 9; j <- 0 until 9 if board(i)(j) == '.') {
      // å¿…é¡»æ˜¯ä¸º . çš„æ•°å­—æ‰æ”¾æ•°å­—ï¼Œä½¿ç”¨å¾ªç¯å®ˆå«åˆ¤æ–­è¯¥ä½ç½®æ˜¯å¦å¯ä»¥æ”¾ç½®å½“å‰å¾ªç¯çš„æ•°å­—
      for (k <- '1' to '9' if isVaild(i, j, k, board)) { // è¿™ä¸ªä½ç½®æ”¾kæ˜¯å¦åˆé€‚
        board(i)(j) = k
        if (backtracking(board)) return true // æ‰¾åˆ°äº†ç«‹åˆ»è¿”å›
        board(i)(j) = '.' // å›æº¯
      }
      return false // 9ä¸ªæ•°éƒ½è¯•å®Œäº†ï¼Œéƒ½ä¸è¡Œå°±è¿”å›false
    }
    true // éå†å®Œæ‰€æœ‰çš„éƒ½æ²¡è¿”å›falseï¼Œè¯´æ˜æ‰¾åˆ°äº†
  }

  def isVaild(x: Int, y: Int, value: Char, board: Array[Array[Char]]): Boolean = {
    // è¡Œï¼Œå¾ªç¯å®ˆå«è¿›è¡Œåˆ¤æ–­
    for (i <- 0 until 9 if board(i)(y) == value) return false
    // åˆ—ï¼Œå¾ªç¯å®ˆå«è¿›è¡Œåˆ¤æ–­
    for (j <- 0 until 9 if board(x)(j) == value) return false
    // å®«ï¼Œå¾ªç¯å®ˆå«è¿›è¡Œåˆ¤æ–­
    var row = (x / 3) * 3
    var col = (y / 3) * 3
    for (i <- row until row + 3; j <- col until col + 3 if board(i)(j) == value) return false
    true // æœ€ç»ˆæ²¡æœ‰è¿”å›falseï¼Œå°±è¯´æ˜è¯¥ä½ç½®å¯ä»¥å¡«å†™true
  }
}
```



# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
    * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
    * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
    * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
    * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
    * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
    * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
    * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜ 
    * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
    * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
    * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
    * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
    * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
    * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»– 
    * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
    * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

-----------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**


