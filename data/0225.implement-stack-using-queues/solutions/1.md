## [225.ç”¨é˜Ÿåˆ—å®ç°æ ˆ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/implement-stack-using-queues/solutions/100000/wu-tu-guan-fang-tui-jian-ti-jie-yong-dui-63d4)

ä½œè€…ï¼š[demigodliu](https://leetcode.cn/u/demigodliu)
![å›¾è§£æ¯æ—¥ä¸€ç»ƒ.jpg](https://pic.leetcode-cn.com/1615817903-fzmpwZ-%E5%9B%BE%E8%A7%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83.jpg)

---

### ğŸ§  è§£é¢˜æ€è·¯

æ ¹æ®é¢˜æ„ï¼Œè¦ç”¨ä¸¤ä¸ªé˜Ÿåˆ—æ¥å®ç°æ ˆï¼Œé¦–å…ˆæˆ‘ä»¬çŸ¥é“ï¼Œé˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºï¼Œæ ˆæ˜¯åè¿›å…ˆå‡ºã€‚

çŸ¥é“äº†ä»¥ä¸Šè¦ç‚¹ï¼Œæˆ‘ä»¬ä¸¤ä¸ªé˜Ÿåˆ—çš„ç”¨å¤„ä¹Ÿå°±ä¸€ç›®äº†ç„¶äº†ã€‚

ä¸€ä¸ªé˜Ÿåˆ—ä¸ºä¸»é˜Ÿåˆ—ï¼Œä¸€ä¸ªä¸ºè¾…åŠ©é˜Ÿåˆ—ï¼Œå½“å…¥æ ˆæ“ä½œæ—¶ï¼Œæˆ‘ä»¬å…ˆå°†ä¸»é˜Ÿåˆ—å†…å®¹å¯¼å…¥è¾…åŠ©é˜Ÿåˆ—ï¼Œç„¶åå°†å…¥æ ˆå…ƒç´ æ”¾å…¥ä¸»é˜Ÿåˆ—é˜Ÿå¤´ä½ç½®ï¼Œå†å°†è¾…åŠ©é˜Ÿåˆ—å†…å®¹ï¼Œä¾æ¬¡æ·»åŠ è¿›ä¸»é˜Ÿåˆ—å³å¯ã€‚

---

### ğŸ¨ å›¾è§£æ¼”ç¤º

<![1.jpg](https://pic.leetcode-cn.com/1616751308-OfYZxa-1.jpg),![2.jpg](https://pic.leetcode-cn.com/1616751310-nQTVbz-2.jpg),![3.jpg](https://pic.leetcode-cn.com/1616751312-JQIGdm-3.jpg),![4.jpg](https://pic.leetcode-cn.com/1616751314-YtBFRr-4.jpg),![5.jpg](https://pic.leetcode-cn.com/1616751315-ATQmxv-5.jpg),![6.jpg](https://pic.leetcode-cn.com/1616751317-rHIteP-6.jpg),![7.jpg](https://pic.leetcode-cn.com/1616751323-urFmLs-7.jpg)>

---

### ğŸ­ ç¤ºä¾‹ä»£ç 

```Javascript []
let MyStack = function() {
    this.queue = [];
    this._queue = [];
};

MyStack.prototype.push = function(x) {
    this.queue.push(x);
};

MyStack.prototype.pop = function() {
    while(this.queue.length > 1){
        this._queue.push(this.queue.shift());
    }
    let ans = this.queue.shift();
    while(this._queue.length){
        this.queue.push(this._queue.shift());
    }
    return ans;
};

MyStack.prototype.top = function() {
    return this.queue.slice(-1)[0];
};

MyStack.prototype.empty = function() {
    return !this.queue.length;
};
```
```Java []
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```
```C++ []
class MyStack {
public:
    queue<int> queue1;
    queue<int> queue2;

    MyStack() {

    }

    void push(int x) {
        queue2.push(x);
        while (!queue1.empty()) {
            queue2.push(queue1.front());
            queue1.pop();
        }
        swap(queue1, queue2);
    }
    
    int pop() {
        int r = queue1.front();
        queue1.pop();
        return r;
    }
    
    int top() {
        int r = queue1.front();
        return r;
    }
    
    bool empty() {
        return queue1.empty();
    }
};
```
```Python3 []
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue1 = collections.deque()
        self.queue2 = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue1.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue1[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue1
```
```Golang []
type MyStack struct {
    queue1, queue2 []int
}

func Constructor() (s MyStack) {
    return
}

func (s *MyStack) Push(x int) {
    s.queue2 = append(s.queue2, x)
    for len(s.queue1) > 0 {
        s.queue2 = append(s.queue2, s.queue1[0])
        s.queue1 = s.queue1[1:]
    }
    s.queue1, s.queue2 = s.queue2, s.queue1
}

func (s *MyStack) Pop() int {
    v := s.queue1[0]
    s.queue1 = s.queue1[1:]
    return v
}

func (s *MyStack) Top() int {
    return s.queue1[0]
}

func (s *MyStack) Empty() bool {
    return len(s.queue1) == 0
}
```
```C []

#define LEN 20
typedef struct queue {
    int *data;
    int head;
    int rear;
    int size;
} Queue;

typedef struct {
    Queue *queue1, *queue2;
} MyStack;

Queue *initQueue(int k) {
    Queue *obj = (Queue *)malloc(sizeof(Queue));
    obj->data = (int *)malloc(k * sizeof(int));
    obj->head = -1;
    obj->rear = -1;
    obj->size = k;
    return obj;
}

void enQueue(Queue *obj, int e) {
    if (obj->head == -1) {
        obj->head = 0;
    }
    obj->rear = (obj->rear + 1) % obj->size;
    obj->data[obj->rear] = e;
}

int deQueue(Queue *obj) {
    int a = obj->data[obj->head];
    if (obj->head == obj->rear) {
        obj->rear = -1;
        obj->head = -1;
        return a;
    }
    obj->head = (obj->head + 1) % obj->size;
    return a;
}

int isEmpty(Queue *obj) {
    return obj->head == -1;
}

MyStack *myStackCreate() {
    MyStack *obj = (MyStack *)malloc(sizeof(MyStack));
    obj->queue1 = initQueue(LEN);
    obj->queue2 = initQueue(LEN);
    return obj;
}

void myStackPush(MyStack *obj, int x) {
    if (isEmpty(obj->queue1)) {
        enQueue(obj->queue2, x);
    } else {
        enQueue(obj->queue1, x);
    }
}

int myStackPop(MyStack *obj) {
    if (isEmpty(obj->queue1)) {
        while (obj->queue2->head != obj->queue2->rear) {
            enQueue(obj->queue1, deQueue(obj->queue2));
        }
        return deQueue(obj->queue2);
    }
    while (obj->queue1->head != obj->queue1->rear) {
        enQueue(obj->queue2, deQueue(obj->queue1));
    }
    return deQueue(obj->queue1);
}

int myStackTop(MyStack *obj) {
    if (isEmpty(obj->queue1)) {
        return obj->queue2->data[obj->queue2->rear];
    }
    return obj->queue1->data[obj->queue1->rear];
}

bool myStackEmpty(MyStack *obj) {
    if (obj->queue1->head == -1 && obj->queue2->head == -1) {
        return true;
    }
    return false;
}

void myStackFree(MyStack *obj) {
    free(obj->queue1->data);
    obj->queue1->data = NULL;
    free(obj->queue1);
    obj->queue1 = NULL;
    free(obj->queue2->data);
    obj->queue2->data = NULL;
    free(obj->queue2);
    obj->queue2 = NULL;
    free(obj);
    obj = NULL;
}
```

---

### è½¬èº«æŒ¥æ‰‹

å˜¿ï¼Œå°‘å¹´ï¼Œåšå›¾ä¸æ˜“ï¼Œç•™ä¸‹ä¸ªèµæˆ–è¯„è®ºå†èµ°å§ï¼è°¢å•¦~ ğŸ’

å·®ç‚¹å¿˜äº†ï¼Œç¥ä½ ç‰›å¹´å¤§å‰ ğŸ® ï¼ŒAC å’Œ Offer ğŸ“‘ å¤šå¤šç›Šå–„~

â›²â›²â›² æœŸå¾…ä¸‹æ¬¡å†è§~ 