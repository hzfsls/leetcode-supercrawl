## [34.在排序数组中查找元素的第一个和最后一个位置 中文热门题解1](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/100000/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc)

作者：[lin-shen-shi-jian-lu-k](https://leetcode.cn/u/lin-shen-shi-jian-lu-k)
### 1、思路

**(二分)**  $O(logn)$  

在一个范围内，查找一个数字，要求找到这个元素的开始位置和结束位置，这个范围内的数字都是单调递增的，即具有单调性质，因此可以使用二分来做。 

![](https://pic.leetcode-cn.com/1629777455-UMFPFX-file_1629777455526){:width="65%"}


两次二分，第一次二分查找第一个$>=target$的位置，第二次二分查找最后一个$<=target$的位置。查找成功则返回两个位置下标，否则返回$[-1,-1]$。


**二分模板：** 

**模板1**

当我们将区间$[l, r]$划分成$[l, mid]$和$[mid + 1, r]$时，其更新操作是$r = mid$或者$l = mid + 1$，计算$mid$时不需要加$1$，即$mid = (l + r)/2$。 

**C++/java代码模板：**

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = (l + r)/2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

**模板2**

当我们将区间$[l, r]$划分成$[l, mid - 1]$和$[mid, r]$时，其更新操作是$r = mid - 1$或者$l = mid$，此时为了防止死循环，计算$mid$时需要加$1$，即$mid = ( l + r + 1 ) /2$。 

**C++/java 代码模板：** 

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = ( l + r + 1 ) /2;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
**为什么两个二分模板$mid$取值不同？** 

对于第二个模板，当我们更新区间时，如果左边界$l$更新为$l = mid$，此时$mid$的取值就应为$mid = (l + r + 1)/ 2$。因为当右边界$r = l + 1$时，此时$mid = (l + l + 1)/2$，下取整，$mid$仍为$l$，左边界再次更新为$l = mid = l$，相当于没有变化，$while$循环就会陷入死循环。因此，我们总结出来一个小技巧，当左边界要更新为$l = mid$时，我们就令 $mid =(l + r + 1)/2$，上取整，此时就不会因为$r$取特殊值$r = l + 1$而陷入死循环了。


而对于第一个模板，如果左边界$l$更新为$l = mid + 1$，是不会出现这样的困扰的。因此，大家可以熟记这两个二分模板，基本上可以解决$99%$以上的二分问题，再也不会被二分的边界取值所困扰了。

**什么时候用模板1？什么时候用模板2？** 



假设初始时我们的二分区间为$[l,r]$，每次二分缩小区间时，如果左边界$l$要更新为 $l = mid$，此时我们就要使用模板2，让 $mid = (l + r + 1)/ 2$，否则$while$会陷入死循环。如果左边界$l$更新为$l = mid + 1$,此时我们就使用模板1，让$mid = (l + r)/2$。因此，模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是$l = mid$，那么在计算$mid$时需要加上$1$，否则如果写完之后发现是$l = mid + 1$，那么在计算$mid$时不能加$1$。




**为什么模板要取while( l < r)，而不是while( l <= r)？**


本质上取$l < r$ 和 $l <= r$是没有任何区别的，只是习惯问题，如果取$l <= r$，只需要修改对应的更新区间即可。


**while循环结束条件是l >= r，但为什么二分结束时我们优先取r而不是l?**


二分的$while$循环的结束条件是$l >= r$，所以在循环结束时$l$有可能会大于$r$，此时就可能导致越界，因此，基本上二分问题优先取$r$都不会翻车。


**实现细节：**

- 二分查找时，首先要确定我们要查找的边界值，保证每次二分缩小区间时，边界值始终包含在内。
- 注意看下面的每张图，最后的答案就是红色箭头指出的位置，也是我们二分的边界值。如果不清楚每次二分时，区间是如何更新的，可以画出和下面类似的图，每次更新区间时，要保证边值始终包含在内，这样关于左右边界的更新就会一目了然。


**第一次查找起始位置:** 

- 1、二分的范围，$l = 0$， $r = nums.size() - 1$，我们去二分查找$>=target$的最左边界。

- 2、当$nums[mid] >= target$时，往左半区域找，$r = mid$。


![](https://pic.leetcode-cn.com/1629777618-TxbKzQ-file_1629777618424){:width="65%"}



- 3、当$nums[mid] < target$时， 往右半区域找，$l = mid + 1$。


![](https://pic.leetcode-cn.com/1629777618-MlQEQA-file_1629777618427){:width="65%"}


- 4、如果$nums[r] != target$，说明数组中不存在目标值 $target$，返回 $[-1, -1]$。否则我们就找到了第一个$>=target$的位置$L$。

**第二次查找结束位置：**

- 1、二分的范围，$l = 0$， $r = nums.size() - 1$，我们去二分查找$<=target$的最右边界。

- 2、当$nums[mid] <= target$时，往右半区域找，$l = mid$。


![](https://pic.leetcode-cn.com/1629777618-VJUqiS-file_1629777618429){:width="65%"}




- 3、当$nums[mid] > target$时， 往左半区域找，$r = mid - 1$。 

![](https://pic.leetcode-cn.com/1629777618-IxXaMK-file_1629777618431){:width="65%"}



- 4、找到了最后一个$<=target$的位置$R$，返回区间$[L,R]$即可。



**时间复杂度分析：** 两次二分查找的时间复杂度为 $O(logn)$。

### 2、c++代码

```c
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.empty()) return {-1,-1};
    
        int l = 0, r = nums.size() - 1; //二分范围
        while( l < r)			        //查找元素的开始位置
        {
            int mid = (l + r )/2;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if( nums[r] != target) return {-1,-1};  //查找失败
        int L = r;
        l = 0, r = nums.size() - 1;     //二分范围
        while( l < r)                   //查找元素的结束位置
        {
            int mid = (l + r + 1)/2;
            if(nums[mid] <= target ) l = mid;
            else r = mid - 1;
        }
        return {L,r};
    }
};
```

### 3、java代码

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length == 0) return new int[]{-1,-1};
    
        int l = 0, r = nums.length - 1; //二分范围
        while( l < r)			        //查找元素的开始位置
        {
            int mid = (l + r )/2;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if( nums[r] != target) return new int[]{-1,-1}; //查找失败
        int L = r;
        l = 0; r = nums.length - 1;     //二分范围
        while( l < r)			        //查找元素的结束位置
        {
            int mid = (l + r + 1)/2;
            if(nums[mid] <= target ) l = mid;
            else r = mid - 1;
        }
        return new int[]{L,r};
    }
}
```

做个总结，有很多人私信我这个二分模板的一些细节问题，如下：
- 为什么模板要取$while( l < r)$,而不是$while( l <= r)$？ 
- 两个二分模板什么时候 $mid = ( l + r) / 2$，什么时候 $mid = ( l + r + 1) / 2$？
-  $while$循环结束条件是$l >= r$,但为什么二分结束时我们优先取$r$而不是$l$?


这些问题我在评论区和实现细节中都做出了补充，在这里做一个统一回复： 关于二分的模板大家在网上可以搜出很多，不同的二分模板，很多地方的实现细节总是不同，因此我们在套用那些模板时，往往被细节和边界问题所折磨，我可以负责人的指出，**y总**的这套二分模板可以解决99%以上的整数二分问题，大家只需要熟记这套模板和实现细节，遇到整数二分问题时，只需要考虑是套用1模板还是套用2模板，其他的细节通通不用再考虑了。


