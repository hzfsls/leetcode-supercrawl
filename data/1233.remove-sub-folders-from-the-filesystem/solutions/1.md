## [1233.åˆ é™¤å­æ–‡ä»¶å¤¹ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/solutions/100000/python3javacgo-yi-ti-shuang-jie-pai-xu-z-dha2)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)

**æ–¹æ³•ä¸€ï¼šæ’åº**

æˆ‘ä»¬å…ˆå°†æ•°ç»„ `folder` æŒ‰ç…§å­—å…¸åºæ’åºï¼Œç„¶åéå†æ•°ç»„ï¼Œå¯¹äºå½“å‰éå†åˆ°çš„æ–‡ä»¶å¤¹ $f$ï¼Œå¦‚æœå®ƒçš„é•¿åº¦å¤§äºç­‰äºç­”æ¡ˆæ•°ç»„ä¸­æœ€åä¸€ä¸ªæ–‡ä»¶å¤¹çš„é•¿åº¦ï¼Œå¹¶ä¸”å®ƒçš„å‰ç¼€åŒ…å«ç­”æ¡ˆæ•°ç»„çš„æœ€åä¸€ä¸ªæ–‡ä»¶å¤¹å†åŠ ä¸Šä¸€ä¸ª `/`ï¼Œåˆ™è¯´æ˜ $f$ æ˜¯ç­”æ¡ˆæ•°ç»„ä¸­æœ€åä¸€ä¸ªæ–‡ä»¶å¤¹çš„å­æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬ä¸éœ€è¦å°†å…¶åŠ å…¥ç­”æ¡ˆæ•°ç»„ä¸­ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å°† $f$ åŠ å…¥ç­”æ¡ˆæ•°ç»„ä¸­ã€‚

éå†ç»“æŸåï¼Œç­”æ¡ˆæ•°ç»„ä¸­çš„æ–‡ä»¶å¤¹å³ä¸ºé¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆã€‚


```python [sol1-Python3]
class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort()
        ans = [folder[0]]
        for f in folder[1:]:
            m, n = len(ans[-1]), len(f)
            if m >= n or not (ans[-1] == f[:m] and f[m] == '/'):
                ans.append(f)
        return ans
```


```java [sol1-Java]
class Solution {
    public List<String> removeSubfolders(String[] folder) {
        Arrays.sort(folder);
        List<String> ans = new ArrayList<>();
        ans.add(folder[0]);
        for (int i = 1; i < folder.length; ++i) {
            int m = ans.get(ans.size() - 1).length();
            int n = folder[i].length();
            if (m >= n || !(ans.get(ans.size() - 1).equals(folder[i].substring(0, m)) && folder[i].charAt(m) == '/')) {
                ans.add(folder[i]);
            }
        }
        return ans;
    }
}
```

```cpp [sol1-C++]
class Solution {
public:
    vector<string> removeSubfolders(vector<string>& folder) {
        sort(folder.begin(), folder.end());
        vector<string> ans = {folder[0]};
        for (int i = 1; i < folder.size(); ++i) {
            int m = ans.back().size();
            int n = folder[i].size();
            if (m >= n || !(ans.back() == folder[i].substr(0, m) && folder[i][m] == '/')) {
                ans.emplace_back(folder[i]);
            }
        }
        return ans;
    }
};
```


```go [sol1-Go]
func removeSubfolders(folder []string) []string {
	sort.Strings(folder)
	ans := []string{folder[0]}
	for _, f := range folder[1:] {
		m, n := len(ans[len(ans)-1]), len(f)
		if m >= n || !(ans[len(ans)-1] == f[:m] && f[m] == '/') {
			ans = append(ans, f)
		}
	}
	return ans
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n \times m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸ºæ•°ç»„ `folder` çš„é•¿åº¦å’Œæ•°ç»„ `folder` ä¸­å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚

---

**æ–¹æ³•äºŒï¼šå­—å…¸æ ‘**

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å­—å…¸æ ‘å­˜å‚¨æ•°ç»„ `folder` ä¸­çš„æ‰€æœ‰æ–‡ä»¶å¤¹ã€‚å­—å…¸æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹åŒ…å« `children` å­—æ®µï¼Œç”¨äºå­˜å‚¨å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œä»¥åŠ `fid` å­—æ®µï¼Œç”¨äºå­˜å‚¨å½“å‰èŠ‚ç‚¹å¯¹åº”çš„æ–‡ä»¶å¤¹åœ¨æ•°ç»„ `folder` ä¸­çš„ä¸‹æ ‡ã€‚

å¯¹äºæ•°ç»„ `folder` ä¸­çš„æ¯ä¸ªæ–‡ä»¶å¤¹ $f$ï¼Œæˆ‘ä»¬å…ˆå°† $f$ æŒ‰ç…§ `/` åˆ†å‰²æˆè‹¥å¹²ä¸ªå­ä¸²ï¼Œç„¶åä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¾æ¬¡å°†å­ä¸²åŠ å…¥å­—å…¸æ ‘ä¸­ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä»æ ¹èŠ‚ç‚¹å¼€å§‹æœç´¢å­—å…¸æ ‘ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹çš„ `fid` å­—æ®µä¸ä¸º `-1`ï¼Œåˆ™è¯´æ˜å½“å‰èŠ‚ç‚¹å¯¹åº”çš„æ–‡ä»¶å¤¹æ˜¯ç­”æ¡ˆæ•°ç»„ä¸­çš„ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬å°†å…¶åŠ å…¥ç­”æ¡ˆæ•°ç»„å¹¶ä¸”è¿”å›ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬é€’å½’åœ°æœç´¢å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œæœ€ç»ˆè¿”å›ç­”æ¡ˆæ•°ç»„ã€‚


```python [sol2-Python3]
class Trie:
    def __init__(self):
        self.children = {}
        self.fid = -1

    def insert(self, i, f):
        node = self
        ps = f.split('/')
        for p in ps[1:]:
            if p not in node.children:
                node.children[p] = Trie()
            node = node.children[p]
        node.fid = i

    def search(self):
        def dfs(root):
            if root.fid != -1:
                ans.append(root.fid)
                return
            for child in root.children.values():
                dfs(child)

        ans = []
        dfs(self)
        return ans

class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        trie = Trie()
        for i, f in enumerate(folder):
            trie.insert(i, f)
        return [folder[i] for i in trie.search()]
```



```java [sol2-Java]
class Trie {
    private Map<String, Trie> children = new HashMap<>();
    private int fid = -1;

    public void insert(int fid, String f) {
        Trie node = this;
        String[] ps = f.split("/");
        for (int i = 1; i < ps.length; ++i) {
            String p = ps[i];
            if (!node.children.containsKey(p)) {
                node.children.put(p, new Trie());
            }
            node = node.children.get(p);
        }
        node.fid = fid;
    }

    public List<Integer> search() {
        List<Integer> ans = new ArrayList<>();
        dfs(this, ans);
        return ans;
    }

    private void dfs(Trie root, List<Integer> ans) {
        if (root.fid != -1) {
            ans.add(root.fid);
            return;
        }
        for (var child : root.children.values()) {
            dfs(child, ans);
        }
    }
}

class Solution {
    public List<String> removeSubfolders(String[] folder) {
        Trie trie = new Trie();
        for (int i = 0; i < folder.length; ++i) {
            trie.insert(i, folder[i]);
        }
        List<String> ans = new ArrayList<>();
        for (int i : trie.search()) {
            ans.add(folder[i]);
        }
        return ans;
    }
}
```

```cpp [sol2-C++]
class Trie {
public:
    void insert(int fid, string& f) {
        Trie* node = this;
        vector<string> ps = split(f, '/');
        for (int i = 1; i < ps.size(); ++i) {
            auto& p = ps[i];
            if (!node->children.count(p)) {
                node->children[p] = new Trie();
            }
            node = node->children[p];
        }
        node->fid = fid;
    }

    vector<int> search() {
        vector<int> ans;
        function<void(Trie*)> dfs = [&](Trie* root) {
            if (root->fid != -1) {
                ans.push_back(root->fid);
                return;
            }
            for (auto& [_, child] : root->children) {
                dfs(child);
            }
        };
        dfs(this);
        return ans;
    }

    vector<string> split(string& s, char delim) {
        stringstream ss(s);
        string item;
        vector<string> res;
        while (getline(ss, item, delim)) {
            res.emplace_back(item);
        }
        return res;
    }

private:
    unordered_map<string, Trie*> children;
    int fid = -1;
};

class Solution {
public:
    vector<string> removeSubfolders(vector<string>& folder) {
        Trie* trie = new Trie();
        for (int i = 0; i < folder.size(); ++i) {
            trie->insert(i, folder[i]);
        }
        vector<string> ans;
        for (int i : trie->search()) {
            ans.emplace_back(folder[i]);
        }
        return ans;
    }
};
```


```go [sol2-Go]
type Trie struct {
	children map[string]*Trie
	fid      int
}

func newTrie() *Trie {
	return &Trie{map[string]*Trie{}, -1}
}

func (this *Trie) insert(fid int, f string) {
	node := this
	ps := strings.Split(f, "/")
	for _, p := range ps[1:] {
		if _, ok := node.children[p]; !ok {
			node.children[p] = newTrie()
		}
		node = node.children[p]
	}
	node.fid = fid
}

func (this *Trie) search() (ans []int) {
	var dfs func(*Trie)
	dfs = func(root *Trie) {
		if root.fid != -1 {
			ans = append(ans, root.fid)
			return
		}
		for _, child := range root.children {
			dfs(child)
		}
	}
	dfs(this)
	return
}

func removeSubfolders(folder []string) (ans []string) {
	trie := newTrie()
	for i, f := range folder {
		trie.insert(i, f)
	}
	for _, i := range trie.search() {
		ans = append(ans, folder[i])
	}
	return
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n \times m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸ºæ•°ç»„ `folder` çš„é•¿åº¦å’Œæ•°ç»„ `folder` ä¸­å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~