## [1807.æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„æ‹¬å·å†…å®¹ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/solutions/100000/by-lcbin-cnvd)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)

**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + æ¨¡æ‹Ÿ**

æˆ‘ä»¬å…ˆç”¨å“ˆå¸Œè¡¨ $d$ è®°å½• `knowledge` ä¸­çš„é”®å€¼å¯¹ã€‚

ç„¶åŽéåŽ†å­—ç¬¦ä¸² $s$ï¼Œå¦‚æžœå½“å‰å­—ç¬¦æ˜¯å·¦æ‹¬å· `'('`ï¼Œåˆ™ä»Žå½“å‰ä½ç½®å¼€å§‹å‘åŽéåŽ†ï¼Œç›´åˆ°é‡åˆ°å³æ‹¬å· `')'`ï¼Œæ­¤æ—¶æ‹¬å·å†…çš„å­—ç¬¦ä¸²å³ä¸ºé”®ï¼Œæˆ‘ä»¬åœ¨å“ˆå¸Œè¡¨ $d$ ä¸­æŸ¥æ‰¾è¯¥é”®å¯¹åº”çš„å€¼ï¼Œå¦‚æžœæ‰¾åˆ°äº†ï¼Œåˆ™å°†è¯¥å€¼æ›¿æ¢åˆ°æ‹¬å·å†…ï¼Œå¦åˆ™æ›¿æ¢ä¸º `'?'`ã€‚


```python [sol1-Python3]
class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        d = {a: b for a, b in knowledge}
        i, n = 0, len(s)
        ans = []
        while i < n:
            if s[i] == '(':
                j = s.find(')', i + 1)
                ans.append(d.get(s[i + 1: j], '?'))
                i = j
            else:
                ans.append(s[i])
            i += 1
        return ''.join(ans)
```


```java [sol1-Java]
class Solution {
    public String evaluate(String s, List<List<String>> knowledge) {
        Map<String, String> d = new HashMap<>(knowledge.size());
        for (var e : knowledge) {
            d.put(e.get(0), e.get(1));
        }
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < s.length(); ++i) {
            if (s.charAt(i) == '(') {
                int j = s.indexOf(')', i + 1);
                ans.append(d.getOrDefault(s.substring(i + 1, j), "?"));
                i = j;
            } else {
                ans.append(s.charAt(i));
            }
        }
        return ans.toString();
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    string evaluate(string s, vector<vector<string>>& knowledge) {
        unordered_map<string, string> d;
        for (auto& e : knowledge) {
            d[e[0]] = e[1];
        }
        string ans;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') {
                int j = s.find(")", i + 1);
                auto t = s.substr(i + 1, j - i - 1);
                ans += d.count(t) ? d[t] : "?";
                i = j;
            } else {
                ans += s[i];
            }
        }
        return ans;
    }
};
```


```go [sol1-Go]
func evaluate(s string, knowledge [][]string) string {
	d := map[string]string{}
	for _, v := range knowledge {
		d[v[0]] = v[1]
	}
	var ans strings.Builder
	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			j := i + 1
			for s[j] != ')' {
				j++
			}
			if v, ok := d[s[i+1:j]]; ok {
				ans.WriteString(v)
			} else {
				ans.WriteByte('?')
			}
			i = j
		} else {
			ans.WriteByte(s[i])
		}
	}
	return ans.String()
}
```


æ—¶é—´å¤æ‚åº¦ $O(n + m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(L)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸ºå­—ç¬¦ä¸² $s$ å’Œåˆ—è¡¨ `knowledge` çš„é•¿åº¦ï¼Œè€Œ $L$ ä¸º `knowledge` ä¸­æ‰€æœ‰å­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹å’Œã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~