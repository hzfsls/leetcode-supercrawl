### ğŸ“º è§†é¢‘é¢˜è§£  
![29.ä¸¤æ•°ç›¸é™¤-æ²ˆè€å¸ˆçš„å‰¯æœ¬.mp4](121a473d-cf86-44b3-9536-d5d17c003be8)

### ğŸ“– æ–‡å­—é¢˜è§£
#### å‰è¨€

ç”±äºé¢˜ç›®è§„å®šäº†ã€Œåªèƒ½å­˜å‚¨ $32$ ä½æ•´æ•°ã€ï¼Œæœ¬é¢˜è§£çš„æ­£æ–‡éƒ¨åˆ†å’Œä»£ç ä¸­éƒ½ä¸ä¼šä½¿ç”¨ä»»ä½• $64$ ä½æ•´æ•°ã€‚**è¯šç„¶ï¼Œä½¿ç”¨ $64$ ä½æ•´æ•°å¯ä»¥æå¤§åœ°æ–¹ä¾¿æˆ‘ä»¬çš„ç¼–ç ï¼Œä½†è¿™æ˜¯è¿åé¢˜ç›®è§„åˆ™çš„ã€‚**

å¦‚æœé™¤æ³•ç»“æœæº¢å‡ºï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦è¿”å› $2^{31} - 1$ ä½œä¸ºç­”æ¡ˆã€‚å› æ­¤åœ¨ç¼–ç ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥é¦–å…ˆå¯¹äºæº¢å‡ºæˆ–è€…å®¹æ˜“å‡ºé”™çš„è¾¹ç•Œæƒ…å†µè¿›è¡Œè®¨è®ºï¼š

- å½“è¢«é™¤æ•°ä¸º $32$ ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ $-2^{31}$ æ—¶ï¼š

    - å¦‚æœé™¤æ•°ä¸º $1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $-2^{31}$ï¼›
    - å¦‚æœé™¤æ•°ä¸º $-1$ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º $2^{31}$ï¼Œäº§ç”Ÿäº†æº¢å‡ºã€‚æ­¤æ—¶æˆ‘ä»¬éœ€è¦è¿”å› $2^{31} - 1$ã€‚

- å½“é™¤æ•°ä¸º $32$ ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€å°å€¼ $-2^{31}$ æ—¶ï¼š

    - å¦‚æœè¢«é™¤æ•°åŒæ ·ä¸º $-2^{31}$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $1$ï¼›
    - å¯¹äºå…¶ä½™çš„æƒ…å†µï¼Œæˆ‘ä»¬è¿”å›ç­”æ¡ˆ $0$ã€‚

- å½“è¢«é™¤æ•°ä¸º $0$ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›ç­”æ¡ˆ $0$ã€‚

å¯¹äºä¸€èˆ¬çš„æƒ…å†µï¼Œæ ¹æ®é™¤æ•°å’Œè¢«é™¤æ•°çš„ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ $4$ ç§ä¸åŒçš„å¯èƒ½æ€§ã€‚å› æ­¤ï¼Œä¸ºäº†æ–¹ä¾¿ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¢«é™¤æ•°æˆ–è€…é™¤æ•°å–ç›¸åæ•°ï¼Œä½¿å¾—å®ƒä»¬ç¬¦å·ç›¸åŒã€‚

å¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºæ­£æ•°ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šå¯¼è‡´æº¢å‡ºã€‚ä¾‹å¦‚å½“è¢«é™¤æ•°ä¸º $-2^{31}$ æ—¶ï¼Œå®ƒçš„ç›¸åæ•° $2^{31}$ äº§ç”Ÿäº†æº¢å‡ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†è¢«é™¤æ•°å’Œé™¤æ•°éƒ½å˜ä¸ºè´Ÿæ•°ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰æº¢å‡ºçš„é—®é¢˜ï¼Œåœ¨ç¼–ç æ—¶åªéœ€è¦è€ƒè™‘ $1$ ç§æƒ…å†µäº†ã€‚

å¦‚æœæˆ‘ä»¬å°†è¢«é™¤æ•°å’Œé™¤æ•°çš„å…¶ä¸­ï¼ˆæ°å¥½ï¼‰ä¸€ä¸ªå˜ä¸ºäº†æ­£æ•°ï¼Œé‚£ä¹ˆåœ¨è¿”å›ç­”æ¡ˆä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ç­”æ¡ˆä¹Ÿå–ç›¸åæ•°ã€‚

#### æ–¹æ³•ä¸€ï¼šäºŒåˆ†æŸ¥æ‰¾

**æ€è·¯ä¸ç®—æ³•**

æ ¹æ®ã€Œå‰è¨€ã€éƒ¨åˆ†çš„è®¨è®ºï¼Œæˆ‘ä»¬è®°è¢«é™¤æ•°ä¸º $X$ï¼Œé™¤æ•°ä¸º $Y$ï¼Œå¹¶ä¸” $X$ å’Œ $Y$ éƒ½æ˜¯è´Ÿæ•°ã€‚æˆ‘ä»¬éœ€è¦æ‰¾å‡º $X/Y$ çš„ç»“æœ $Z$ã€‚$Z$ ä¸€å®šæ˜¯æ­£æ•°æˆ– $0$ã€‚

æ ¹æ®é™¤æ³•ä»¥åŠä½™æ•°çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹æˆä¹˜æ³•çš„ç­‰ä»·å½¢å¼ï¼Œå³ï¼š

$$
Z \times Y \geq X > (Z+1) \times Y
$$

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•å¾—åˆ° $Z$ï¼Œå³æ‰¾å‡º**æœ€å¤§**çš„ $Z$ ä½¿å¾— $Z \times Y \geq X$ æˆç«‹ã€‚

ç”±äºæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ä¹˜æ³•è¿ç®—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•å¾—åˆ° $Z \times Y$ çš„å€¼ã€‚ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•ä¸ã€Œå¿«é€Ÿå¹‚ã€ç±»ä¼¼ï¼Œå‰è€…é€šè¿‡åŠ æ³•å®ç°ä¹˜æ³•ï¼Œåè€…é€šè¿‡ä¹˜æ³•å®ç°å¹‚è¿ç®—ã€‚ã€Œå¿«é€Ÿå¹‚ã€ç®—æ³•å¯ä»¥å‚è€ƒ[ã€Œ50. Pow(x, n)ã€çš„å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)ï¼Œã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•åªéœ€è¦åœ¨ã€Œå¿«é€Ÿå¹‚ã€ç®—æ³•çš„åŸºç¡€ä¸Šï¼Œå°†ä¹˜æ³•è¿ç®—æ”¹æˆåŠ æ³•è¿ç®—å³å¯ã€‚

**ç»†èŠ‚**

ç”±äºæˆ‘ä»¬åªèƒ½ä½¿ç”¨ $32$ ä½æ•´æ•°ï¼Œå› æ­¤äºŒåˆ†æŸ¥æ‰¾ä¸­ä¼šæœ‰å¾ˆå¤šç»†èŠ‚ã€‚

é¦–å…ˆï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„ä¸‹ç•Œä¸º $1$ï¼Œä¸Šç•Œä¸º $2^{31} - 1$ã€‚å”¯ä¸€å¯èƒ½å‡ºç°çš„ç­”æ¡ˆä¸º $2^{31}$ çš„æƒ…å†µå·²ç»è¢«æˆ‘ä»¬åœ¨ã€Œå‰è¨€ã€éƒ¨åˆ†è¿›è¡Œäº†ç‰¹æ®Šå¤„ç†ï¼Œå› æ­¤ç­”æ¡ˆçš„æœ€å¤§å€¼ä¸º $2^{31} - 1$ã€‚å¦‚æœäºŒåˆ†æŸ¥æ‰¾å¤±è´¥ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šä¸º $0$ã€‚

åœ¨å®ç°ã€Œå¿«é€Ÿä¹˜ã€æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨åŠ æ³•è¿ç®—ï¼Œç„¶è€Œè¾ƒå¤§çš„ $Z$ ä¹Ÿä¼šå¯¼è‡´åŠ æ³•è¿ç®—æº¢å‡ºã€‚ä¾‹å¦‚æˆ‘ä»¬è¦åˆ¤æ–­ $A + B$ æ˜¯å¦å°äº $C$ æ—¶ï¼ˆå…¶ä¸­ $A, B, C$ å‡ä¸ºè´Ÿæ•°ï¼‰ï¼Œ$A + B$ å¯èƒ½ä¼šäº§ç”Ÿæº¢å‡ºï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å°†åˆ¤æ–­æ”¹ä¸º $A < C - B$ æ˜¯å¦æˆç«‹ã€‚ç”±äºä»»æ„ä¸¤ä¸ªè´Ÿæ•°çš„å·®ä¸€å®šåœ¨ $[-2^{31} + 1, 2^{31} - 1]$ èŒƒå›´å†…ï¼Œè¿™æ ·å°±ä¸ä¼šäº§ç”Ÿæº¢å‡ºã€‚

è¯»è€…å¯ä»¥é˜…è¯»ä¸‹é¢çš„ä»£ç å’Œæ³¨é‡Šï¼Œç†è§£å¦‚ä½•é¿å…ä½¿ç”¨ä¹˜æ³•å’Œé™¤æ³•ï¼Œä»¥åŠæ­£ç¡®å¤„ç†æº¢å‡ºé—®é¢˜ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Solution {
public:
    int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == INT_MIN) {
            if (divisor == 1) {
                return INT_MIN;
            }
            if (divisor == -1) {
                return INT_MAX;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == INT_MIN) {
            return dividend == INT_MIN ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        // å¿«é€Ÿä¹˜
        auto quickAdd = [](int y, int z, int x) {
            // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
            // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
            int result = 0, add = y;
            while (z) {
                if (z & 1) {
                    // éœ€è¦ä¿è¯ result + add >= x
                    if (result < x - add) {
                        return false;
                    }
                    result += add;
                }
                if (z != 1) {
                    // éœ€è¦ä¿è¯ add + add >= x
                    if (add < x - add) {
                        return false;
                    }
                    add += add;
                }
                // ä¸èƒ½ä½¿ç”¨é™¤æ³•
                z >>= 1;
            }
            return true;
        };
        
        int left = 1, right = INT_MAX, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == INT_MAX) {
                    break;
                }
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == Integer.MIN_VALUE) {
            if (divisor == 1) {
                return Integer.MIN_VALUE;
            }
            if (divisor == -1) {
                return Integer.MAX_VALUE;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == Integer.MIN_VALUE) {
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        boolean rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
        
        int left = 1, right = Integer.MAX_VALUE, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            boolean check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == Integer.MAX_VALUE) {
                    break;
                }
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }

    // å¿«é€Ÿä¹˜
    public boolean quickAdd(int y, int z, int x) {
        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
        int result = 0, add = y;
        while (z != 0) {
            if ((z & 1) != 0) {
                // éœ€è¦ä¿è¯ result + add >= x
                if (result < x - add) {
                    return false;
                }
                result += add;
            }
            if (z != 1) {
                // éœ€è¦ä¿è¯ add + add >= x
                if (add < x - add) {
                    return false;
                }
                add += add;
            }
            // ä¸èƒ½ä½¿ç”¨é™¤æ³•
            z >>= 1;
        }
        return true;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int Divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == int.MinValue) {
            if (divisor == 1) {
                return int.MinValue;
            }
            if (divisor == -1) {
                return int.MaxValue;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == int.MinValue) {
            return dividend == int.MinValue ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
        
        int left = 1, right = int.MaxValue, ans = 0;
        while (left <= right) {
            // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                // æ³¨æ„æº¢å‡º
                if (mid == int.MaxValue) {
                    break;
                }
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }

    // å¿«é€Ÿä¹˜
    public bool quickAdd(int y, int z, int x) {
        // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
        // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
        int result = 0, add = y;
        while (z != 0) {
            if ((z & 1) != 0) {
                // éœ€è¦ä¿è¯ result + add >= x
                if (result < x - add) {
                    return false;
                }
                result += add;
            }
            if (z != 1) {
                // éœ€è¦ä¿è¯ add + add >= x
                if (add < x - add) {
                    return false;
                }
                add += add;
            }
            // ä¸èƒ½ä½¿ç”¨é™¤æ³•
            z >>= 1;
        }
        return true;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1

        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == INT_MIN:
            if divisor == 1:
                return INT_MIN
            if divisor == -1:
                return INT_MAX
        
        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == INT_MIN:
            return 1 if dividend == INT_MIN else 0
        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if dividend == 0:
            return 0
        
        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        rev = False
        if dividend > 0:
            dividend = -dividend
            rev = not rev
        if divisor > 0:
            divisor = -divisor
            rev = not rev

        # å¿«é€Ÿä¹˜
        def quickAdd(y: int, z: int, x: int) -> bool:
            # x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
            # éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
            result, add = 0, y
            while z > 0:
                if (z & 1) == 1:
                    # éœ€è¦ä¿è¯ result + add >= x
                    if result < x - add:
                        return False
                    result += add
                if z != 1:
                    # éœ€è¦ä¿è¯ add + add >= x
                    if add < x - add:
                        return False
                    add += add
                # ä¸èƒ½ä½¿ç”¨é™¤æ³•
                z >>= 1
            return True
        
        left, right, ans = 1, INT_MAX, 0
        while left <= right:
            # æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
            mid = left + ((right - left) >> 1)
            check = quickAdd(divisor, mid, dividend)
            if check:
                ans = mid
                # æ³¨æ„æº¢å‡º
                if mid == INT_MAX:
                    break
                left = mid + 1
            else:
                right = mid - 1

        return -ans if rev else ans
```

```go [sol1-Golang]
// å¿«é€Ÿä¹˜
// x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
// åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
func quickAdd(y, z, x int) bool {
    for result, add := 0, y; z > 0; z >>= 1 { // ä¸èƒ½ä½¿ç”¨é™¤æ³•
        if z&1 > 0 {
            // éœ€è¦ä¿è¯ result + add >= x
            if result < x-add {
                return false
            }
            result += add
        }
        if z != 1 {
            // éœ€è¦ä¿è¯ add + add >= x
            if add < x-add {
                return false
            }
            add += add
        }
    }
    return true
}

func divide(dividend, divisor int) int {
    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == 1 {
            return math.MinInt32
        }
        if divisor == -1 {
            return math.MaxInt32
        }
    }
    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == math.MinInt32 {
            return 1
        }
        return 0
    }
    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        return 0
    }

    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    rev := false
    if dividend > 0 {
        dividend = -dividend
        rev = !rev
    }
    if divisor > 0 {
        divisor = -divisor
        rev = !rev
    }

    ans := 0
    left, right := 1, math.MaxInt32
    for left <= right {
        mid := left + (right-left)>>1 // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
        if quickAdd(divisor, mid, dividend) {
            ans = mid
            if mid == math.MaxInt32 { // æ³¨æ„æº¢å‡º
                break
            }
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    if rev {
        return -ans
    }
    return ans
}
```

```JavaScript [sol1-JavaScript]
var divide = function(dividend, divisor) {
    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);
    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (dividend === MIN_VALUE) {
        if (divisor === 1) {
            return MIN_VALUE;
        }
        if (divisor === -1) {
            return MAX_VALUE;
        }
    }
    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (divisor === MIN_VALUE) {
        return dividend === MIN_VALUE ? 1 : 0;
    }
    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
    if (dividend === 0) {
        return 0;
    }
    
    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    let rev = false;
    if (dividend > 0) {
        dividend = -dividend;
        rev = !rev;
    }
    if (divisor > 0) {
        divisor = -divisor;
        rev = !rev;
    }
    
    let left = 1, right = MAX_VALUE, ans = 0;
    while (left <= right) {
        // æ³¨æ„æº¢å‡ºï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨é™¤æ³•
        const mid = left + ((right - left) >> 1);
        const check = quickAdd(divisor, mid, dividend);
        if (check) {
            ans = mid;
            // æ³¨æ„æº¢å‡º
            if (mid === MAX_VALUE) {
                break;
            }
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return rev ? -ans : ans;
}

// å¿«é€Ÿä¹˜
const quickAdd = (y, z, x) => {
    // x å’Œ y æ˜¯è´Ÿæ•°ï¼Œz æ˜¯æ­£æ•°
    // éœ€è¦åˆ¤æ–­ z * y >= x æ˜¯å¦æˆç«‹
    let result = 0, add = y;
    while (z !== 0) {
        if ((z & 1) !== 0) {
            // éœ€è¦ä¿è¯ result + add >= x
            if (result < x - add) {
                return false;
            }
            result += add;
        }
        if (z !== 1) {
            // éœ€è¦ä¿è¯ add + add >= x
            if (add < x - add) {
                return false;
            }
            add += add;
        }
        // ä¸èƒ½ä½¿ç”¨é™¤æ³•
        z >>= 1;
    }
    return true;
};
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(\log^2 C)$ï¼Œå…¶ä¸­ $C$ è¡¨ç¤º $32$ ä½æ•´æ•°çš„èŒƒå›´ã€‚äºŒåˆ†æŸ¥æ‰¾çš„æ¬¡æ•°ä¸º $O(\log C)$ï¼Œå…¶ä¸­çš„æ¯ä¸€æ­¥æˆ‘ä»¬éƒ½éœ€è¦ $O(\log C)$ ä½¿ç”¨ã€Œå¿«é€Ÿä¹˜ã€ç®—æ³•åˆ¤æ–­ $Z \times Y \geq X$ æ˜¯å¦æˆç«‹ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(\log^2 C)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

#### æ–¹æ³•äºŒï¼šç±»äºŒåˆ†æŸ¥æ‰¾

**å‰è¨€**

å¸¸è§„æ„ä¹‰ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾ä¸ºï¼šç»™å®šåŒºé—´ $[l, r]$ï¼Œå–è¯¥åŒºé—´çš„ä¸­ç‚¹ $\textit{mid} = \lfloor \dfrac{l+r}{2} \rfloor$ï¼Œæ ¹æ® $\textit{mid}$ å¤„æ˜¯å¦æ»¡è¶³æŸä¸€æ¡ä»¶ï¼Œæ¥å†³å®šç§»åŠ¨å·¦è¾¹ç•Œ $l$ è¿˜æ˜¯å³è¾¹ç•Œ $r$ã€‚

æˆ‘ä»¬ä¹Ÿå¯ä»¥è€ƒè™‘å¦ä¸€ç§äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼š

- è®° $k$ ä¸ºæ»¡è¶³ $2^k \leq r-l < 2^{k+1}$ çš„ $k$ å€¼ã€‚

- äºŒåˆ†æŸ¥æ‰¾ä¼šè¿›è¡Œ $k+1$ æ¬¡ã€‚åœ¨ç¬¬ $i ~ (1 \leq i \leq k+1)$ æ¬¡äºŒåˆ†æŸ¥æ‰¾æ—¶ï¼Œè®¾åŒºé—´ä¸º $[l_i, r_i]$ï¼Œæˆ‘ä»¬å– $\textit{mid} = l_i + 2^{k+1-i}$ï¼š

- å¦‚æœ $\textit{mid}$ ä¸åœ¨ $[l_i, r_i]$ çš„èŒƒå›´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥å¿½ç•¥è¿™æ¬¡äºŒåˆ†æŸ¥æ‰¾ï¼›

- å¦‚æœ $\textit{mid}$ åœ¨ $[l_i, r_i]$ çš„èŒƒå›´å†…ï¼Œå¹¶ä¸” $\textit{mid}$ å¤„æ»¡è¶³æŸä¸€æ¡ä»¶ï¼Œæˆ‘ä»¬å°±å°† $l_i$ æ›´æ–°ä¸º $\textit{mid}$ï¼Œå¦åˆ™åŒæ ·å¿½ç•¥è¿™æ¬¡äºŒåˆ†æŸ¥æ‰¾ã€‚

æœ€ç»ˆ $l_i$ å³ä¸ºäºŒåˆ†æŸ¥æ‰¾çš„ç»“æœã€‚è¿™æ ·åšçš„æ­£ç¡®æ€§åœ¨äºï¼š

> è®¾åœ¨å¸¸è§„æ„ä¹‰ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾çš„ç­”æ¡ˆä¸º $\textit{ans}$ï¼Œè®° $\delta$ ä¸º $\textit{ans}$ ä¸å·¦è¾¹ç•Œçš„å·®å€¼ $\textit{ans} - l$ã€‚$\delta$ ä¸ä¼šå¤§äº $r-l$ï¼Œå¹¶ä¸” $\delta$ ä¸€å®šå¯ä»¥ç”¨ $2^k, 2^{k-1}, 2^{k-2}, \cdots, 2^1, 2^0$ ä¸­çš„è‹¥å¹²ä¸ªå…ƒç´ ä¹‹å’Œè¡¨ç¤ºï¼ˆè€ƒè™‘ $\delta$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ„ä¹‰å³å¯ï¼‰ã€‚å› æ­¤ä¸Šè¿°äºŒåˆ†æŸ¥æ‰¾æ˜¯æ­£ç¡®çš„ã€‚

**æ€è·¯ä¸ç®—æ³•**

åŸºäºä¸Šè¿°çš„äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡å‡ºå¦‚ä¸‹çš„ç®—æ³•ï¼š

- æˆ‘ä»¬é¦–å…ˆä¸æ–­åœ°å°† $Y$ ä¹˜ä»¥ $2$ï¼ˆé€šè¿‡åŠ æ³•è¿ç®—å®ç°ï¼‰ï¼Œå¹¶å°†è¿™äº›ç»“æœæ”¾å…¥æ•°ç»„ä¸­ï¼Œå…¶ä¸­æ•°ç»„çš„ç¬¬ $i$ é¡¹å°±ç­‰äº $Y \times 2^i$ã€‚è¿™ä¸€è¿‡ç¨‹ç›´åˆ° $Y$ çš„ä¸¤å€ä¸¥æ ¼å°äº $X$ ä¸ºæ­¢ã€‚

- æˆ‘ä»¬å¯¹æ•°ç»„è¿›è¡Œé€†åºéå†ã€‚å½“éå†åˆ°ç¬¬ $i$ é¡¹æ—¶ï¼Œå¦‚æœå…¶å¤§äºç­‰äº $X$ï¼Œæˆ‘ä»¬å°±å°†ç­”æ¡ˆå¢åŠ  $2^i$ï¼Œå¹¶ä¸”å°† $X$ ä¸­å‡å»è¿™ä¸€é¡¹çš„å€¼ã€‚

æœ¬è´¨ä¸Šï¼Œä¸Šè¿°çš„é€†åºéå†å°±æ¨¡æ‹Ÿäº†äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ã€‚

**ä»£ç **

```C++ [sol2-C++]
class Solution {
public:
    int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == INT_MIN) {
            if (divisor == 1) {
                return INT_MIN;
            }
            if (divisor == -1) {
                return INT_MAX;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == INT_MIN) {
            return dividend == INT_MIN ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        vector<int> candidates = {divisor};
        // æ³¨æ„æº¢å‡º
        while (candidates.back() >= dividend - candidates.back()) {
            candidates.push_back(candidates.back() + candidates.back());
        }
        int ans = 0;
        for (int i = candidates.size() - 1; i >= 0; --i) {
            if (candidates[i] >= dividend) {
                ans += (1 << i);
                dividend -= candidates[i];
            }
        }

        return rev ? -ans : ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == Integer.MIN_VALUE) {
            if (divisor == 1) {
                return Integer.MIN_VALUE;
            }
            if (divisor == -1) {
                return Integer.MAX_VALUE;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == Integer.MIN_VALUE) {
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        boolean rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        List<Integer> candidates = new ArrayList<Integer>();
        candidates.add(divisor);
        int index = 0;
        // æ³¨æ„æº¢å‡º
        while (candidates.get(index) >= dividend - candidates.get(index)) {
            candidates.add(candidates.get(index) + candidates.get(index));
            ++index;
        }
        int ans = 0;
        for (int i = candidates.size() - 1; i >= 0; --i) {
            if (candidates.get(i) >= dividend) {
                ans += 1 << i;
                dividend -= candidates.get(i);
            }
        }

        return rev ? -ans : ans;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int Divide(int dividend, int divisor) {
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == int.MinValue) {
            if (divisor == 1) {
                return int.MinValue;
            }
            if (divisor == -1) {
                return int.MaxValue;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == int.MinValue) {
            return dividend == int.MinValue ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }

        IList<int> candidates = new List<int>();
        candidates.Add(divisor);
        int index = 0;
        // æ³¨æ„æº¢å‡º
        while (candidates[index] >= dividend - candidates[index]) {
            candidates.Add(candidates[index] + candidates[index]);
            ++index;
        }
        int ans = 0;
        for (int i = candidates.Count - 1; i >= 0; --i) {
            if (candidates[i] >= dividend) {
                ans += 1 << i;
                dividend -= candidates[i];
            }
        }

        return rev ? -ans : ans;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1

        # è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == INT_MIN:
            if divisor == 1:
                return INT_MIN
            if divisor == -1:
                return INT_MAX
        
        # è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == INT_MIN:
            return 1 if dividend == INT_MIN else 0
        # è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if dividend == 0:
            return 0
        
        # ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
        # å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
        rev = False
        if dividend > 0:
            dividend = -dividend
            rev = not rev
        if divisor > 0:
            divisor = -divisor
            rev = not rev
        
        candidates = [divisor]
        # æ³¨æ„æº¢å‡º
        while candidates[-1] >= dividend - candidates[-1]:
            candidates.append(candidates[-1] + candidates[-1])
        
        ans = 0
        for i in range(len(candidates) - 1, -1, -1):
            if candidates[i] >= dividend:
                ans += (1 << i)
                dividend -= candidates[i]

        return -ans if rev else ans
```

```go [sol2-Golang]
func divide(dividend, divisor int) int {
    if dividend == math.MinInt32 { // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if divisor == 1 {
            return math.MinInt32
        }
        if divisor == -1 {
            return math.MaxInt32
        }
    }
    if divisor == math.MinInt32 { // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if dividend == math.MinInt32 {
            return 1
        }
        return 0
    }
    if dividend == 0 { // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        return 0
    }

    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    rev := false
    if dividend > 0 {
        dividend = -dividend
        rev = !rev
    }
    if divisor > 0 {
        divisor = -divisor
        rev = !rev
    }

    candidates := []int{divisor}
    for y := divisor; y >= dividend-y; { // æ³¨æ„æº¢å‡º
        y += y
        candidates = append(candidates, y)
    }

    ans := 0
    for i := len(candidates) - 1; i >= 0; i-- {
        if candidates[i] >= dividend {
            ans |= 1 << i
            dividend -= candidates[i]
        }
    }
    if rev {
        return -ans
    }
    return ans
}
```

```JavaScript [sol2-JavaScript]
var divide = function(dividend, divisor) {
    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);
    // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (dividend === MIN_VALUE) {
        if (divisor === 1) {
            return MIN_VALUE;
        }
        if (divisor === -1) {
            return MAX_VALUE;
        }
    }
    // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
    if (divisor === MIN_VALUE) {
        return dividend === MIN_VALUE ? 1 : 0;
    }
    // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
    if (dividend === 0) {
        return 0;
    }
    
    // ä¸€èˆ¬æƒ…å†µï¼Œä½¿ç”¨ç±»äºŒåˆ†æŸ¥æ‰¾
    // å°†æ‰€æœ‰çš„æ­£æ•°å–ç›¸åæ•°ï¼Œè¿™æ ·å°±åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µ
    let rev = false;
    if (dividend > 0) {
        dividend = -dividend;
        rev = !rev;
    }
    if (divisor > 0) {
        divisor = -divisor;
        rev = !rev;
    }

    const candidates = [divisor];
    let index = 0;
    // æ³¨æ„æº¢å‡º
    while (candidates[index] >= dividend - candidates[index]) {
        candidates.push(candidates[index] + candidates[index]);
        ++index;
    }
    let ans = 0;
    for (let i = candidates.length - 1; i >= 0; --i) {
        if (candidates[i] >= dividend) {
            ans += 1 << i;
            dividend -= candidates[i];
        }
    }

    return rev ? -ans : ans;
};
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(\log C)$ï¼Œå³ä¸ºäºŒåˆ†æŸ¥æ‰¾éœ€è¦çš„æ—¶é—´ã€‚æ–¹æ³•äºŒæ—¶é—´å¤æ‚åº¦ä¼˜äºæ–¹æ³•ä¸€çš„åŸå› æ˜¯ï¼šæ–¹æ³•ä¸€çš„æ¯ä¸€æ­¥äºŒåˆ†æŸ¥æ‰¾éƒ½éœ€è¦é‡æ–°è®¡ç®— $Z \times Y$ çš„å€¼ï¼Œéœ€è¦ $O(\log C)$ çš„æ—¶é—´å¤æ‚åº¦ï¼›è€Œæ–¹æ³•äºŒçš„æ¯ä¸€æ­¥çš„æƒé‡éƒ½æ˜¯ $2$ çš„å¹‚ï¼Œåœ¨äºŒåˆ†æŸ¥æ‰¾å¼€å§‹å‰å°±éƒ½æ˜¯å·²çŸ¥çš„å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ $O(\log C)$ çš„æ—¶é—´å†…ï¼Œä¸€æ¬¡æ€§å°†å®ƒä»¬å…¨éƒ¨é¢„å¤„ç†å‡ºæ¥ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(\log C)$ï¼Œå³ä¸ºéœ€è¦å­˜å‚¨çš„ $Y \times 2^i$ çš„æ•°é‡ã€‚