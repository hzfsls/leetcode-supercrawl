#### 方法一：动态规划

**思路与算法**

我们用 $f[i][j]$ 表示使用 $\textit{nums}[0..i]$ 中的元素可以组成的类型为 $j$ 的子序列的数目。其中 $j$ 的取值范围为 $\{0, 1, 2\}$，它们表示：

- 当 $j=0$ 时，表示由**正整数**个 $0$ 组成的子序列；

- 当 $j=1$ 时，表示由**正整数**个 $0$ 紧接着正整数个 $1$ 组成的子序列；

- 当 $j=2$ 时，表示**正整数**个 $0$ 紧接着正整数个 $1$，最后**正整数**个 $2$ 组成的子序列，也就是题目描述中的「特殊序列」。

在进行状态转移时，我们可以考虑 $\textit{nums}[i]$ 的值：

- 当 $\textit{nums}[i] = 0$ 时，我们可以在每一个使用 $\textit{nums}[0..i-1]$ 中的元素组成的类型为 $0$ 的子序列之后添加这个 $0$，得到额外的 $f[i-1][0]$ 个类型为 $0$ 的子序列。此外，这个 $0$ 也可以单独构成一个新的类型为 $0$ 的子序列。因此 $f[i][0]$ 比 $f[i-1][0]$ 多出了 $f[i-1][0] + 1$，即有状态转移方程：

    $$
    f[i][0] = 2 \cdot f[i-1][0] + 1
    $$

    而对于 $f[i][1]$ 和 $f[i][2]$，并没有新的子序列生成，因此它们各自保持 $f[i-1][1]$ 与 $f[i-1][2]$ 的值不变。

- 当 $\textit{nums}[i] = 1$ 时，我们可以在每一个使用 $\textit{nums}[0..i-1]$ 中的元素组成的类型为 $1$ 的子序列之后添加这个 $1$，得到额外的 $f[i-1][1]$ 个类型为 $1$ 的子序列；也可以在每一个类型为 $0$ 的子序列之后添加这个 $1$，得到额外的 $f[i-1][0]$ 个类型为 $1$ 的子序列。因此 $f[i][1]$ 比 $f[i-1][1]$ 多出了 $f[i-1][0] + f[i-1][1]$，即有状态转移方程：

    $$
    f[i][1] = 2 \cdot f[i-1][1] + f[i-1][0]
    $$

    而对于 $f[i][0]$ 和 $f[i][2]$，并没有新的子序列生成，因此它们各自保持 $f[i-1][0]$ 与 $f[i-1][2]$ 的值不变。

- 当 $\textit{nums}[i] = 2$ 时，我们可以在每一个使用 $\textit{nums}[0..i-1]$ 中的元素组成的类型为 $2$ 的子序列之后添加这个 $2$，得到额外的 $f[i-1][2]$ 个类型为 $1$ 的子序列；也可以在每一个类型为 $1$ 的子序列之后添加这个 $2$，得到额外的 $f[i-1][1]$ 个类型为 $2$ 的子序列。因此 $f[i][2]$ 比 $f[i-1][2]$ 多出了 $f[i-1][1] + f[i-1][2]$，即有状态转移方程：

    $$
    f[i][2] = 2 \cdot f[i-1][2] + f[i-1][1]
    $$

    而对于 $f[i][0]$ 和 $f[i][1]$，并没有新的子序列生成，因此它们各自保持 $f[i-1][0]$ 与 $f[i-1][1]$ 的值不变。

最终的答案即为 $f[n-1][2]$，其中 $n$ 是数组 $\textit{nums}$ 的长度。

**细节**

当 $i=0$ 时，$f[i-1][..]$ 不是合法的状态，因此我们可以规定 $f[i-1][..] = 0$，使其可以正确地进行转移。

此外，在状态转移方程中，$f[i][j]$ 只会从 $f[i-1][..]$ 转移而来，因此我们可以使用两个长度为 $3$ 的一维数组代替 $f$ 的二维数组，交替地进行状态转移。而本题的状态转移更加特殊，对于每一个 $i$，只会有一个 $f[i][j]$ 与 $f[i-1][j]$ 的值不同，另外两个的值不会发生变化，因此我们只需要使用一个长度为 $3$ 的一维数组，甚至直接使用 $3$ 个变量进行状态转移即可。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    static constexpr int mod = 1000000007;

public:
    int countSpecialSubsequences(vector<int>& nums) {
        int f0 = 0, f1 = 0, f2 = 0;
        for (int num: nums) {
            if (num == 0) {
                f0 = (f0 * 2 + 1) % mod;
            }
            else if (num == 1) {
                f1 = (f1 * 2 % mod + f0) % mod;
            }
            else {
                f2 = (f2 * 2 % mod + f1) % mod;
            }
        }
        return f2;
    }
};
```

```Python [sol1-Python3]
class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        mod = 10**9 + 7
        f0 = f1 = f2 = 0
        for num in nums:
            if num == 0:
                f0 = (f0 * 2 + 1) % mod
            elif num == 1:
                f1 = (f1 * 2 + f0) % mod
            else:
                f2 = (f2 * 2 + f1) % mod
        return f2
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。

- 空间复杂度：$O(1)$。