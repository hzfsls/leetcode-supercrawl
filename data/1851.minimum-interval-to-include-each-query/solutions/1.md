## [1851.åŒ…å«æ¯ä¸ªæŸ¥è¯¢çš„æœ€å°åŒºé—´ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/minimum-interval-to-include-each-query/solutions/100000/python3javacgo-yi-ti-yi-jie-pai-xu-chi-x-5mgt)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)



**æ–¹æ³•ä¸€ï¼šæŽ’åº + ç¦»çº¿æŸ¥è¯¢ + ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰**

æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œé¢˜ç›®ä¸­æŸ¥è¯¢çš„é¡ºåºå¹¶ä¸ä¼šå½±å“ç­”æ¡ˆï¼Œå¹¶ä¸”æ¶‰åŠåˆ°çš„åŒºé—´ä¹Ÿä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è€ƒè™‘å°†æ‰€æœ‰çš„æŸ¥è¯¢æŒ‰ç…§ä»Žå°åˆ°å¤§çš„é¡ºåºè¿›è¡ŒæŽ’åºï¼ŒåŒæ—¶å°†æ‰€æœ‰çš„åŒºé—´æŒ‰ç…§å·¦ç«¯ç‚¹ä»Žå°åˆ°å¤§çš„é¡ºåºè¿›è¡ŒæŽ’åºã€‚

æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰ $pq$ æ¥ç»´æŠ¤å½“å‰æ‰€æœ‰çš„åŒºé—´ï¼Œé˜Ÿåˆ—çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $(v, r)$ï¼Œè¡¨ç¤ºä¸€ä¸ªåŒºé—´é•¿åº¦ä¸º $v$ï¼Œå³ç«¯ç‚¹ä¸º $r$ çš„åŒºé—´ã€‚åˆå§‹æ—¶ï¼Œä¼˜å…ˆé˜Ÿåˆ—ä¸ºç©ºã€‚å¦å¤–ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆ $i$ï¼ŒæŒ‡å‘å½“å‰éåŽ†åˆ°çš„åŒºé—´ï¼Œåˆå§‹æ—¶ $i=0$ã€‚

æˆ‘ä»¬æŒ‰ç…§ä»Žå°åˆ°å¤§çš„é¡ºåºä¾æ¬¡éåŽ†æ¯ä¸ªæŸ¥è¯¢ $(x, j)$ï¼Œå¹¶è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š

-   å¦‚æžœæŒ‡é’ˆ $i$ å°šæœªéåŽ†å®Œæ‰€æœ‰çš„åŒºé—´ï¼Œå¹¶ä¸”å½“å‰éåŽ†åˆ°çš„åŒºé—´ $[a, b]$ çš„å·¦ç«¯ç‚¹å°äºŽç­‰äºŽ $x$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†è¯¥åŒºé—´åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼Œå¹¶å°†æŒ‡é’ˆ $i$ åŽç§»ä¸€ä½ï¼Œå¾ªçŽ¯æ­¤è¿‡ç¨‹ï¼›
-   å¦‚æžœä¼˜å…ˆé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å †é¡¶å…ƒç´ çš„åŒºé—´å³ç«¯ç‚¹å°äºŽ $x$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å †é¡¶å…ƒç´ å¼¹å‡ºï¼Œå¾ªçŽ¯æ­¤è¿‡ç¨‹ï¼›
-   æ­¤æ—¶ï¼Œå¦‚æžœä¼˜å…ˆé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå †é¡¶å…ƒç´ å°±æ˜¯åŒ…å« $x$ çš„æœ€å°åŒºé—´ã€‚æˆ‘ä»¬å°†å…¶é•¿åº¦ $v$ åŠ å…¥ç­”æ¡ˆæ•°ç»„ $ans$ ä¸­ã€‚

åœ¨ä¸Šè¿°è¿‡ç¨‹ç»“æŸåŽï¼Œæˆ‘ä»¬è¿”å›žç­”æ¡ˆæ•°ç»„ $ans$ å³å¯ã€‚




```python [sol1-Python3]
class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        n, m = len(intervals), len(queries)
        intervals.sort()
        queries = sorted((x, i) for i, x in enumerate(queries))
        ans = [-1] * m
        pq = []
        i = 0
        for x, j in queries:
            while i < n and intervals[i][0] <= x:
                a, b = intervals[i]
                heappush(pq, (b - a + 1, b))
                i += 1
            while pq and pq[0][1] < x:
                heappop(pq)
            if pq:
                ans[j] = pq[0][0]
        return ans
```


```java [sol1-Java]
class Solution {
    public int[] minInterval(int[][] intervals, int[] queries) {
        int n = intervals.length, m = queries.length;
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        int[][] qs = new int[m][0];
        for (int i = 0; i < m; ++i) {
            qs[i] = new int[] {queries[i], i};
        }
        Arrays.sort(qs, (a, b) -> a[0] - b[0]);
        int[] ans = new int[m];
        Arrays.fill(ans, -1);
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        int i = 0;
        for (int[] q : qs) {
            while (i < n && intervals[i][0] <= q[0]) {
                int a = intervals[i][0], b = intervals[i][1];
                pq.offer(new int[] {b - a + 1, b});
                ++i;
            }
            while (!pq.isEmpty() && pq.peek()[1] < q[0]) {
                pq.poll();
            }
            if (!pq.isEmpty()) {
                ans[q[1]] = pq.peek()[0];
            }
        }
        return ans;
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        int n = intervals.size(), m = queries.size();
        sort(intervals.begin(), intervals.end());
        using pii = pair<int, int>;
        vector<pii> qs;
        for (int i = 0; i < m; ++i) {
            qs.emplace_back(queries[i], i);
        }
        sort(qs.begin(), qs.end());
        vector<int> ans(m, -1);
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        int i = 0;
        for (auto& [x, j] : qs) {
            while (i < n && intervals[i][0] <= x) {
                int a = intervals[i][0], b = intervals[i][1];
                pq.emplace(b - a + 1, b);
                ++i;
            }
            while (!pq.empty() && pq.top().second < x) {
                pq.pop();
            }
            if (!pq.empty()) {
                ans[j] = pq.top().first;
            }
        }
        return ans;
    }
};
```



```go [sol1-Go]
func minInterval(intervals [][]int, queries []int) []int {
	n, m := len(intervals), len(queries)
	sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })
	qs := make([][2]int, m)
	ans := make([]int, m)
	for i := range qs {
		qs[i] = [2]int{queries[i], i}
		ans[i] = -1
	}
	sort.Slice(qs, func(i, j int) bool { return qs[i][0] < qs[j][0] })
	pq := hp{}
	i := 0
	for _, q := range qs {
		x, j := q[0], q[1]
		for i < n && intervals[i][0] <= x {
			a, b := intervals[i][0], intervals[i][1]
			heap.Push(&pq, pair{b - a + 1, b})
			i++
		}
		for len(pq) > 0 && pq[0].r < x {
			heap.Pop(&pq)
		}
		if len(pq) > 0 {
			ans[j] = pq[0].v
		}
	}
	return ans
}

type pair struct{ v, r int }
type hp []pair

func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { return h[i].v < h[j].v }
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.(pair)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n + m \times \log m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n + m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«æ˜¯æ•°ç»„ $intervals$ å’Œ $queries$ çš„é•¿åº¦ã€‚


---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~