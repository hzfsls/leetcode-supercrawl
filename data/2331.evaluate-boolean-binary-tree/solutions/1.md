## [2331.è®¡ç®—å¸ƒå°”äºŒå‰æ ‘çš„å€¼ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/evaluate-boolean-binary-tree/solutions/100000/python3javacgo-yi-ti-yi-jie-di-gui-by-lc-g9b0)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)



**æ–¹æ³•ä¸€ï¼šé€’å½’**

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹å¼æ¥æ±‚è§£æœ¬é¢˜ã€‚

å¯¹äºå½“å‰èŠ‚ç‚¹ `root`ï¼š

-   å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶åˆ¤æ–­å…¶å€¼æ˜¯å¦ä¸º $1$ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚
-   å¦åˆ™ï¼Œå¯¹å…¶å·¦å³å­©å­åˆ†åˆ«é€’å½’æ±‚è§£ï¼Œå¾—åˆ°å…¶å·¦å³å­©å­çš„å€¼ $l$ å’Œ $r$ã€‚ç„¶åæ ¹æ®å½“å‰èŠ‚ç‚¹å€¼çš„ä¸åŒï¼Œåˆ†åˆ«è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š
    -   å¦‚æœå½“å‰èŠ‚ç‚¹å€¼ä¸º $2$ï¼Œåˆ™è¿”å› `l or r`ã€‚
    -   å¦‚æœå½“å‰èŠ‚ç‚¹å€¼ä¸º $3$ï¼Œåˆ™è¿”å› `l && r`ã€‚


```python [sol1-Python3]
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left is None:
            return bool(root.val)
        l = self.evaluateTree(root.left)
        r = self.evaluateTree(root.right)
        return l or r if root.val == 2 else l and r
```



```java [sol1-Java]
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean evaluateTree(TreeNode root) {
        if (root.left == null) {
            return root.val == 1;
        }
        boolean l = evaluateTree(root.left);
        boolean r = evaluateTree(root.right);
        return root.val == 2 ? l || r : l && r;
    }
}
```



```cpp [sol1-C++]
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        if (!root->left) {
            return root->val;
        }
        bool l = evaluateTree(root->left);
        bool r = evaluateTree(root->right);
        return root->val == 2 ? l or r : l and r;
    }
};
```



```go [sol1-Go]
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func evaluateTree(root *TreeNode) bool {
	if root.Left == nil {
		return root.Val == 1
	}
	l, r := evaluateTree(root.Left), evaluateTree(root.Right)
	if root.Val == 2 {
		return l || r
	}
	return l && r
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºäºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•°ã€‚



---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~