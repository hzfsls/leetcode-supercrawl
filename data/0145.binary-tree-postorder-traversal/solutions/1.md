## [145.äºŒå‰æ ‘çš„ååºéå† ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/100000/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t)

ä½œè€…ï¼š[carlsun-2](https://leetcode.cn/u/carlsun-2)

**ä¸å°‘åŒå­¦å¯¹äºŒå‰æ ‘çš„é€’å½’ä¸éé€’å½’éå†ï¼Œå‰ä¸­ååºéƒ½è¿˜å¤„äºæœ¦èƒ§çŠ¶æ€ï¼Œæˆ‘ç‰¹æ„å½•äº†ä¸€æœŸè§†é¢‘ï¼Œè®²ä¸€è®²[äºŒå‰æ ‘çš„éå†](https://www.bilibili.com/video/BV1Wh411S7xt)**ï¼Œè¿˜è¯¦ç»†ä»‹ç»äº†æˆ‘ä»¬åšäºŒå‰æ ‘çš„æ—¶å€™å¸¸é‡åˆ°çš„é—®é¢˜ï¼Œç›¸ä¿¡ç»“åˆæœ¬ç¯‡é¢˜è§£ï¼Œä¼šå¯¹ä½ å­¦ä¹ äºŒå‰æ ‘æœ‰æ‰€å¸®åŠ©ã€‚


è¿™ç¯‡æ–‡ç« ï¼Œ**å½»åº•è®²æ¸…æ¥šåº”è¯¥å¦‚ä½•å†™é€’å½’ï¼Œå¹¶ç»™å‡ºäº†å‰ä¸­ååºä¸‰ç§ä¸åŒçš„è¿­ä»£æ³•ï¼Œç„¶ååˆ†æè¿­ä»£æ³•çš„ä»£ç é£æ ¼ä¸ºä»€ä¹ˆæ²¡æœ‰ç»Ÿä¸€ï¼Œæœ€åç»™å‡ºç»Ÿä¸€çš„å‰ä¸­ååºè¿­ä»£æ³•çš„ä»£ç ï¼Œå¸®å¤§å®¶å½»åº•åƒé€äºŒå‰æ ‘çš„æ·±åº¦ä¼˜å…ˆéå†ã€‚**


ä»¥ä¸‹å¼€å§‹å¼€å§‹æ­£æ–‡ï¼š

* äºŒå‰æ ‘æ·±åº¦ä¼˜å…ˆéå†
    * å‰åºéå†ï¼š 144.äºŒå‰æ ‘çš„å‰åºéå†
    * ååºéå†ï¼š 145.äºŒå‰æ ‘çš„ååºéå†
    * ä¸­åºéå†ï¼š 94.äºŒå‰æ ‘çš„ä¸­åºéå†
* äºŒå‰æ ‘å¹¿åº¦ä¼˜å…ˆéå† 
    * å±‚åºéå†ï¼š102.äºŒå‰æ ‘çš„å±‚åºéå†



å…ˆå¸®å¤§å®¶æ˜ç¡®ä¸€ä¸‹äºŒå‰æ ‘çš„éå†è§„åˆ™ï¼š

![image.png](https://pic.leetcode-cn.com/0005d6f797d3281bbe2be08effd0f8fa991dc8126aef754929af34edf650626a-image.png)


ä»¥ä¸Šè¿°ä¸­ï¼Œå‰ä¸­ååºéå†é¡ºåºå¦‚ä¸‹ï¼š

* å‰åºéå†ï¼ˆä¸­å·¦å³ï¼‰ï¼š5 4 1 2 6 7 8
* ä¸­åºéå†ï¼ˆå·¦ä¸­å³ï¼‰ï¼š1 4 2 5 7 6 8
* ååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼š1 2 4 7 8 6 5

# é€’å½’æ³•

è¿™æ¬¡æˆ‘ä»¬è¦å¥½å¥½è°ˆä¸€è°ˆé€’å½’ï¼Œä¸ºä»€ä¹ˆå¾ˆå¤šåŒå­¦çœ‹é€’å½’ç®—æ³•éƒ½æ˜¯â€œä¸€çœ‹å°±ä¼šï¼Œä¸€å†™å°±åºŸâ€ã€‚

ä¸»è¦æ˜¯å¯¹é€’å½’ä¸æˆä½“ç³»ï¼Œæ²¡æœ‰æ–¹æ³•è®ºï¼Œ**æ¯æ¬¡å†™é€’å½’ç®—æ³• ï¼Œéƒ½æ˜¯é ç„å­¦æ¥å†™ä»£ç **ï¼Œä»£ç èƒ½ä¸èƒ½ç¼–è¿‡éƒ½é è¿æ°”ã€‚

**æœ¬ç¯‡å°†ä»‹ç»å‰åä¸­åºçš„é€’å½’å†™æ³•ï¼Œä¸€äº›åŒå­¦å¯èƒ½ä¼šæ„Ÿè§‰å¾ˆç®€å•ï¼Œå…¶å®ä¸ç„¶ï¼Œæˆ‘ä»¬è¦é€šè¿‡ç®€å•é¢˜ç›®æŠŠæ–¹æ³•è®ºç¡®å®šä¸‹æ¥ï¼Œæœ‰äº†æ–¹æ³•è®ºï¼Œåé¢æ‰èƒ½åº”ä»˜å¤æ‚çš„é€’å½’ã€‚**

è¿™é‡Œå¸®åŠ©å¤§å®¶ç¡®å®šä¸‹æ¥é€’å½’ç®—æ³•çš„ä¸‰ä¸ªè¦ç´ ã€‚**æ¯æ¬¡å†™é€’å½’ï¼Œéƒ½æŒ‰ç…§è¿™ä¸‰è¦ç´ æ¥å†™ï¼Œå¯ä»¥ä¿è¯å¤§å®¶å†™å‡ºæ­£ç¡®çš„é€’å½’ç®—æ³•ï¼**

1. **ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼š**
ç¡®å®šå“ªäº›å‚æ•°æ˜¯é€’å½’çš„è¿‡ç¨‹ä¸­éœ€è¦å¤„ç†çš„ï¼Œé‚£ä¹ˆå°±åœ¨é€’å½’å‡½æ•°é‡ŒåŠ ä¸Šè¿™ä¸ªå‚æ•°ï¼Œ å¹¶ä¸”è¿˜è¦æ˜ç¡®æ¯æ¬¡é€’å½’çš„è¿”å›å€¼æ˜¯ä»€ä¹ˆè¿›è€Œç¡®å®šé€’å½’å‡½æ•°çš„è¿”å›ç±»å‹ã€‚

2. **ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼š**
å†™å®Œäº†é€’å½’ç®—æ³•,  è¿è¡Œçš„æ—¶å€™ï¼Œç»å¸¸ä¼šé‡åˆ°æ ˆæº¢å‡ºçš„é”™è¯¯ï¼Œå°±æ˜¯æ²¡å†™ç»ˆæ­¢æ¡ä»¶æˆ–è€…ç»ˆæ­¢æ¡ä»¶å†™çš„ä¸å¯¹ï¼Œæ“ä½œç³»ç»Ÿä¹Ÿæ˜¯ç”¨ä¸€ä¸ªæ ˆçš„ç»“æ„æ¥ä¿å­˜æ¯ä¸€å±‚é€’å½’çš„ä¿¡æ¯ï¼Œå¦‚æœé€’å½’æ²¡æœ‰ç»ˆæ­¢ï¼Œæ“ä½œç³»ç»Ÿçš„å†…å­˜æ ˆå¿…ç„¶å°±ä¼šæº¢å‡ºã€‚

3. **ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼š**
ç¡®å®šæ¯ä¸€å±‚é€’å½’éœ€è¦å¤„ç†çš„ä¿¡æ¯ã€‚åœ¨è¿™é‡Œä¹Ÿå°±ä¼šé‡å¤è°ƒç”¨è‡ªå·±æ¥å®ç°é€’å½’çš„è¿‡ç¨‹ã€‚

å¥½äº†ï¼Œæˆ‘ä»¬ç¡®è®¤äº†é€’å½’çš„ä¸‰è¦ç´ ï¼Œæ¥ä¸‹æ¥å°±æ¥ç»ƒç»ƒæ‰‹ï¼š

**ä»¥ä¸‹ä»¥å‰åºéå†ä¸ºä¾‹ï¼š**

1. **ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼**ï¼šå› ä¸ºè¦æ‰“å°å‡ºå‰åºéå†èŠ‚ç‚¹çš„æ•°å€¼ï¼Œæ‰€ä»¥å‚æ•°é‡Œéœ€è¦ä¼ å…¥vectoråœ¨æ”¾èŠ‚ç‚¹çš„æ•°å€¼ï¼Œé™¤äº†è¿™ä¸€ç‚¹å°±ä¸éœ€è¦åœ¨å¤„ç†ä»€ä¹ˆæ•°æ®äº†ä¹Ÿä¸éœ€è¦æœ‰è¿”å›å€¼ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°è¿”å›ç±»å‹å°±æ˜¯voidï¼Œä»£ç å¦‚ä¸‹ï¼š

```
void traversal(TreeNode* cur, vector<int>& vec)
```

2. **ç¡®å®šç»ˆæ­¢æ¡ä»¶**ï¼šåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚ä½•ç®—æ˜¯é€’å½’ç»“æŸäº†å‘¢ï¼Œå½“ç„¶æ˜¯å½“å‰éå†çš„èŠ‚ç‚¹æ˜¯ç©ºäº†ï¼Œé‚£ä¹ˆæœ¬å±‚é€’å½’å°±è¦è¦ç»“æŸäº†ï¼Œæ‰€ä»¥å¦‚æœå½“å‰éå†çš„è¿™ä¸ªèŠ‚ç‚¹æ˜¯ç©ºï¼Œå°±ç›´æ¥returnï¼Œä»£ç å¦‚ä¸‹ï¼š

```
if (cur == NULL) return;
```

3. **ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘**ï¼šå‰åºéå†æ˜¯ä¸­å·¦å³çš„å¾ªåºï¼Œæ‰€ä»¥åœ¨å•å±‚é€’å½’çš„é€»è¾‘ï¼Œæ˜¯è¦å…ˆå–ä¸­èŠ‚ç‚¹çš„æ•°å€¼ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
vec.push_back(cur->val);    // ä¸­
traversal(cur->left, vec);  // å·¦
traversal(cur->right, vec); // å³
```

å•å±‚é€’å½’çš„é€»è¾‘å°±æ˜¯æŒ‰ç…§ä¸­å·¦å³çš„é¡ºåºæ¥å¤„ç†çš„ï¼Œè¿™æ ·äºŒå‰æ ‘çš„å‰åºéå†ï¼ŒåŸºæœ¬å°±å†™å®Œäº†ï¼Œåœ¨çœ‹ä¸€ä¸‹å®Œæ•´ä»£ç ï¼š

å‰åºéå†ï¼š

```
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // ä¸­
        traversal(cur->left, vec);  // å·¦
        traversal(cur->right, vec); // å³
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

é‚£ä¹ˆå‰åºéå†å†™å‡ºæ¥ä¹‹åï¼Œä¸­åºå’Œååºéå†å°±ä¸éš¾ç†è§£äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š

ä¸­åºéå†ï¼š

```
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // å·¦
        vec.push_back(cur->val);    // ä¸­
        traversal(cur->right, vec); // å³
    }
```

ååºéå†ï¼š

```
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // å·¦
        traversal(cur->right, vec); // å³
        vec.push_back(cur->val);    // ä¸­
    }
```

æ­¤æ—¶å¤§å®¶å¯ä»¥åšä¸€åšleetcodeä¸Šä¸‰é“é¢˜ç›®ï¼Œåˆ†åˆ«æ˜¯ï¼š

* 144.äºŒå‰æ ‘çš„å‰åºéå†
* 145.äºŒå‰æ ‘çš„ååºéå†
* 94.äºŒå‰æ ‘çš„ä¸­åºéå†

å¯èƒ½æœ‰åŒå­¦æ„Ÿè§‰å‰åä¸­åºéå†çš„é€’å½’å¤ªç®€å•äº†ï¼Œè¦æ‰“è¿­ä»£æ³•ï¼ˆéé€’å½’ï¼‰ï¼Œåˆ«æ€¥ï¼Œæˆ‘ä»¬æ˜å¤©æ‰“è¿­ä»£æ³•ï¼Œæ‰“ä¸ªé€šé€ï¼


# è¿­ä»£æ³• 

ä¸ºä»€ä¹ˆå¯ä»¥ç”¨è¿­ä»£æ³•ï¼ˆéé€’å½’çš„æ–¹å¼ï¼‰æ¥å®ç°äºŒå‰æ ‘çš„å‰åä¸­åºéå†å‘¢ï¼Ÿ

**é€’å½’çš„å®ç°å°±æ˜¯ï¼šæ¯ä¸€æ¬¡é€’å½’è°ƒç”¨éƒ½ä¼šæŠŠå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€ç­‰å‹å…¥è°ƒç”¨æ ˆä¸­**ï¼Œç„¶åé€’å½’è¿”å›çš„æ—¶å€™ï¼Œä»æ ˆé¡¶å¼¹å‡ºä¸Šä¸€æ¬¡é€’å½’çš„å„é¡¹å‚æ•°ï¼Œæ‰€ä»¥è¿™å°±æ˜¯é€’å½’ä¸ºä»€ä¹ˆå¯ä»¥è¿”å›ä¸Šä¸€å±‚ä½ç½®çš„åŸå› ã€‚

æ­¤æ—¶å¤§å®¶åº”è¯¥çŸ¥é“æˆ‘ä»¬ç”¨æ ˆä¹Ÿå¯ä»¥æ˜¯å®ç°äºŒå‰æ ‘çš„å‰åä¸­åºéå†äº†ã€‚

## å‰åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹å‰åºéå†ã€‚

å‰åºéå†æ˜¯ä¸­å·¦å³ï¼Œæ¯æ¬¡å…ˆå¤„ç†çš„æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå…ˆå°†è·ŸèŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼Œç„¶åå°†å³å­©å­åŠ å…¥æ ˆï¼Œå†åŠ å…¥å·¦å­©å­ã€‚

ä¸ºä»€ä¹ˆè¦å…ˆåŠ å…¥ å³å­©å­ï¼Œå†åŠ å…¥å·¦å­©å­å‘¢ï¼Ÿ å› ä¸ºè¿™æ ·å‡ºæ ˆçš„æ—¶å€™æ‰æ˜¯ä¸­å·¦å³çš„é¡ºåºã€‚

åŠ¨ç”»å¦‚ä¸‹ï¼š


![äºŒå‰æ ‘å‰åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰.gif](https://pic.leetcode-cn.com/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)


ä¸éš¾å†™å‡ºå¦‚ä¸‹ä»£ç : ï¼ˆ**æ³¨æ„ä»£ç ä¸­ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ**ï¼‰

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // ä¸­
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // å³ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->left) st.push(node->left);             // å·¦ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
        }
        return result;
    }
};
```

æ­¤æ—¶ä¼šå‘ç°è²Œä¼¼ä½¿ç”¨è¿­ä»£æ³•å†™å‡ºå‰åºéå†å¹¶ä¸éš¾ï¼Œç¡®å®ä¸éš¾ã€‚

**æ­¤æ—¶æ˜¯ä¸æ˜¯æƒ³æ”¹ä¸€ç‚¹å‰åºéå†ä»£ç é¡ºåºå°±æŠŠä¸­åºéå†æå‡ºæ¥äº†ï¼Ÿ**

å…¶å®è¿˜çœŸä¸è¡Œï¼

ä½†æ¥ä¸‹æ¥ï¼Œ**å†ç”¨è¿­ä»£æ³•å†™ä¸­åºéå†çš„æ—¶å€™ï¼Œä¼šå‘ç°å¥—è·¯åˆä¸ä¸€æ ·äº†ï¼Œç›®å‰çš„å‰åºéå†çš„é€»è¾‘æ— æ³•ç›´æ¥åº”ç”¨åˆ°ä¸­åºéå†ä¸Šã€‚**

## ä¸­åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰

ä¸ºäº†è§£é‡Šæ¸…æ¥šï¼Œæˆ‘è¯´æ˜ä¸€ä¸‹ åˆšåˆšåœ¨è¿­ä»£çš„è¿‡ç¨‹ä¸­ï¼Œå…¶å®æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ“ä½œï¼š

1. **å¤„ç†ï¼šå°†å…ƒç´ æ”¾è¿›resultæ•°ç»„ä¸­**
2. **è®¿é—®ï¼šéå†èŠ‚ç‚¹**

åˆ†æä¸€ä¸‹ä¸ºä»€ä¹ˆåˆšåˆšå†™çš„å‰åºéå†çš„ä»£ç ï¼Œä¸èƒ½å’Œä¸­åºéå†é€šç”¨å‘¢ï¼Œå› ä¸ºå‰åºéå†çš„é¡ºåºæ˜¯ä¸­å·¦å³ï¼Œå…ˆè®¿é—®çš„å…ƒç´ æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œè¦å¤„ç†çš„å…ƒç´ ä¹Ÿæ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œæ‰€ä»¥åˆšåˆšæ‰èƒ½å†™å‡ºç›¸å¯¹ç®€æ´çš„ä»£ç ï¼Œ**å› ä¸ºè¦è®¿é—®çš„å…ƒç´ å’Œè¦å¤„ç†çš„å…ƒç´ é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œéƒ½æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚**

é‚£ä¹ˆå†çœ‹çœ‹ä¸­åºéå†ï¼Œä¸­åºéå†æ˜¯å·¦ä¸­å³ï¼Œå…ˆè®¿é—®çš„æ˜¯äºŒå‰æ ‘é¡¶éƒ¨çš„èŠ‚ç‚¹ï¼Œç„¶åä¸€å±‚ä¸€å±‚å‘ä¸‹è®¿é—®ï¼Œç›´åˆ°åˆ°è¾¾æ ‘å·¦é¢çš„æœ€åº•éƒ¨ï¼Œå†å¼€å§‹å¤„ç†èŠ‚ç‚¹ï¼ˆä¹Ÿå°±æ˜¯åœ¨æŠŠèŠ‚ç‚¹çš„æ•°å€¼æ”¾è¿›resultæ•°ç»„ä¸­ï¼‰ï¼Œè¿™å°±é€ æˆäº†**å¤„ç†é¡ºåºå’Œè®¿é—®é¡ºåºæ˜¯ä¸ä¸€è‡´çš„ã€‚**

é‚£ä¹ˆ**åœ¨ä½¿ç”¨è¿­ä»£æ³•å†™ä¸­åºéå†ï¼Œå°±éœ€è¦å€Ÿç”¨æŒ‡é’ˆçš„éå†æ¥å¸®åŠ©è®¿é—®èŠ‚ç‚¹ï¼Œæ ˆåˆ™ç”¨æ¥å¤„ç†èŠ‚ç‚¹ä¸Šçš„å…ƒç´ ã€‚**

åŠ¨ç”»å¦‚ä¸‹ï¼š

![äºŒå‰æ ‘ä¸­åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰.gif](https://pic.leetcode-cn.com/1600934697-oafdTT-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

**ä¸­åºéå†ï¼Œå¯ä»¥å†™å‡ºå¦‚ä¸‹ä»£ç ï¼š**

```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur->left;                // å·¦
            } else {
                cur = st.top(); // ä»æ ˆé‡Œå¼¹å‡ºçš„æ•°æ®ï¼Œå°±æ˜¯è¦å¤„ç†çš„æ•°æ®ï¼ˆæ”¾è¿›resultæ•°ç»„é‡Œçš„æ•°æ®ï¼‰
                st.pop();
                result.push_back(cur->val);     // ä¸­
                cur = cur->right;               // å³
            }
        }
        return result;
    }
};

```

## ååºéå†ï¼ˆè¿­ä»£æ³•ï¼‰

å†æ¥çœ‹ååºéå†ï¼Œå…ˆåºéå†æ˜¯ä¸­å·¦å³ï¼Œåç»­éå†æ˜¯å·¦å³ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è°ƒæ•´ä¸€ä¸‹å…ˆåºéå†çš„ä»£ç é¡ºåºï¼Œå°±å˜æˆä¸­å³å·¦çš„éå†é¡ºåºï¼Œç„¶ååœ¨åè½¬resultæ•°ç»„ï¼Œè¾“å‡ºçš„ç»“æœé¡ºåºå°±æ˜¯å·¦å³ä¸­äº†ï¼Œå¦‚ä¸‹å›¾ï¼š

![image.png](https://pic.leetcode-cn.com/4f49ee1ccbd7b2d641a740d63a68f69146dc0bcb6dd5c0471e4289730d902352-image.png)

**æ‰€ä»¥ååºéå†åªéœ€è¦å‰åºéå†çš„ä»£ç ç¨ä½œä¿®æ”¹å°±å¯ä»¥äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š**

```C++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // ç›¸å¯¹äºå‰åºéå†ï¼Œè¿™æ›´æ”¹ä¸€ä¸‹å…¥æ ˆé¡ºåº ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->right) st.push(node->right); // ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ
        }
        reverse(result.begin(), result.end()); // å°†ç»“æœåè½¬ä¹‹åå°±æ˜¯å·¦å³ä¸­çš„é¡ºåºäº†
        return result;
    }
};

```


æ­¤æ—¶æˆ‘ä»¬å®ç°äº†å‰åä¸­éå†çš„ä¸‰ç§è¿­ä»£æ³•ï¼Œ**æ˜¯ä¸æ˜¯å‘ç°è¿­ä»£æ³•å®ç°çš„å…ˆä¸­ååºï¼Œå…¶å®é£æ ¼ä¹Ÿä¸æ˜¯é‚£ä¹ˆç»Ÿä¸€ï¼Œé™¤äº†å…ˆåºå’Œååºï¼Œæœ‰å…³è”ï¼Œä¸­åºå®Œå…¨å°±æ˜¯å¦ä¸€ä¸ªé£æ ¼äº†ï¼Œä¸€ä¼šç”¨æ ˆéå†ï¼Œä¸€ä¼šåˆç”¨æŒ‡é’ˆæ¥éå†ã€‚**

# äºŒå‰æ ‘å‰ä¸­åè¿­ä»£æ–¹å¼ç»Ÿä¸€å†™æ³•

**è¿­ä»£æ³•å®ç°çš„å…ˆä¸­ååºï¼Œå…¶å®é£æ ¼ä¹Ÿä¸æ˜¯é‚£ä¹ˆç»Ÿä¸€ï¼Œé™¤äº†å…ˆåºå’Œååºï¼Œæœ‰å…³è”ï¼Œä¸­åºå®Œå…¨å°±æ˜¯å¦ä¸€ä¸ªé£æ ¼äº†ï¼Œä¸€ä¼šç”¨æ ˆéå†ï¼Œä¸€ä¼šåˆç”¨æŒ‡é’ˆæ¥éå†ã€‚**

å®è·µè¿‡çš„åŒå­¦ï¼Œä¹Ÿä¼šå‘ç°ä½¿ç”¨è¿­ä»£æ³•å®ç°å…ˆä¸­ååºéå†ï¼Œå¾ˆéš¾å†™å‡ºç»Ÿä¸€çš„ä»£ç ï¼Œä¸åƒæ˜¯é€’å½’æ³•ï¼Œå®ç°äº†å…¶ä¸­çš„ä¸€ç§éå†æ–¹å¼ï¼Œå…¶ä»–ä¸¤ç§åªè¦ç¨ç¨æ”¹ä¸€ä¸‹èŠ‚ç‚¹é¡ºåºå°±å¯ä»¥äº†ã€‚

å…¶å®**é’ˆå¯¹ä¸‰ç§éå†æ–¹å¼ï¼Œä½¿ç”¨è¿­ä»£æ³•æ˜¯å¯ä»¥å†™å‡ºç»Ÿä¸€é£æ ¼çš„ä»£ç ï¼**

**é‡å¤´æˆæ¥äº†ï¼Œæ¥ä¸‹æ¥ä»‹ç»ä¸€ä¸‹ç»Ÿä¸€å†™æ³•ã€‚**

æˆ‘ä»¬ä»¥ä¸­åºéå†ä¸ºä¾‹ï¼Œ**æ— æ³•åŒæ—¶è§£å†³è®¿é—®èŠ‚ç‚¹ï¼ˆéå†èŠ‚ç‚¹ï¼‰å’Œå¤„ç†èŠ‚ç‚¹ï¼ˆå°†å…ƒç´ æ”¾è¿›ç»“æœé›†ï¼‰ä¸ä¸€è‡´çš„æƒ…å†µ**ã€‚

**é‚£æˆ‘ä»¬å°±å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼ŒæŠŠè¦å¤„ç†çš„èŠ‚ç‚¹ä¹Ÿæ”¾å…¥æ ˆä¸­ä½†æ˜¯è¦åšæ ‡è®°ã€‚**

å¦‚ä½•æ ‡è®°å‘¢ï¼Œ**å°±æ˜¯è¦å¤„ç†çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¹‹åï¼Œç´§æ¥ç€æ”¾å…¥ä¸€ä¸ªç©ºæŒ‡é’ˆä½œä¸ºæ ‡è®°ã€‚** è¿™ç§æ–¹æ³•ä¹Ÿå¯ä»¥å«åšæ ‡è®°æ³•ã€‚

## è¿­ä»£æ³•ä¸­åºéå†

ä¸­åºéå†ä»£ç å¦‚ä¸‹ï¼šï¼ˆè¯¦ç»†æ³¨é‡Šï¼‰

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                if (node->right) st.push(node->right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰

                st.push(node);                          // æ·»åŠ ä¸­èŠ‚ç‚¹
                st.push(NULL); // ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚

                if (node->left) st.push(node->left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.top();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.push_back(node->val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
    }
};
```

çœ‹ä»£ç æœ‰ç‚¹æŠ½è±¡æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹åŠ¨ç”»(ä¸­åºéå†)ï¼š

![ä¸­åºéå†è¿­ä»£ï¼ˆç»Ÿä¸€å†™æ³•ï¼‰.mp4](62c6ae4a-9046-428a-ac1f-8a66be274401)

åŠ¨ç”»ä¸­ï¼Œresultæ•°ç»„å°±æ˜¯æœ€ç»ˆç»“æœé›†ã€‚

å¯ä»¥çœ‹å‡ºæˆ‘ä»¬å°†è®¿é—®çš„èŠ‚ç‚¹ç›´æ¥åŠ å…¥åˆ°æ ˆä¸­ï¼Œä½†å¦‚æœæ˜¯å¤„ç†çš„èŠ‚ç‚¹åˆ™åé¢æ”¾å…¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œ è¿™æ ·åªæœ‰ç©ºèŠ‚ç‚¹å¼¹å‡ºçš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†ã€‚

æ­¤æ—¶æˆ‘ä»¬å†æ¥çœ‹å‰åºéå†ä»£ç ã€‚



## è¿­ä»£æ³•å‰åºéå†

è¿­ä»£æ³•å‰åºéå†ä»£ç å¦‚ä¸‹ï¼š (**æ³¨æ„æ­¤æ—¶æˆ‘ä»¬å’Œä¸­åºéå†ç›¸æ¯”ä»…ä»…æ”¹å˜äº†ä¸¤è¡Œä»£ç çš„é¡ºåº**)

```C++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // å³
                if (node->left) st.push(node->left);    // å·¦
                st.push(node);                          // ä¸­
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

## è¿­ä»£æ³•ååºéå†

åç»­éå†ä»£ç å¦‚ä¸‹ï¼š (**æ³¨æ„æ­¤æ—¶æˆ‘ä»¬å’Œä¸­åºéå†ç›¸æ¯”ä»…ä»…æ”¹å˜äº†ä¸¤è¡Œä»£ç çš„é¡ºåº**)

```C++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // ä¸­
                st.push(NULL);

                if (node->right) st.push(node->right);  // å³
                if (node->left) st.push(node->left);    // å·¦

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

# æ€»ç»“

æ­¤æ—¶æˆ‘ä»¬å†™å‡ºäº†ç»Ÿä¸€é£æ ¼çš„è¿­ä»£æ³•ï¼Œä¸ç”¨åœ¨çº ç»“äºå‰åºå†™å‡ºæ¥äº†ï¼Œä¸­åºå†™ä¸å‡ºæ¥çš„æƒ…å†µäº†ã€‚

ä½†æ˜¯ç»Ÿä¸€é£æ ¼çš„è¿­ä»£æ³•å¹¶ä¸å¥½ç†è§£ï¼Œè€Œä¸”æƒ³åœ¨é¢è¯•ç›´æ¥å†™å‡ºæ¥è¿˜æœ‰éš¾åº¦çš„ã€‚

æ‰€ä»¥å¤§å®¶æ ¹æ®è‡ªå·±çš„ä¸ªäººå–œå¥½ï¼Œå¯¹äºäºŒå‰æ ‘çš„å‰ä¸­ååºéå†ï¼Œé€‰æ‹©ä¸€ç§è‡ªå·±å®¹æ˜“ç†è§£çš„é€’å½’å’Œè¿­ä»£æ³•ã€‚

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼ˆé€’å½’ï¼‰


Javaï¼š
```Java
// å‰åºéå†Â·é€’å½’Â·LC144_äºŒå‰æ ‘çš„å‰åºéå†
class Solution {
    ArrayList<Integer> preOrderReverse(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        preOrder(root, result);
        return result;
    }

    void preOrder(TreeNode root, ArrayList<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);           // æ³¨æ„è¿™ä¸€å¥
        preOrder(root.left, result);
        preOrder(root.right, result);
    }
}
// ä¸­åºéå†Â·é€’å½’Â·LC94_äºŒå‰æ ‘çš„ä¸­åºéå†
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    void inorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        inorder(root.left, list);
        list.add(root.val);             // æ³¨æ„è¿™ä¸€å¥
        inorder(root.right, list);
    }
}
// ååºéå†Â·é€’å½’Â·LC145_äºŒå‰æ ‘çš„ååºéå†
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }

    void postorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        postorder(root.left, list);
        postorder(root.right, list);
        list.add(root.val);             // æ³¨æ„è¿™ä¸€å¥
    }
}
```

Pythonï¼š
```python3
# å‰åºéå†-é€’å½’-LC144_äºŒå‰æ ‘çš„å‰åºéå†
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # ä¿å­˜ç»“æœ
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # å‰åº
            traversal(root.left)    # å·¦
            traversal(root.right)   # å³

        traversal(root)
        return result

# ä¸­åºéå†-é€’å½’-LC94_äºŒå‰æ ‘çš„ä¸­åºéå†
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # å·¦
            result.append(root.val) # ä¸­åº
            traversal(root.right)   # å³

        traversal(root)
        return result

# ååºéå†-é€’å½’-LC145_äºŒå‰æ ‘çš„ååºéå†
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # å·¦
            traversal(root.right)   # å³
            result.append(root.val) # ååº

        traversal(root)
        return result
```

Goï¼š

å‰åºéå†:
```go
func PreorderTraversal(root *TreeNode) (res []int) {
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode) {
	if node == nil {
            return
	}
	res = append(res,node.Val)
	traversal(node.Left)
	traversal(node.Right)
    }
    traversal(root)
    return res
}

```
ä¸­åºéå†:

```go
func InorderTraversal(root *TreeNode) (res []int) {
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode) {
	if node == nil {
	    return
	}
	traversal(node.Left)
	res = append(res,node.Val)
	traversal(node.Right)
    }
    traversal(root)
    return res
}
```
ååºéå†:

```go
func PostorderTraversal(root *TreeNode) (res []int) {
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode) {
	if node == nil {
	    return
	}
	traversal(node.Left)
	traversal(node.Right)
        res = append(res,node.Val)
    }
    traversal(root)
    return res
}
```

javaScript:

```js

å‰åºéå†:

var preorderTraversal = function(root, res = []) {
    if (!root) return res;
    res.push(root.val);
    preorderTraversal(root.left, res)
    preorderTraversal(root.right, res)
    return res;
};

ä¸­åºéå†:

var inorderTraversal = function(root, res = []) {
    if (!root) return res;
    inorderTraversal(root.left, res);
    res.push(root.val);
    inorderTraversal(root.right, res);
    return res;
};

ååºéå†:

var postorderTraversal = function(root, res = []) {
    if (!root) return res;
    postorderTraversal(root.left, res);
    postorderTraversal(root.right, res);
    res.push(root.val);
    return res;
};
```
Javascriptç‰ˆæœ¬ï¼š

å‰åºéå†ï¼š
```Javascript
var preorderTraversal = function(root) {
 let res=[];
 const dfs=function(root){
     if(root===null)return ;
     //å…ˆåºéå†æ‰€ä»¥ä»çˆ¶èŠ‚ç‚¹å¼€å§‹
     res.push(root.val);
     //é€’å½’å·¦å­æ ‘
     dfs(root.left);
     //é€’å½’å³å­æ ‘
     dfs(root.right);
 }
 //åªä½¿ç”¨ä¸€ä¸ªå‚æ•° ä½¿ç”¨é—­åŒ…è¿›è¡Œå­˜å‚¨ç»“æœ
 dfs(root);
 return res;
};
```
ä¸­åºéå†
```javascript
var inorderTraversal = function(root) {
    let res=[];
    const dfs=function(root){
        if(root===null){
            return ;
        }
        dfs(root.left);
        res.push(root.val);
        dfs(root.right);
    }
    dfs(root);
    return res;
};
```

ååºéå†
```javascript
var postorderTraversal = function(root) {
    let res=[];
    const dfs=function(root){
        if(root===null){
            return ;
        }
        dfs(root.left);
        dfs(root.right);
        res.push(root.val);
    }
    dfs(root);
    return res;
};
```

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼ˆè¿­ä»£ä¸ç»Ÿä¸€å†™æ³•ï¼‰

Javaï¼š

```java
// å‰åºéå†é¡ºåºï¼šä¸­-å·¦-å³ï¼Œå…¥æ ˆé¡ºåºï¼šä¸­-å³-å·¦
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}

// ä¸­åºéå†é¡ºåº: å·¦-ä¸­-å³ å…¥æ ˆé¡ºåºï¼š å·¦-å³
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left;
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
        }
        return result;
    }
}

// ååºéå†é¡ºåº å·¦-å³-ä¸­ å…¥æ ˆé¡ºåºï¼šä¸­-å·¦-å³ å‡ºæ ˆé¡ºåºï¼šä¸­-å³-å·¦ï¼Œ æœ€åç¿»è½¬ç»“æœ
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```




Pythonï¼š
```python3
# å‰åºéå†-è¿­ä»£-LC144_äºŒå‰æ ‘çš„å‰åºéå†
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # æ ¹ç»“ç‚¹ä¸ºç©ºåˆ™è¿”å›ç©ºåˆ—è¡¨
        if not root:
            return []
        stack = [root]
        result = []
        while stack:
            node = stack.pop()
            # ä¸­ç»“ç‚¹å…ˆå¤„ç†
            result.append(node.val)
            # å³å­©å­å…ˆå…¥æ ˆ
            if node.right:
                stack.append(node.right)
            # å·¦å­©å­åå…¥æ ˆ
            if node.left:
                stack.append(node.left)
        return result
        
# ä¸­åºéå†-è¿­ä»£-LC94_äºŒå‰æ ‘çš„ä¸­åºéå†
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        stack = []  # ä¸èƒ½æå‰å°†rootç»“ç‚¹åŠ å…¥stackä¸­
        result = []
        cur = root
        while cur or stack:
            # å…ˆè¿­ä»£è®¿é—®æœ€åº•å±‚çš„å·¦å­æ ‘ç»“ç‚¹
            if cur:     
                stack.append(cur)
                cur = cur.left		
            # åˆ°è¾¾æœ€å·¦ç»“ç‚¹åå¤„ç†æ ˆé¡¶ç»“ç‚¹    
            else:		
                cur = stack.pop()
                result.append(cur.val)
                # å–æ ˆé¡¶å…ƒç´ å³ç»“ç‚¹
                cur = cur.right	
        return result
        
# ååºéå†-è¿­ä»£-LC145_äºŒå‰æ ‘çš„ååºéå†
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        stack = [root]
        result = []
        while stack:
            node = stack.pop()
            # ä¸­ç»“ç‚¹å…ˆå¤„ç†
            result.append(node.val)
            # å·¦å­©å­å…ˆå…¥æ ˆ
            if node.left:
                stack.append(node.left)
            # å³å­©å­åå…¥æ ˆ
            if node.right:
                stack.append(node.right)
        # å°†æœ€ç»ˆçš„æ•°ç»„ç¿»è½¬
        return result[::-1]
```


Goï¼š
> è¿­ä»£æ³•å‰åºéå†

```go
//è¿­ä»£æ³•å‰åºéå†
/**
 type Element struct {
    // å…ƒç´ ä¿ç®¡çš„å€¼
    Value interface{}
    // å†…å«éšè—æˆ–éå¯¼å‡ºå­—æ®µ
}

func (l *List) Back() *Element 
å‰åºéå†ï¼šä¸­å·¦å³
å‹æ ˆé¡ºåºï¼šå³å·¦ä¸­
 **/
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New()
    stack.PushBack(root.Right)
    stack.PushBack(root.Left)
    res:=[]int{}
    res=append(res,root.Val)
    for stack.Len()>0 {
        e:=stack.Back()
        stack.Remove(e)
        node := e.Value.(*TreeNode)//eæ˜¯Elementç±»å‹ï¼Œå…¶å€¼ä¸ºe.Value.ç”±äºValueä¸ºæ¥å£ï¼Œæ‰€ä»¥è¦æ–­è¨€
        if node==nil{
            continue
        }
        res=append(res,node.Val)
        stack.PushBack(node.Right)
        stack.PushBack(node.Left)
    }
    return res
}
```

> è¿­ä»£æ³•ååºéå†

```go
//è¿­ä»£æ³•ååºéå†
//åç»­éå†ï¼šå·¦å³ä¸­
//å‹æ ˆé¡ºåºï¼šä¸­å³å·¦(æŒ‰ç…§å‰åºéå†æ€è·¯)ï¼Œå†åè½¬ç»“æœæ•°ç»„
func postorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New()
    stack.PushBack(root.Left)
    stack.PushBack(root.Right)
    res:=[]int{}
    res=append(res,root.Val)
    for stack.Len()>0 {
        e:=stack.Back()
        stack.Remove(e)
        node := e.Value.(*TreeNode)//eæ˜¯Elementç±»å‹ï¼Œå…¶å€¼ä¸ºe.Value.ç”±äºValueä¸ºæ¥å£ï¼Œæ‰€ä»¥è¦æ–­è¨€
        if node==nil{
            continue
        }
        res=append(res,node.Val)
        stack.PushBack(node.Left)
        stack.PushBack(node.Right)
    }
    for i:=0;i<len(res)/2;i++{
        res[i],res[len(res)-i-1] = res[len(res)-i-1],res[i]
    }
    return res
}
```

> è¿­ä»£æ³•ä¸­åºéå†

```go
//è¿­ä»£æ³•ä¸­åºéå†
func inorderTraversal(root *TreeNode) []int {
    rootRes:=[]int{}
    if root==nil{
       return nil
    }
    stack:=list.New()
    node:=root
    //å…ˆå°†æ‰€æœ‰å·¦èŠ‚ç‚¹æ‰¾åˆ°ï¼ŒåŠ å…¥æ ˆä¸­
    for node!=nil{
        stack.PushBack(node)
        node=node.Left
    }
    //å…¶æ¬¡å¯¹æ ˆä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å…ˆå¼¹å‡ºåŠ å…¥åˆ°ç»“æœé›†ä¸­ï¼Œå†æ‰¾åˆ°è¯¥èŠ‚ç‚¹çš„å³èŠ‚ç‚¹çš„æ‰€æœ‰å·¦èŠ‚ç‚¹åŠ å…¥æ ˆä¸­
    for stack.Len()>0{
        e:=stack.Back()
        node:=e.Value.(*TreeNode)
        stack.Remove(e)
        //æ‰¾åˆ°è¯¥èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œå†æœç´¢ä»–çš„æ‰€æœ‰å·¦èŠ‚ç‚¹åŠ å…¥æ ˆä¸­
        rootRes=append(rootRes,node.Val)
        node=node.Right
        for node!=nil{
            stack.PushBack(node)
            node=node.Left
        }
    }
    return rootRes
}
```

javaScript

```js

å‰åºéå†:

// å…¥æ ˆ å³ -> å·¦
// å‡ºæ ˆ ä¸­ -> å·¦ -> å³
var preorderTraversal = function(root, res = []) {
    if(!root) return res;
    const stack = [root];
    let cur = null;
    while(stack.length) {
        cur = stack.pop();
        res.push(cur.val);
        cur.right && stack.push(cur.right);
        cur.left && stack.push(cur.left);
    }
    return res;
};

ä¸­åºéå†:

// å…¥æ ˆ å·¦ -> å³
// å‡ºæ ˆ å·¦ -> ä¸­ -> å³

var inorderTraversal = function(root, res = []) {
    const stack = [];
    let cur = root;
    while(stack.length || cur) {
        if(cur) {
            stack.push(cur);
            // å·¦
            cur = cur.left;
        } else {
            // --> å¼¹å‡º ä¸­
            cur = stack.pop();
            res.push(cur.val); 
            // å³
            cur = cur.right;
        }
    };
    return res;
};

ååºéå†:

// å…¥æ ˆ å·¦ -> å³
// å‡ºæ ˆ ä¸­ -> å³ -> å·¦ ç»“æœç¿»è½¬

var postorderTraversal = function(root, res = []) {
    if (!root) return res;
    const stack = [root];
    let cur = null;
    do {
        cur = stack.pop();
        res.push(cur.val);
        cur.left && stack.push(cur.left);
        cur.right && stack.push(cur.right);
    } while(stack.length);
    return res.reverse();
};
```

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼ˆè¿­ä»£ç»Ÿä¸€å†™æ³•ï¼‰


Javaï¼š
  è¿­ä»£æ³•å‰åºéå†ä»£ç å¦‚ä¸‹:
  ```java
  class Solution {
    
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                if (node.right!=null) st.push(node.right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                if (node.left!=null) st.push(node.left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                st.push(node);                          // æ·»åŠ ä¸­èŠ‚ç‚¹
                st.push(null); // ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚
                
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.peek();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.add(node.val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
    }
}

  ```
  è¿­ä»£æ³•ä¸­åºéå†ä»£ç å¦‚ä¸‹:
  ```java
  class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
		    List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                if (node.right!=null) st.push(node.right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                st.push(node);                          // æ·»åŠ ä¸­èŠ‚ç‚¹
                st.push(null); // ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚

                if (node.left!=null) st.push(node.left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.peek();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.add(node.val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
    }
}
  ```
  è¿­ä»£æ³•ååºéå†ä»£ç å¦‚ä¸‹:
  ```java
  class Solution {

   public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                st.push(node);                          // æ·»åŠ ä¸­èŠ‚ç‚¹
                st.push(null); // ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚
                if (node.right!=null) st.push(node.right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                if (node.left!=null) st.push(node.left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰         
                               
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.peek();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.add(node.val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
   }
}

  ```
Pythonï¼š
> è¿­ä»£æ³•å‰åºéå†

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st= []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #å³
                    st.append(node.right)
                if node.left: #å·¦
                    st.append(node.left)
                st.append(node) #ä¸­
                st.append(None)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```

> è¿­ä»£æ³•ä¸­åºéå†
```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                    st.append(node.right)
                
                st.append(node) #æ·»åŠ ä¸­èŠ‚ç‚¹
                st.append(None) #ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚
                
                if node.left: #æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
                    st.append(node.left)
            else: #åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                node = st.pop() #é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                result.append(node.val) #åŠ å…¥åˆ°ç»“æœé›†
        return result
```

> è¿­ä»£æ³•ååºéå†
```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #ä¸­
                st.append(None)
                
                if node.right: #å³
                    st.append(node.right)
                if node.left: #å·¦
                    st.append(node.left)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```

Goï¼š
> å‰åºéå†ç»Ÿä¸€è¿­ä»£æ³•

```GO
 /**
 type Element struct {
    // å…ƒç´ ä¿ç®¡çš„å€¼
    Value interface{}
    // å†…å«éšè—æˆ–éå¯¼å‡ºå­—æ®µ
}

func (l *List) Back() *Element 
å‰åºéå†ï¼šä¸­å·¦å³
å‹æ ˆé¡ºåºï¼šå³å·¦ä¸­
 **/
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New()//æ ˆ
    res:=[]int{}//ç»“æœé›†
    stack.PushBack(root)
    var node *TreeNode
    for stack.Len()>0{
        e := stack.Back()
        stack.Remove(e)//å¼¹å‡ºå…ƒç´ 
        if e.Value==nil{// å¦‚æœä¸ºç©ºï¼Œåˆ™è¡¨æ˜æ˜¯éœ€è¦å¤„ç†ä¸­é—´èŠ‚ç‚¹
            e=stack.Back()//å¼¹å‡ºå…ƒç´ ï¼ˆå³ä¸­é—´èŠ‚ç‚¹ï¼‰
            stack.Remove(e)//åˆ é™¤ä¸­é—´èŠ‚ç‚¹
            node=e.Value.(*TreeNode)
            res=append(res,node.Val)//å°†ä¸­é—´èŠ‚ç‚¹åŠ å…¥åˆ°ç»“æœé›†ä¸­
            continue//ç»§ç»­å¼¹å‡ºæ ˆä¸­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }
        node = e.Value.(*TreeNode)
        //å‹æ ˆé¡ºåºï¼šå³å·¦ä¸­
        if node.Right!=nil{
            stack.PushBack(node.Right)
        }
        if node.Left!=nil{
            stack.PushBack(node.Left)
        }
        stack.PushBack(node)//ä¸­é—´èŠ‚ç‚¹å‹æ ˆåå†å‹å…¥nilä½œä¸ºä¸­é—´èŠ‚ç‚¹çš„æ ‡å¿—ç¬¦
        stack.PushBack(nil)
    }
    return res

}
```

> ä¸­åºéå†ç»Ÿä¸€è¿­ä»£æ³•

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
 //ä¸­åºéå†ï¼šå·¦ä¸­å³
 //å‹æ ˆé¡ºåºï¼šå³ä¸­å·¦
func inorderTraversal(root *TreeNode) []int {
    if root==nil{
       return nil
    }
    stack:=list.New()//æ ˆ
    res:=[]int{}//ç»“æœé›†
    stack.PushBack(root)
    var node *TreeNode
    for stack.Len()>0{
        e := stack.Back()
        stack.Remove(e)
        if e.Value==nil{// å¦‚æœä¸ºç©ºï¼Œåˆ™è¡¨æ˜æ˜¯éœ€è¦å¤„ç†ä¸­é—´èŠ‚ç‚¹
            e=stack.Back()//å¼¹å‡ºå…ƒç´ ï¼ˆå³ä¸­é—´èŠ‚ç‚¹ï¼‰
            stack.Remove(e)//åˆ é™¤ä¸­é—´èŠ‚ç‚¹
            node=e.Value.(*TreeNode)
            res=append(res,node.Val)//å°†ä¸­é—´èŠ‚ç‚¹åŠ å…¥åˆ°ç»“æœé›†ä¸­
            continue//ç»§ç»­å¼¹å‡ºæ ˆä¸­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }
        node = e.Value.(*TreeNode)
        //å‹æ ˆé¡ºåºï¼šå³ä¸­å·¦
        if node.Right!=nil{
            stack.PushBack(node.Right)
        }
        stack.PushBack(node)//ä¸­é—´èŠ‚ç‚¹å‹æ ˆåå†å‹å…¥nilä½œä¸ºä¸­é—´èŠ‚ç‚¹çš„æ ‡å¿—ç¬¦
        stack.PushBack(nil)
        if node.Left!=nil{
            stack.PushBack(node.Left)
        }
    }
    return res
}
```

> ååºéå†ç»Ÿä¸€è¿­ä»£æ³•

```go
//åç»­éå†ï¼šå·¦å³ä¸­
//å‹æ ˆé¡ºåºï¼šä¸­å³å·¦
func postorderTraversal(root *TreeNode) []int {
	if root == nil {
		return nil
	}
	var stack = list.New()//æ ˆ
    res:=[]int{}//ç»“æœé›†
    stack.PushBack(root)
    var node *TreeNode
    for stack.Len()>0{
        e := stack.Back()
        stack.Remove(e)
        if e.Value==nil{// å¦‚æœä¸ºç©ºï¼Œåˆ™è¡¨æ˜æ˜¯éœ€è¦å¤„ç†ä¸­é—´èŠ‚ç‚¹
            e=stack.Back()//å¼¹å‡ºå…ƒç´ ï¼ˆå³ä¸­é—´èŠ‚ç‚¹ï¼‰
            stack.Remove(e)//åˆ é™¤ä¸­é—´èŠ‚ç‚¹
            node=e.Value.(*TreeNode)
            res=append(res,node.Val)//å°†ä¸­é—´èŠ‚ç‚¹åŠ å…¥åˆ°ç»“æœé›†ä¸­
            continue//ç»§ç»­å¼¹å‡ºæ ˆä¸­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }
        node = e.Value.(*TreeNode)
        //å‹æ ˆé¡ºåºï¼šä¸­å³å·¦
        stack.PushBack(node)//ä¸­é—´èŠ‚ç‚¹å‹æ ˆåå†å‹å…¥nilä½œä¸ºä¸­é—´èŠ‚ç‚¹çš„æ ‡å¿—ç¬¦
        stack.PushBack(nil)
        if node.Right!=nil{
            stack.PushBack(node.Right)
        }
        if node.Left!=nil{
            stack.PushBack(node.Left)
        }
    }
    return res
}
```

javaScript:

> å‰åºéå†ç»Ÿä¸€è¿­ä»£æ³•

```js

// å‰åºéå†ï¼šä¸­å·¦å³
// å‹æ ˆé¡ºåºï¼šå³å·¦ä¸­

var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // å³
        if (node.left) stack.push(node.left); // å·¦
        stack.push(node); // ä¸­
        stack.push(null);
    };
    return res;
};

```

> ä¸­åºéå†ç»Ÿä¸€è¿­ä»£æ³•

```js

//  ä¸­åºéå†ï¼šå·¦ä¸­å³
//  å‹æ ˆé¡ºåºï¼šå³ä¸­å·¦
 
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // å³
        stack.push(node); // ä¸­
        stack.push(null);
        if (node.left) stack.push(node.left); // å·¦
    };
    return res;
};

```

> ååºéå†ç»Ÿä¸€è¿­ä»£æ³•

```js

// åç»­éå†ï¼šå·¦å³ä¸­
// å‹æ ˆé¡ºåºï¼šä¸­å³å·¦
 
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // ä¸­
        stack.push(null);
        if (node.right) stack.push(node.right); // å³
        if (node.left) stack.push(node.left); // å·¦
    };
    return res;
};

```



# äºŒå‰æ ‘åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ äºŒå‰æ ‘çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚ä»¥ä¸‹æ¯é“é¢˜ç›®åœ¨åŠ›æ‰£é¢˜è§£åŒºéƒ½æœ‰ã€Œä»£ç éšæƒ³å½•ã€çš„é¢˜è§£ã€‚

![image.png](https://pic.leetcode-cn.com/1625557068-rTzCSW-image.png){:width="450px"}{:align="center"}

------------

**å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œç‚¹å‡»[æˆ‘çš„å¤´åƒ](https://programmercarl.com)**ï¼ŒæŸ¥çœ‹åŠ›æ‰£è¯¦ç»†åˆ·é¢˜æ”»ç•¥ï¼Œä½ ä¼šå‘ç°ç›¸è§æ¨æ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

