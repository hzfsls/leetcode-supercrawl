## [460.LFU ç¼“å­˜ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/lfu-cache/solutions/100000/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji)

ä½œè€…ï¼š[sweetiee](https://leetcode.cn/u/sweetiee)
ğŸ™‹**æˆ‘ä»¥å‰çš„é¢˜è§£ç«Ÿç„¶è¢«æ¯æ—¥ä¸€é¢˜ç¿»ç‰Œäº†ï¼Œä»Šå¤©ç»ˆäºä¸ç”¨æ–°æ›´äº†å‘¢**

**ä»¥ä¸‹è§£æ³•ä¸­ï¼Œæ–¹æ³• 3 ç›¸å¯¹äºå…¶ä»–äººå¾ˆå¤šå‡ ç™¾æ¯«ç§’çš„ $O(1)$ å®ç°æ¥è¯´ï¼Œæ˜¯ç›®å‰æœ€ä¼˜çš„ $O(1)$ å®ç°å“¦ï¼Œåªéœ€è¦ 13 æ¯«ç§’ï¼~**
**æƒ³çœ‹æ›´å¤šå¹²è´§é¢˜è§£ï¼Œè¯·æˆ³ [æˆ‘çš„ä¸»é¡µ](https://leetcode-cn.com/u/sweetiee/)ï¼**

----


 [TOC]

### ä¸€ã€$O(1)$ è§£æ³•

ä¸‹é¢è¦è¯´çš„ $O(1)$ çš„ 3 ç§ Java å†™æ³•å…¶å®æ˜¯ 1 ç§è§£æ³•ï¼Œå› ä¸ºå…·ä½“å®ç°ç»†èŠ‚ä¸­ä½¿ç”¨çš„æ•°æ®ç»“æ„ä¸åŒï¼Œå¯¼è‡´æ€§èƒ½æœ‰æ‰€å·®å¼‚ã€‚ä¸ºæ–¹ä¾¿ç†è§£ï¼Œä¸‹é¢ 3 ä¸ªå®ç°ï¼Œ**æ€§èƒ½ä»ç•¥æŒ«é€æ­¥ä¼˜åŒ–**ï¼š

1. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; `min` æ˜¯æœ€å°è®¿é—®é¢‘æ¬¡; `HashMap<Integer, LinkedHashSet<Node>> freqMap` å­˜æ¯ä¸ªè®¿é—®é¢‘æ¬¡å¯¹åº”çš„ Node çš„åŒå‘é“¾è¡¨ï¼ˆå†™æ³• 1 ä¸ºäº†æ–¹ä¾¿ï¼Œç›´æ¥ç”¨äº† JDK ç°æœ‰çš„ LinkedHashSetï¼Œå…¶å®ç°äº† 1 æ¡åŒå‘é“¾è¡¨è´¯ç©¿å“ˆå¸Œè¡¨ä¸­çš„æ‰€æœ‰ Entryï¼Œæ”¯æŒä»¥æ’å…¥çš„å…ˆåé¡ºåºå¯¹åŸæœ¬æ— åºçš„ HashSet è¿›è¡Œè¿­ä»£ï¼‰

2. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; `min` æ˜¯æœ€å°è®¿é—®é¢‘æ¬¡; `HashMap<Integer, DoublyLinkedList>freqMap` å­˜æ¯ä¸ªè®¿é—®é¢‘æ¬¡å¯¹åº”çš„ Node çš„åŒå‘é“¾è¡¨ï¼ˆå†™æ³• 2 ä¸å†™æ³• 1 ä¸€æ ·ï¼Œåªä¸è¿‡å°† JDK è‡ªå¸¦çš„ LinkedHashSet åŒå‘é“¾è¡¨å®ç°æ”¹æˆäº†è‡ªå®šä¹‰çš„åŒå‘é“¾è¡¨ DoublyLinkedListï¼Œå‡å°‘äº†ä¸€äº›å“ˆå¸Œç›¸å…³çš„è€—æ—¶ï¼‰

3. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; å°†å†™æ³• 1 å†™æ³• 2 ä¸­çš„ freqMap ä¸å†ç”¨ HashMap æ¥è¡¨ç¤ºï¼Œè€Œæ˜¯ç›´æ¥ç”¨åŒå‘é“¾è¡¨ `DoublyLinkedList firstLinkedList; DoublyLinkedList lastLinkedList`ï¼Œçœå»äº†ä¸€äº›å“ˆå¸Œç›¸å…³çš„è€—æ—¶ï¼Œä¹Ÿä¸éœ€è¦ç”¨ min æ¥å­˜å‚¨æœ€å°é¢‘æ¬¡äº†ï¼ŒlastLinkedList.pre è¿™æ¡ DoublyLinkedList å³ä¸ºæœ€å°é¢‘æ¬¡å¯¹åº”çš„ Node åŒå‘é“¾è¡¨ï¼ŒlastLinkedList.pre.tail.pre è¿™ä¸ª Node å³ä¸ºæœ€å°é¢‘æ¬¡çš„åŒå‘é“¾è¡¨ä¸­çš„æ‰€æœ‰ Node ä¸­æœ€å…ˆè®¿é—®çš„ Nodeï¼Œå³å®¹é‡æ»¡äº†åè¦åˆ é™¤çš„ Nodeã€‚


**ä¸‹é¢è´´è¿™ä»¨å®ç°ï¼Œä¸å¤šå“”å“”äº†ç›´æ¥åœ¨ä»£ç ä¸­æ³¨é‡Šå•¦**
**æœ€ä¼˜è§£æ˜¯ç¬¬ä¸‰ç§ï¼Œè¯¦å°½æ³¨é‡Šäº†ã€‚ å…¶ä»–çš„å®ç°å®åœ¨æ‡’å¾—æ³¨é‡Šäº†å“ğŸ¥ºï¼Œæ²¡æ³•æŠ˜å å¥½å‚»xï¼Œç›´æ¥è·³å»ç¬¬ä¸‰ç§å­**


#### O(1) è§£æ³• â€”â€” åŒå‘é“¾è¡¨ç›´æ¥ä½¿ç”¨LinkedHashSet
``` Java
class LFUCache {
    Map<Integer, Node> cache;  // å­˜å‚¨ç¼“å­˜çš„å†…å®¹
    Map<Integer, LinkedHashSet<Node>> freqMap; // å­˜å‚¨æ¯ä¸ªé¢‘æ¬¡å¯¹åº”çš„åŒå‘é“¾è¡¨
    int size;
    int capacity;
    int min; // å­˜å‚¨å½“å‰æœ€å°é¢‘æ¬¡

    public LFUCache(int capacity) {
        cache = new HashMap<> (capacity);
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            freqInc(node);
        } else {
            if (size == capacity) {
                Node deadNode = removeNode();
                cache.remove(deadNode.key);
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            size++;     
        }
    }

    void freqInc(Node node) {
        // ä»åŸfreqå¯¹åº”çš„é“¾è¡¨é‡Œç§»é™¤, å¹¶æ›´æ–°min
        int freq = node.freq;
        LinkedHashSet<Node> set = freqMap.get(freq);
        set.remove(node);
        if (freq == min && set.size() == 0) { 
            min = freq + 1;
        }
        // åŠ å…¥æ–°freqå¯¹åº”çš„é“¾è¡¨
        node.freq++;
        LinkedHashSet<Node> newSet = freqMap.get(freq + 1);
        if (newSet == null) {
            newSet = new LinkedHashSet<>();
            freqMap.put(freq + 1, newSet);
        }
        newSet.add(node);
    }

    void addNode(Node node) {
        LinkedHashSet<Node> set = freqMap.get(1);
        if (set == null) {
            set = new LinkedHashSet<>();
            freqMap.put(1, set);
        } 
        set.add(node); 
        min = 1;
    }

    Node removeNode() {
        LinkedHashSet<Node> set = freqMap.get(min);
        Node deadNode = set.iterator().next();
        set.remove(deadNode);
        return deadNode;
    }
}

class Node {
    int key;
    int value;
    int freq = 1;

    public Node() {}
    
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

#### O(1) è§£æ³• â€”â€” è‡ªå®šä¹‰åŒå‘é“¾è¡¨
``` Java
class LFUCache {
    Map<Integer, Node> cache; // å­˜å‚¨ç¼“å­˜çš„å†…å®¹
    Map<Integer, DoublyLinkedList> freqMap; // å­˜å‚¨æ¯ä¸ªé¢‘æ¬¡å¯¹åº”çš„åŒå‘é“¾è¡¨
    int size;
    int capacity;
    int min; // å­˜å‚¨å½“å‰æœ€å°é¢‘æ¬¡

    public LFUCache(int capacity) {
        cache = new HashMap<> (capacity);
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            freqInc(node);
        } else {
            if (size == capacity) {
                DoublyLinkedList minFreqLinkedList = freqMap.get(min);
                cache.remove(minFreqLinkedList.tail.pre.key);
                minFreqLinkedList.removeNode(minFreqLinkedList.tail.pre); // è¿™é‡Œä¸éœ€è¦ç»´æŠ¤min, å› ä¸ºä¸‹é¢addäº†newNodeåminè‚¯å®šæ˜¯1.
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            DoublyLinkedList linkedList = freqMap.get(1);
            if (linkedList == null) {
                linkedList = new DoublyLinkedList();
                freqMap.put(1, linkedList);
            }
            linkedList.addNode(newNode);
            size++;  
            min = 1;   
        }
    }

    void freqInc(Node node) {
        // ä»åŸfreqå¯¹åº”çš„é“¾è¡¨é‡Œç§»é™¤, å¹¶æ›´æ–°min
        int freq = node.freq;
        DoublyLinkedList linkedList = freqMap.get(freq);
        linkedList.removeNode(node);
        if (freq == min && linkedList.head.post == linkedList.tail) { 
            min = freq + 1;
        }
        // åŠ å…¥æ–°freqå¯¹åº”çš„é“¾è¡¨
        node.freq++;
        linkedList = freqMap.get(freq + 1);
        if (linkedList == null) {
            linkedList = new DoublyLinkedList();
            freqMap.put(freq + 1, linkedList);
        }
        linkedList.addNode(node);
    }
}

class Node {
    int key;
    int value;
    int freq = 1;
    Node pre;
    Node post;

    public Node() {}
    
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}

class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node();
        tail = new Node();
        head.post = tail;
        tail.pre = head;
    }

    void removeNode(Node node) {
        node.pre.post = node.post;
        node.post.pre = node.pre;
    }

    void addNode(Node node) {
        node.post = head.post;
        head.post.pre = node;
        head.post = node;
        node.pre = head;
    }
}
```

#### O(1) è§£æ³• â€”â€” å­˜å‚¨é¢‘æ¬¡çš„HashMapæ”¹ä¸ºç›´æ¥ç”¨åŒå‘é“¾è¡¨ï¼ˆæœ€ä¼˜å®ç° 13ms åŒ100%ï¼‰

``` Java

class LFUCache {

  Map<Integer, Node> cache;  // å­˜å‚¨ç¼“å­˜çš„å†…å®¹ï¼ŒNodeä¸­é™¤äº†valueå€¼å¤–ï¼Œè¿˜æœ‰keyã€freqã€æ‰€åœ¨doublyLinkedListã€æ‰€åœ¨doublyLinkedListä¸­çš„postNodeã€æ‰€åœ¨doublyLinkedListä¸­çš„preNodeï¼Œå…·ä½“å®šä¹‰åœ¨ä¸‹æ–¹ã€‚

  DoublyLinkedList firstLinkedList; // firstLinkedList.post æ˜¯é¢‘æ¬¡æœ€å¤§çš„åŒå‘é“¾è¡¨

  DoublyLinkedList lastLinkedList;  // lastLinkedList.pre æ˜¯é¢‘æ¬¡æœ€å°çš„åŒå‘é“¾è¡¨ï¼Œæ»¡äº†ä¹‹ååˆ é™¤ lastLinkedList.pre.tail.pre è¿™ä¸ªNodeå³ä¸ºé¢‘æ¬¡æœ€å°ä¸”è®¿é—®æœ€æ—©çš„Node

  int size;

  int capacity;



  public LFUCache(int capacity) {

â€‹    cache = new HashMap<> (capacity);

â€‹    firstLinkedList = new DoublyLinkedList();

â€‹    lastLinkedList = new DoublyLinkedList();

â€‹    firstLinkedList.post = lastLinkedList;

â€‹    lastLinkedList.pre = firstLinkedList;

â€‹    this.capacity = capacity;

  }

  

  public int get(int key) {

â€‹    Node node = cache.get(key);

â€‹    if (node == null) {

â€‹      return -1;

â€‹    }

    // è¯¥keyè®¿é—®é¢‘æ¬¡+1

â€‹    freqInc(node);

â€‹    return node.value;

  }

  

  public void put(int key, int value) {

â€‹    if (capacity == 0) {

â€‹      return;

â€‹    }

â€‹    Node node = cache.get(key);

    // è‹¥keyå­˜åœ¨ï¼Œåˆ™æ›´æ–°valueï¼Œè®¿é—®é¢‘æ¬¡+1

â€‹    if (node != null) {

â€‹      node.value = value;

â€‹      freqInc(node);

â€‹    } else {

      // è‹¥keyä¸å­˜åœ¨

â€‹      if (size == capacity) {

â€‹        // å¦‚æœç¼“å­˜æ»¡äº†ï¼Œåˆ é™¤lastLinkedList.preè¿™ä¸ªé“¾è¡¨ï¼ˆå³è¡¨ç¤ºæœ€å°é¢‘æ¬¡çš„é“¾è¡¨ï¼‰ä¸­çš„tail.preè¿™ä¸ªNodeï¼ˆå³æœ€å°é¢‘æ¬¡é“¾è¡¨ä¸­æœ€å…ˆè®¿é—®çš„Nodeï¼‰ï¼Œå¦‚æœè¯¥é“¾è¡¨ä¸­çš„å…ƒç´ åˆ ç©ºäº†ï¼Œåˆ™åˆ æ‰è¯¥é“¾è¡¨ã€‚

â€‹        cache.remove(lastLinkedList.pre.tail.pre.key);

â€‹        lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);

â€‹        size--;

â€‹        if (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) {

â€‹          removeDoublyLinkedList(lastLinkedList.pre);

â€‹        } 

â€‹      }

      // cacheä¸­putæ–°Key-Nodeå¯¹å„¿ï¼Œå¹¶å°†æ–°nodeåŠ å…¥è¡¨ç¤ºfreqä¸º1çš„DoublyLinkedListä¸­ï¼Œè‹¥ä¸å­˜åœ¨freqä¸º1çš„DoublyLinkedListåˆ™æ–°å»ºã€‚

â€‹      Node newNode = new Node(key, value);

â€‹      cache.put(key, newNode);

â€‹      if (lastLinkedList.pre.freq != 1) {

â€‹        DoublyLinkedList newDoublyLinedList = new DoublyLinkedList(1);

â€‹        addDoublyLinkedList(newDoublyLinedList, lastLinkedList.pre);

â€‹        newDoublyLinedList.addNode(newNode);

â€‹      } else {

â€‹        lastLinkedList.pre.addNode(newNode);

â€‹      }

â€‹      size++;

â€‹    }

  }


  /**
   * nodeçš„è®¿é—®é¢‘æ¬¡ + 1
   */
  void freqInc(Node node) {

â€‹    // å°†nodeä»åŸfreqå¯¹åº”çš„åŒå‘é“¾è¡¨é‡Œç§»é™¤, å¦‚æœé“¾è¡¨ç©ºäº†åˆ™åˆ é™¤é“¾è¡¨ã€‚

â€‹    DoublyLinkedList linkedList = node.doublyLinkedList;

â€‹    DoublyLinkedList preLinkedList = linkedList.pre;

â€‹    linkedList.removeNode(node);

â€‹    if (linkedList.head.post == linkedList.tail) { 

â€‹      removeDoublyLinkedList(linkedList);

â€‹    }


â€‹    // å°†nodeåŠ å…¥æ–°freqå¯¹åº”çš„åŒå‘é“¾è¡¨ï¼Œè‹¥è¯¥é“¾è¡¨ä¸å­˜åœ¨ï¼Œåˆ™å…ˆåˆ›å»ºè¯¥é“¾è¡¨ã€‚

â€‹    node.freq++;

â€‹    if (preLinkedList.freq != node.freq) {

â€‹      DoublyLinkedList newDoublyLinedList = new DoublyLinkedList(node.freq);

â€‹      addDoublyLinkedList(newDoublyLinedList, preLinkedList);

â€‹      newDoublyLinedList.addNode(node);

â€‹    } else {

â€‹      preLinkedList.addNode(node);

â€‹    }

  }


  /**
   * å¢åŠ ä»£è¡¨æŸ1é¢‘æ¬¡çš„åŒå‘é“¾è¡¨
   */
  void addDoublyLinkedList(DoublyLinkedList newDoublyLinedList, DoublyLinkedList preLinkedList) {

â€‹    newDoublyLinedList.post = preLinkedList.post;

â€‹    newDoublyLinedList.post.pre = newDoublyLinedList;

â€‹    newDoublyLinedList.pre = preLinkedList;

â€‹    preLinkedList.post = newDoublyLinedList; 

  }


  /**
   * åˆ é™¤ä»£è¡¨æŸ1é¢‘æ¬¡çš„åŒå‘é“¾è¡¨
   */
  void removeDoublyLinkedList(DoublyLinkedList doublyLinkedList) {

â€‹    doublyLinkedList.pre.post = doublyLinkedList.post;

â€‹    doublyLinkedList.post.pre = doublyLinkedList.pre;

  }

}



class Node {

  int key;

  int value;

  int freq = 1;

  Node pre; // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨çš„å‰ç»§Node 

  Node post; // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨çš„åç»§Node

  DoublyLinkedList doublyLinkedList;  // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨



  public Node() {}

  

  public Node(int key, int value) {

â€‹    this.key = key;

â€‹    this.value = value;

  }

}



class DoublyLinkedList {

  int freq; // è¯¥åŒå‘é“¾è¡¨è¡¨ç¤ºçš„é¢‘æ¬¡

  DoublyLinkedList pre;  // è¯¥åŒå‘é“¾è¡¨çš„å‰ç»§é“¾è¡¨ï¼ˆpre.freq < this.freqï¼‰

  DoublyLinkedList post; // è¯¥åŒå‘é“¾è¡¨çš„åç»§é“¾è¡¨ (post.freq > this.freq)

  Node head; // è¯¥åŒå‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹ä»å¤´éƒ¨åŠ å…¥ï¼Œè¡¨ç¤ºæœ€è¿‘è®¿é—®

  Node tail; // è¯¥åŒå‘é“¾è¡¨çš„å°¾èŠ‚ç‚¹ï¼Œåˆ é™¤èŠ‚ç‚¹ä»å°¾éƒ¨åˆ é™¤ï¼Œè¡¨ç¤ºæœ€ä¹…è®¿é—®



  public DoublyLinkedList() {

â€‹    head = new Node();

â€‹    tail = new Node();

â€‹    head.post = tail;

â€‹    tail.pre = head;

  }



  public DoublyLinkedList(int freq) {

â€‹    head = new Node();

â€‹    tail = new Node();

â€‹    head.post = tail;

â€‹    tail.pre = head;

â€‹    this.freq = freq;

  }



  void removeNode(Node node) {

â€‹    node.pre.post = node.post;

â€‹    node.post.pre = node.pre;

  }



  void addNode(Node node) {

â€‹    node.post = head.post;

â€‹    head.post.pre = node;

â€‹    head.post = node;

â€‹    node.pre = head;

â€‹    node.doublyLinkedList = this;

  }



}

```



---

## äºŒã€$O(logN)$ è§£æ³•

#### O(logN) è§£æ³• â€”â€” ä½¿ç”¨å°æ ¹å †æ‰¾åˆ° `freq` æœ€å°ï¼Œå› ä¸º Java ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †, å®ç°æœ€ç®€å•

æ¯æ¬¡å°†è®¿é—®é¢‘æ¬¡ `freq` æœ€å°çš„ä¸”æœ€å…ˆè®¿é—®çš„ä¸Šæµ®åˆ°å †é¡¶ï¼Œä¸‹é¢ç”¨å…¨å±€è‡ªå¢ `idx` è¡¨ç¤ºè®¿é—®çš„å…ˆåï¼Œæˆ–è€…å¯ä»¥ç›´æ¥æ”¹æˆ `idx = System.nanoTime()` ç”¨ä»¥æ¯”è¾ƒè®¿é—®æ—¶é—´çš„å…ˆåã€‚

``` Java
class LFUCache {

    Map<Integer, Node> cache;
    Queue<Node> queue;
    int capacity;
    int size;
    int idx = 0;

    public LFUCache(int capacity) {
        cache = new HashMap<>(capacity);
        if (capacity > 0) {
            queue = new PriorityQueue<>(capacity);
        }
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        node.freq++;
        node.idx = idx++;
        queue.remove(node);
        queue.offer(node);
        return node.value;

    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            node.freq++;
            node.idx = idx++;
            queue.remove(node);
            queue.offer(node);
        } else {
            if (size == capacity) {
                cache.remove(queue.peek().key);
                queue.poll();
                size--;
            } 
            Node newNode = new Node(key, value, idx++);
            cache.put(key, newNode);
            queue.offer(newNode);
            size++;
        }
    }
}

class Node implements Comparable<Node> {
    int key;
    int value;
    int freq;
    int idx;

    public Node() {}

    public Node(int key, int value, int idx) {
        this.key = key;
        this.value = value;
        freq = 1;
        this.idx = idx;
    }

    public int compareTo(Node node) {
		int diff = freq - node.freq;
        return diff != 0? diff: idx - node.idx;
    }
}
```

## ä¸‰ã€O(N) è§£æ³•

#### æœ€å‚»fufuã® O(N) â€”â€” åªç”¨1æ¡åŒå‘é“¾è¡¨

ä½¿ `freq` å°çš„ `Node` åœ¨é“¾è¡¨çš„å·¦è¾¹ï¼Œ`freq` å¤§çš„ `Node` åœ¨é“¾è¡¨çš„å³è¾¹ï¼Œ`freq` ç›¸ç­‰çš„è¯æœ€ä¹…ä½¿ç”¨çš„ `Node` åœ¨å·¦è¾¹ã€æœ€è¿‘ä½¿ç”¨çš„ `Node` åœ¨å³è¾¹ï¼Œå› æ­¤æ»¡äº†ä¹‹ååˆ é™¤ `head.post`ï¼Œè¯¥ `Node` å³ `freq` æœ€å°ä¸”æœ€ä¹…è®¿é—®çš„ã€‚
æ¯æ¬¡ `node` çš„ `freq++` åï¼Œä»å½“å‰ä½ç½®å‘åéå†é“¾è¡¨ï¼Œç›´åˆ° `nextNode.freq > node.freq || nextNode == tail`ï¼Œåœ¨ `nextNode` ä¹‹å‰æ’å…¥è¯¥ `node`ã€‚

``` Java
class LFUCache {

    HashMap<Integer, Node> cache;
    Node head;
    Node tail;
    int capacity;
    int size;

    public LFUCache(int capacity) {
        cache = new HashMap<Integer, Node>(capacity);
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.post = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        node.freq++;
        moveToNewPosition(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            node.freq++;
            moveToNewPosition(node);
        } else {
            if (size == capacity) {
                cache.remove(head.post.key);
                removeNode(head.post);
                size--;
            }
            Node newNode = new Node(key, value);
            addNode(newNode);
            cache.put(key, newNode);
            size++;
        }
    }

    private void moveToNewPosition(Node node) {
        Node nextNode = node.post;
        removeNode(node);
        while (nextNode.freq <= node.freq && nextNode != tail) {
            nextNode = nextNode.post;
        }
        nextNode.pre.post = node;
        node.pre = nextNode.pre;
        node.post = nextNode;
        nextNode.pre = node;
    }

    private void addNode(Node node) {
        node.post = head.post;
        node.pre = head;
        head.post.pre = node;
        head.post = node;
        moveToNewPosition(node);
    }

    private void removeNode(Node node) {
        node.pre.post = node.post;
        node.post.pre = node.pre;
    }
}

class Node {
    int key;
    int value;
    int freq = 1;
    Node pre;
    Node post;

    public Node() {}
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```


---

å—¯ï¼Œå¾ˆå…¨/::)