## [32.最长有效括号 中文热门题解1](https://leetcode.cn/problems/longest-valid-parentheses/solutions/100000/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042)

作者：[zhanganan0425](https://leetcode.cn/u/zhanganan0425)

#### 解题思路：
结合题目，有 **最长** 这个字眼，可以考虑尝试使用 **动态规划** 进行分析。这是一个 **最值型** 动态规划的题目。

动态规划题目分析的 4 个步骤：

- 确定状态
  - 研究最优策略的最后一步
  - 化为子问题
- 转移方程
  - 根据子问题定义得到
- 初始条件和边界情况
- 计算顺序

首先，我们定义一个 $dp$ 数组，其中第 $i$ 个元素表示以下标为 $i$ 的字符结尾的最长有效子字符串的长度。

#### 确定状态：
#### 最后一步：

对于最优的策略，一定有最后一个元素 $s[i]$.

所以，我们先看第 $i$ 个位置，这个位置的元素 $s[i]$可能有如下两种情况：

- $s[i] == '('$ :

    这时，$s[i]$ 无法和其之前的元素组成有效的括号对，所以，$dp[i] = 0$

- $s[i] == ')'$ :
    
    这时，需要看其前面对元素来判断是否有有效括号对。

    - 情况1:

        $s[i - 1] == '('$ 

        即 $s[i]$ 和 $s[i - 1]$ 组成一对有效括号，有效括号长度新增长度2，$i$位置对最长有效括号长度为  **其之前2个位置的最长括号长度加上当前位置新增的2**，我们无需知道$i-2$位置对字符是否可以组成有效括号对。

        那么有：

        $dp[i] = dp[i - 2] + 2$

        ![截屏2020-04-17下午4.30.46.png](https://pic.leetcode-cn.com/6f176074b305e1571da1ab74839d22436be5fba22b592d618d531ac79dae8a7a-%E6%88%AA%E5%B1%8F2020-04-17%E4%B8%8B%E5%8D%884.30.46.png)

    - 情况2:

        $s[i - 1] == ')'$ 

        这种情况下，如果前面有和$s[i]$组成有效括号对的字符，即形如 $( (....) )$，这样的话，就要求$s[i - 1]$位置必然是有效的括号对，否则$s[i]$无法和前面对字符组成有效括号对。

        这时，我们只需要找到和$s[i]$配对对位置，并判断其是否是 $($ 即可。和其配对对位置为：$i - dp[i - 1] - 1$。

        如果：$s[i - dp[i - 1] - 1] == '('$ :

        有效括号长度新增长度 2，$i$ 位置对最长有效括号长度为 **i-1位置的最长括号长度加上当前位置新增的 2**，那么有：

        $dp[i] = dp[i - 1] + 2$

        值得注意的是，$i - dp[i - 1] - 1$  和  $i$  组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 $(...)$ 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：

        $dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2$

> 注： 这个在分析时是很容易遗漏的，分析要更细致。我在第一次分析是就遗漏了，提交后，有用例 `)()(()))`不过，分析后发现是少了这一段。

        
![截屏2020-04-17下午4.26.34.png](https://pic.leetcode-cn.com/6e07ddaac3b703cba03a9ea8438caf1407c4834b7b1e4c8ec648c34f2833a3b9-%E6%88%AA%E5%B1%8F2020-04-17%E4%B8%8B%E5%8D%884.26.34.png)

#### 子问题：

根据上面的分析，我们得到了如下两个计算公式：

$dp[i] = dp[i - 2] + 2$

$dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2$

那么，求$dp[i]$就变成了求$dp[i - 1]$、 $dp[i - 2]$、$dp[i - dp[i - 1] - 2]$的子问题。

这样状态也明确了：

**设 $dp$ 数组，其中第 $i$ 个元素表示以下标为 $i$ 的字符结尾的最长有效子字符串的长度。**

#### 转移方程：

子问题明确后，转移方程直接由子问题得到：


```C++ []
if s[i] == '(' :
    dp[i] = 0
if s[i] == ')' :
    if s[i - 1] == '(' :
        dp[i] = dp[i - 2] + 2 #要保证i - 2 >= 0

    if s[i - 1] == ')' and s[i - dp[i - 1] - 1] == '(' :
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 #要保证i - dp[i - 1] - 2 >= 0
```

#### 初始条件和边界情况：

初始条件： $dp[i] = 0$

边界情况：需要保证计算过程中：$i - 2 >= 0$ 和 $i - dp[i - 1] - 2 >= 0$

#### 计算顺序：

无论第一个字符是什么，都有：$dp[0] = 0$

然后依次计算：$dp[1], dp[2], ..., dp[n - 1]$

结果是： $max(dp[i])$

#### 复杂度计算：

时间复杂度： 遍历了一遍字符串，所以时间复杂度是：$O(N)$

空间复杂度：需要和字符串长度相同的数组保存每个位置的最长有效括号长度，所以空间复杂度是：$O(N)$


```C++ []
class Solution {
public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);

        int maxVal = 0;
        for(int i = 1; i < size; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2 >= 0) {
                        dp[i] = dp[i] + dp[i - 2];
                    }
                } else if (dp[i - 1] > 0) {
                    if ((i - dp[i - 1] - 1) >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if ((i - dp[i - 1] - 2) >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxVal = max(maxVal, dp[i]);
        }
        return maxVal;
    }
};
```


#### 总结

拿到这种题目后，不要慌，根据题目中是否有：**计数、最大/最小/最长、是否存在** 等字眼，先判断是否可以使用动态规划解决，如果可以，然后根据上面的步骤，一步一步进行分析，尤其是 **最后一步** 这一步分析，是能否转化为子问题的关键。转化为子问题后，就能轻易得到转移方程，后面的操作就简单了。

有些题目，动态规划不一定是最高效的解法，但是根据这个套路进行分析，一定是最快的解法。先写出来之后再考虑是否可以优化，或者其他更优的解法。