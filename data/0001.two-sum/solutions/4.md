## [1.ä¸¤æ•°ä¹‹å’Œ ä¸­æ–‡çƒ­é—¨é¢˜è§£4](https://leetcode.cn/problems/two-sum/solutions/100000/tu-jie-guan-fang-tui-jian-ti-jie-liang-s-02xs)

ä½œè€…ï¼š[demigodliu](https://leetcode.cn/u/demigodliu)
![å›¾è§£æ¯æ—¥ä¸€ç»ƒ.jpg](https://pic.leetcode-cn.com/1615817903-fzmpwZ-%E5%9B%BE%E8%A7%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83.jpg)

---

### ğŸ§  è§£é¢˜æ€è·¯

æ ¹æ®é¢˜æ„ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨æš´ç ´ï¼Œä¼šå¯¼è‡´æ—¶é—´å¤æ‚åº¦ä¸º $n^2$ï¼Œè¿™æ ·çš„ä»£ä»·æ— ç–‘æ˜¯å¾ˆå¤§çš„ã€‚

æ‰€ä»¥æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°ç”¨å“ˆå¸Œè¡¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

æˆ‘ä»¬éå†åˆ°æ•°å­— $a$ æ—¶ï¼Œç”¨ $target$ å‡å» $a$ï¼Œå°±ä¼šå¾—åˆ° $b$ï¼Œè‹¥ $b$ å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥è¿”å›ç»“æœäº†ã€‚è‹¥ $b$ ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦å°† $a$ å­˜å…¥å“ˆå¸Œè¡¨ï¼Œå¥½è®©åç»­éå†çš„æ•°å­—ä½¿ç”¨ã€‚

---

### ğŸ¨ å›¾è§£æ¼”ç¤º

<![1.jpg](https://pic.leetcode-cn.com/1615819146-WssWKk-1.jpg),![2.jpg](https://pic.leetcode-cn.com/1615819153-zIOjvl-2.jpg),![3.jpg](https://pic.leetcode-cn.com/1615819156-nXEKNY-3.jpg),![4.jpg](https://pic.leetcode-cn.com/1615819160-wppIqY-4.jpg)>

---

### ğŸ­ ç¤ºä¾‹ä»£ç 

```Javascript []
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        if(map.has(target - nums[i])){
            return [map.get(target - nums[i]), i];
        }else{
            map.set(nums[i], i);
        }
    }
    return [];
};
```
```Java []
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```
```C++ []
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```
```C []
struct hashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

struct hashTable* hashtable;

struct hashTable* find(int ikey) {
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

void insert(int ikey, int ival) {
    struct hashTable* it = find(ikey);
    if (it == NULL) {
        struct hashTable* tmp = malloc(sizeof(struct hashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    } else {
        it->val = ival;
    }
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) {
        struct hashTable* it = find(target - nums[i]);
        if (it != NULL) {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0;
    return NULL;
}
```
```Python3 []
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []
```
```Golang []
func twoSum(nums []int, target int) []int {
    hashTable := map[int]int{}
    for i, x := range nums {
        if p, ok := hashTable[target-x]; ok {
            return []int{p, i}
        }
        hashTable[x] = i
    }
    return nil
}
```

---

### è½¬èº«æŒ¥æ‰‹

å˜¿ï¼Œå°‘å¹´ï¼Œåšå›¾ä¸æ˜“ï¼Œç•™ä¸‹ä¸ªèµæˆ–è¯„è®ºå†èµ°å§ï¼è°¢å•¦~ ğŸ’

å·®ç‚¹å¿˜äº†ï¼Œç¥ä½ ç‰›å¹´å¤§å‰ ğŸ® ï¼ŒAC å’Œ Offer ğŸ“‘ å¤šå¤šç›Šå–„~

â›²â›²â›² æœŸå¾…ä¸‹æ¬¡å†è§~ 