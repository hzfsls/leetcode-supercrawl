## [1253.é‡æž„ 2 è¡ŒäºŒè¿›åˆ¶çŸ©é˜µ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/solutions/100000/python3javacgotypescript-yi-ti-yi-jie-ta-ecug)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)



**æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ**

æˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªç­”æ¡ˆæ•°ç»„ $ans$ï¼Œå…¶ä¸­ $ans[0]$ å’Œ $ans[1]$ åˆ†åˆ«è¡¨ç¤ºçŸ©é˜µçš„ç¬¬ä¸€è¡Œå’Œç¬¬äºŒè¡Œã€‚

æŽ¥ä¸‹æ¥ï¼Œä»Žå·¦åˆ°å³éåŽ†æ•°ç»„ $colsum$ï¼Œå¯¹äºŽå½“å‰éåŽ†åˆ°çš„å…ƒç´  $colsum[j]$ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š

-   å¦‚æžœ $colsum[j] = 2$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°† $ans[0][j]$ å’Œ $ans[1][j]$ éƒ½ç½®ä¸º $1$ã€‚æ­¤æ—¶ $upper$ å’Œ $lower$ éƒ½å‡åŽ» $1$ã€‚
-   å¦‚æžœ $colsum[j] = 1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°† $ans[0][j]$ æˆ– $ans[1][j]$ ç½®ä¸º $1$ã€‚å¦‚æžœ $upper \gt lower$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼˜å…ˆå°† $ans[0][j]$ ç½®ä¸º $1$ï¼Œå¦åˆ™æˆ‘ä»¬ä¼˜å…ˆå°† $ans[1][j]$ ç½®ä¸º $1$ã€‚æ­¤æ—¶ $upper$ æˆ– $lower$ å‡åŽ» $1$ã€‚
-   å¦‚æžœ $colsum[j] = 0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°† $ans[0][j]$ å’Œ $ans[1][j]$ éƒ½ç½®ä¸º $0$ã€‚
-   å¦‚æžœ $upper \lt 0$ æˆ– $lower \lt 0$ï¼Œé‚£ä¹ˆè¯´æ˜Žæ— æ³•æž„é€ å‡ºæ»¡è¶³è¦æ±‚çš„çŸ©é˜µï¼Œæˆ‘ä»¬è¿”å›žä¸€ä¸ªç©ºæ•°ç»„ã€‚

éåŽ†ç»“æŸï¼Œå¦‚æžœ $upper$ å’Œ $lower$ éƒ½ä¸º $0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¿”å›ž $ans$ï¼Œå¦åˆ™æˆ‘ä»¬è¿”å›žä¸€ä¸ªç©ºæ•°ç»„ã€‚




```python [sol1-Python3]
class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        n = len(colsum)
        ans = [[0] * n for _ in range(2)]
        for j, v in enumerate(colsum):
            if v == 2:
                ans[0][j] = ans[1][j] = 1
                upper, lower = upper - 1, lower - 1
            if v == 1:
                if upper > lower:
                    upper -= 1
                    ans[0][j] = 1
                else:
                    lower -= 1
                    ans[1][j] = 1
            if upper < 0 or lower < 0:
                return []
        return ans if lower == upper == 0 else []
```



```java [sol1-Java]
class Solution {
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        int n = colsum.length;
        List<Integer> first = new ArrayList<>();
        List<Integer> second = new ArrayList<>();
        for (int j = 0; j < n; ++j) {
            int a = 0, b = 0;
            if (colsum[j] == 2) {
                a = b = 1;
                upper--;
                lower--;
            } else if (colsum[j] == 1) {
                if (upper > lower) {
                    upper--;
                    a = 1;
                } else {
                    lower--;
                    b = 1;
                }
            }
            if (upper < 0 || lower < 0) {
                break;
            }
            first.add(a);
            second.add(b);
        }
        return upper == 0 && lower == 0 ? List.of(first, second) : List.of();
    }
}
```


```cpp [sol1-C++]
class Solution {
public:
    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {
        int n = colsum.size();
        vector<vector<int>> ans(2, vector<int>(n));
        for (int j = 0; j < n; ++j) {
            if (colsum[j] == 2) {
                ans[0][j] = ans[1][j] = 1;
                upper--;
                lower--;
            }
            if (colsum[j] == 1) {
                if (upper > lower) {
                    upper--;
                    ans[0][j] = 1;
                } else {
                    lower--;
                    ans[1][j] = 1;
                }
            }
            if (upper < 0 || lower < 0) {
                break;
            }
        }
        return upper || lower ? vector<vector<int>>() : ans;
    }
};
```



```go [sol1-Go]
func reconstructMatrix(upper int, lower int, colsum []int) [][]int {
	n := len(colsum)
	ans := make([][]int, 2)
	for i := range ans {
		ans[i] = make([]int, n)
	}
	for j, v := range colsum {
		if v == 2 {
			ans[0][j], ans[1][j] = 1, 1
			upper--
			lower--
		}
		if v == 1 {
			if upper > lower {
				upper--
				ans[0][j] = 1
			} else {
				lower--
				ans[1][j] = 1
			}
		}
		if upper < 0 || lower < 0 {
			break
		}
	}
	if upper != 0 || lower != 0 {
		return [][]int{}
	}
	return ans
}
```



```ts [sol1-TypeScript]
function reconstructMatrix(
    upper: number,
    lower: number,
    colsum: number[],
): number[][] {
    const n = colsum.length;
    const ans: number[][] = Array(2)
        .fill(0)
        .map(() => Array(n).fill(0));
    for (let j = 0; j < n; ++j) {
        if (colsum[j] === 2) {
            ans[0][j] = ans[1][j] = 1;
            upper--;
            lower--;
        } else if (colsum[j] === 1) {
            if (upper > lower) {
                ans[0][j] = 1;
                upper--;
            } else {
                ans[1][j] = 1;
                lower--;
            }
        }
        if (upper < 0 || lower < 0) {
            break;
        }
    }
    return upper || lower ? [] : ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $colsum$ çš„é•¿åº¦ã€‚å¿½ç•¥ç­”æ¡ˆæ•°ç»„çš„ç©ºé—´æ¶ˆè€—ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚


---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~