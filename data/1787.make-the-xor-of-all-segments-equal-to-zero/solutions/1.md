## [1787.使所有区间的异或结果为零 中文热门题解1](https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solutions/100000/gong-shui-san-xie-chou-xiang-cheng-er-we-ww79)

作者：[AC_OIer](https://leetcode.cn/u/AC_OIer)
## 基本分析

题目示例所包含的提示过于明显了，估计很多同学光看三个样例就猜出来了：**答案数组必然是每 $k$ 个一组进行重复的。**

这样的性质是可由「答案数组中所有长度为 $k$ 的区间异或结果为 $0$」推导出来的：

* 假设区间 $[i, j]$ 长度为 $k$，其异或结果为 $0$。即 $nums[i] ⊕ nums[i + 1] ⊕ ... ⊕ nums[j] = 0$

* 长度不变，将区间整体往后移动一位 $[i + 1, j + 1]$，其异或结果为 $0$。即 $nums[i + 1] ⊕ ... ⊕ nums[j] ⊕ nums[j + 1] = 0$

* 两式结合，中间 $[i + 1, j]$ 区间的数值出现两次，抵消掉最终剩下 $nums[i] ⊕ nums[j + 1] = 0$，即推出 $nums[i]$ 必然等于 $num[j + 1]$。

即答案数组必然每 $k$ 个一组进行重复。

也可以从滑动窗口的角度分析：窗口每滑动一格，会新增和删除一个值。对于异或而言，新增和删除都是对值本身做异或，因此新增值和删除值相等（保持窗口内异或值为 $0$）。

因此我们将这个一维的输入看成二维，从而将问题转化为：**使得最终每列相等，同时「首行」的异或值为 $0$ 的最小修改次数。**

![image.png](https://pic.leetcode-cn.com/1621904944-ApPozf-image.png)

当然 $n$ 和 $k$ 未必成倍数关系，这时候最后一行可能为不足 $k$ 个。这也是为什么上面没有说「每行异或结果为 $0$」，而是说「首行异或结果为 $0$」的原因：

![image.png](https://pic.leetcode-cn.com/1621907349-YZYOCA-image.png)


***

## 动态规划

定义 $f[i][xor]$ 为考虑前 $i$ 列，且首行前 $i$ 列异或值为 $xor$ 的最小修改次数，最终答案为 $f[k - 1][0]$。

第一维的范围为 $[0, k)$，由输入参数给出；第二维为 $[0, 2^{10})$，根据题目给定的数据范围 `0 <= nums[i] < 2^10` 可得（异或为不进位加法，因此最大异或结果不会超过 $2^{10}$）。

为了方便，我们需要使用哈希表 $map$ 记录每一列的数字分别出现了多少次，使用变量 $cnt$ 统计该列有多少数字（因为最后一行可能不足 $k$ 个）。

不失一般性的考虑 $f[i][xor]$ 如何转移:

* 当前处于第 $0$ 列：由于没有前一列，这时候只需要考虑怎么把该列变成 $xor$ 即可：

$$
f[0][xor] = cnt - map.get(xor)
$$

* 当前处于其他列：需要考虑与前面列的关系。

    我们知道最终的 $f[i][xor]$ 由两部分组成：一部分是前 $i - 1$ 列的修改次数，一部分是当前列的修改次数。
    
    这时候需要分情况讨论：
    
    * **仅修改当列的部分数**：这时候需要从哈希表中遍历已存在的数，在所有方案中取 $min$：
    $$
    f[i][xor] = f[i - 1][xor ⊕ cur] + cnt - map.get(cur)
    $$

    * **对整列进行修改替换**：此时当前列的修改成本固定为 $cnt$，只需要取前 $i - 1$ 列的最小修改次数过来即可：
    $$
    f[i][xor] = f[i - 1][xor'] + cnt
    $$

最终 $f[i][xor]$ 在所有上述方案中取 $min$。为了加速「取前 $i - 1$ 列的最小修改次数」的过程，我们可以多开一个 $g[]$ 数组来记录前一列的最小状态值。

代码：
```Java []
class Solution {
    public int minChanges(int[] nums, int k) {
        int n = nums.length;
        int max = 1024; 
        int[][] f = new int[k][max];
        int[] g = new int[k];
        for (int i = 0; i < k; i++) {
            Arrays.fill(f[i], 0x3f3f3f3f);
            g[i] = 0x3f3f3f3f;
        }
        for (int i = 0, cnt = 0; i < k; i++, cnt = 0) {
            // 使用 map 和 cnt 分别统计当前列的「每个数的出现次数」和「有多少个数」
            Map<Integer, Integer> map = new HashMap<>();
            for (int j = i; j < n; j += k) {
                map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);
                cnt++;
            }
            if (i == 0) { // 第 0 列：只需要考虑如何将该列变为 xor 即可
                for (int xor = 0; xor < max; xor++) {
                    f[0][xor] = Math.min(f[0][xor], cnt - map.getOrDefault(xor, 0));
                    g[0] = Math.min(g[0], f[0][xor]);
                }
            } else { // 其他列：考虑与前面列的关系
                for (int xor = 0; xor < max; xor++) {
                    f[i][xor] = g[i - 1] + cnt; // 整列替换
                    for (int cur : map.keySet()) { // 部分替换
                        f[i][xor] = Math.min(f[i][xor], f[i - 1][xor ^ cur] + cnt - map.get(cur));
                    }
                    g[i] = Math.min(g[i], f[i][xor]);
                }
            }
        }
        return f[k - 1][0];
    }
}
```
* 时间复杂度：共有 $O(C * k)$ 个状态需要被转移（其中 $C$ 固定为 $2^{10}$），每个状态的转移需要遍历哈希表，最多有 $\frac{n}{k}$ 个数，复杂度为 $O(\frac{n}{k})$。整体复杂度为 $O(C * n)$
* 空间复杂度：$O(C * k)$，其中 $C$ 固定为 $2^{10} + 1$

---

## 答疑补充 

* 为啥能直接使用 $f[i][xor] = g[i-1] + cnt$ 呢

**因为是找最小值问题，「某些状态重复参与比较」或者「比较过程中增加一个较大值」不会影响最终结果。**

什么意思呢？假设我们转移 $f[i][xor] = g[i - 1] + cnt$ 的时候使用的 $g[i - 1]$ 是由 $f[i - 1][xor']$ 而来（当然也有可能有多个 $xor'$ 同时取得 $g[i - 1]$）。

这时候为什么直接采用使用 $f[i][xor] = g[i - 1] + cnt$ 是正确的？我们是否需要考虑从 $cnt$ 中删掉一些数？

答案是不需要。

我们令 $x = xor ⊕ xor'$。

* 假如 $x$ 本身在当前列中，这时候理论上我们应该是要让 $f[i][xor] = g[i - 1] + cnt - map.get(x)$，但是如果要实现到这一步的话，我们需要额外记录下 $g[i - 1]$ 是从哪个 $f[i - 1][xor']$ 转移而来，而且从严谨的角度来说，我们需要使用 list 来记录所有的 $xor'$，这将会增加我们算法的复杂度。
    
    因此我们这里采用的做法是，直接 $g[i - 1] + cnt$ 来初始化 $f[i][xor]$（可以观察到，这时候会比“真实值”要大），但这种情况会被「仅修改当列的部分数」的转移过程所修复（不会错过 $f[i][xor]$ 的真实最小值），因此没有问题。

* 假如 $x$ 不在当前列中，这时候 $map.get(x)$ 为 $0$，使用 $f[i][xor] = g[i - 1] + cnt$ 完全对应了真实情况。 

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~