## [792.åŒ¹é…å­åºåˆ—çš„å•è¯æ•° ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/number-of-matching-subsequences/solutions/100000/by-lcbin-gwyj)

ä½œè€…ï¼š[lcbin](https://leetcode.cn/u/lcbin)

**æ–¹æ³•ä¸€ï¼šåˆ†æ¡¶**

é¢˜ç›®ä¸­å­—ç¬¦ä¸² $s$ çš„æ•°æ®è§„æ¨¡æœ€é«˜è¾¾åˆ° $5 \times 10^4$ï¼Œå¦‚æžœæš´åŠ›æžšä¸¾ $words$ ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸² $w$ï¼Œåˆ¤æ–­å…¶æ˜¯å¦ä¸º $s$ çš„å­åºåˆ—ï¼Œå¾ˆæœ‰å¯èƒ½ä¼šè¶…æ—¶ã€‚

æˆ‘ä»¬ä¸å¦¨å°† $words$ ä¸­çš„æ‰€æœ‰å•è¯æ ¹æ®é¦–å­—æ¯æ¥åˆ†æ¡¶ï¼Œå³ï¼šæŠŠæ‰€æœ‰å•è¯æŒ‰ç…§é¦–å­—æ¯åˆ†åˆ° $26$ ä¸ªæ¡¶ä¸­ï¼Œæ¯ä¸ªæ¡¶ä¸­å­˜å‚¨çš„æ˜¯æ‰€æœ‰ä»¥è¯¥å­—æ¯å¼€å¤´çš„æ‰€æœ‰å•è¯ã€‚

æ¯”å¦‚å¯¹äºŽ `words = ["a", "bb", "acd", "ace"]`ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹çš„åˆ†æ¡¶ç»“æžœï¼š

```text
a: ["a", "acd", "ace"]
b: ["bb"]
```

ç„¶åŽæˆ‘ä»¬ä»Ž $s$ çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹éåŽ†ï¼Œå‡è®¾å½“å‰å­—ç¬¦ä¸º `'a'`ï¼Œæˆ‘ä»¬ä»Ž `'a'` å¼€å¤´çš„æ¡¶ä¸­å–å‡ºæ‰€æœ‰å•è¯ã€‚å¯¹äºŽå–å‡ºçš„æ¯ä¸ªå•è¯ï¼Œå¦‚æžœæ­¤æ—¶å•è¯é•¿åº¦ä¸º $1$ï¼Œè¯´æ˜Žè¯¥å•è¯å·²ç»åŒ¹é…å®Œæ¯•ï¼Œæˆ‘ä»¬å°†ç­”æ¡ˆåŠ  $1$ï¼›å¦åˆ™æˆ‘ä»¬å°†å•è¯çš„é¦–å­—æ¯åŽ»æŽ‰ï¼Œç„¶åŽæ”¾å…¥ä¸‹ä¸€ä¸ªå­—æ¯å¼€å¤´çš„æ¡¶ä¸­ï¼Œæ¯”å¦‚å¯¹äºŽå•è¯ `"acd"`ï¼ŒåŽ»æŽ‰é¦–å­—æ¯ `'a'` åŽï¼Œæˆ‘ä»¬å°†å…¶æ”¾å…¥ `'c'` å¼€å¤´çš„æ¡¶ä¸­ã€‚è¿™ä¸€è½®ç»“æŸåŽï¼Œåˆ†æ¡¶ç»“æžœå˜ä¸ºï¼š

```text
c: ["cd", "ce"]
b: ["bb"]
```

éåŽ†å®Œ $s$ åŽï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ç­”æ¡ˆã€‚


```python [sol1-Python3]
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        d = defaultdict(deque)
        for w in words:
            d[w[0]].append(w)
        ans = 0
        for c in s:
            for _ in range(len(d[c])):
                t = d[c].popleft()
                if len(t) == 1:
                    ans += 1
                else:
                    d[t[1]].append(t[1:])
        return ans
```


```java [sol1-Java]
class Solution {
    public int numMatchingSubseq(String s, String[] words) {
        Deque<String>[] d = new Deque[26];
        for (int i = 0; i < 26; ++i) {
            d[i] = new ArrayDeque<>();
        }
        for (String w : words) {
            d[w.charAt(0) - 'a'].add(w);
        }
        int ans = 0;
        for (char c : s.toCharArray()) {
            var q = d[c - 'a'];
            for (int k = q.size(); k > 0; --k) {
                String t = q.pollFirst();
                if (t.length() == 1) {
                    ++ans;
                } else {
                    d[t.charAt(1) - 'a'].offer(t.substring(1));
                }
            }
        }
        return ans;
    }
}
```



```cpp [sol1-C++]
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        vector<queue<string>> d(26);
        for (auto& w : words) d[w[0] - 'a'].emplace(w);
        int ans = 0;
        for (char& c : s) {
            auto& q = d[c - 'a'];
            for (int k = q.size(); k; --k) {
                auto t = q.front();
                q.pop();
                if (t.size() == 1) ++ans;
                else d[t[1] - 'a'].emplace(t.substr(1));
            }
        }
        return ans;
    }
};
```



```go [sol1-Go]
func numMatchingSubseq(s string, words []string) (ans int) {
	d := [26][]string{}
	for _, w := range words {
		d[w[0]-'a'] = append(d[w[0]-'a'], w)
	}
	for _, c := range s {
		q := d[c-'a']
		d[c-'a'] = nil
		for _, t := range q {
			if len(t) == 1 {
				ans++
			} else {
				d[t[1]-'a'] = append(d[t[1]-'a'], t[1:])
			}
		}
	}
	return
}
```

å®žé™…ä¸Šï¼Œæ¯ä¸ªæ¡¶å¯ä»¥åªå­˜å‚¨å•è¯çš„ä¸‹æ ‡ $i$ ä»¥åŠè¯¥å•è¯å½“å‰åŒ¹é…åˆ°çš„ä½ç½® $j$ï¼Œè¿™æ ·å¯ä»¥èŠ‚çœç©ºé—´ã€‚


```python [sol2-Python3]
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        d = defaultdict(deque)
        for i, w in enumerate(words):
            d[w[0]].append((i, 0))
        ans = 0
        for c in s:
            for _ in range(len(d[c])):
                i, j = d[c].popleft()
                j += 1
                if j == len(words[i]):
                    ans += 1
                else:
                    d[words[i][j]].append((i, j))
        return ans
```

```java [sol2-Java]
class Solution {
    public int numMatchingSubseq(String s, String[] words) {
        Deque<int[]>[] d = new Deque[26];
        for (int i = 0; i < 26; ++i) {
            d[i] = new ArrayDeque<>();
        }
        for (int i = 0; i < words.length; ++i) {
            d[words[i].charAt(0) - 'a'].offer(new int[] {i, 0});
        }
        int ans = 0;
        for (char c : s.toCharArray()) {
            var q = d[c - 'a'];
            for (int t = q.size(); t > 0; --t) {
                var p = q.pollFirst();
                int i = p[0], j = p[1] + 1;
                if (j ==  words[i].length()) {
                    ++ans;
                } else {
                    d[words[i].charAt(j) - 'a'].offer(new int[] {i, j});
                }
            }
        }
        return ans;
    }
}
```



```cpp [sol2-C++]
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        vector<queue<pair<int, int>>> d(26);
        for (int i = 0; i < words.size(); ++i) d[words[i][0] - 'a'].emplace(i, 0);
        int ans = 0;
        for (char& c : s) {
            auto& q = d[c - 'a'];
            for (int t = q.size(); t; --t) {
                auto [i, j] = q.front();
                q.pop();
                if (++j == words[i].size()) ++ans;
                else d[words[i][j] - 'a'].emplace(i, j);
            }
        }
        return ans;
    }
};
```




```go [sol2-Go]
func numMatchingSubseq(s string, words []string) (ans int) {
	type pair struct{ i, j int }
	d := [26][]pair{}
	for i, w := range words {
		d[w[0]-'a'] = append(d[w[0]-'a'], pair{i, 0})
	}
	for _, c := range s {
		q := d[c-'a']
		d[c-'a'] = nil
		for _, p := range q {
			i, j := p.i, p.j+1
			if j == len(words[i]) {
				ans++
			} else {
				d[words[i][j]-'a'] = append(d[words[i][j]-'a'], pair{i, j})
			}
		}
	}
	return
}
```

æ—¶é—´å¤æ‚åº¦ $O(n + \sum_{i=0}^{m-1} |w_i|)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸º $s$ å’Œ $words$ çš„é•¿åº¦ï¼Œè€Œ $|w_i|$ ä¸º $words[i]$ çš„é•¿åº¦ã€‚

---

**æ–¹æ³•äºŒï¼šäºŒåˆ†æŸ¥æ‰¾**

æˆ‘ä»¬è¿˜å¯ä»¥å…ˆç”¨æ•°ç»„æˆ–å“ˆå¸Œè¡¨ $d$ å­˜æ”¾å­—ç¬¦ä¸² $s$ æ¯ä¸ªå­—ç¬¦çš„ä¸‹æ ‡ï¼Œå³ $d[c]$ ä¸º $s$ ä¸­æ‰€æœ‰å­—ç¬¦ $c$ çš„ä¸‹æ ‡ç»„æˆçš„æ•°ç»„ã€‚

ç„¶åŽæˆ‘ä»¬éåŽ† $words$ ä¸­çš„æ¯ä¸ªå•è¯ $w$ï¼Œæˆ‘ä»¬é€šè¿‡äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œåˆ¤æ–­ $w$ æ˜¯å¦ä¸º $s$ çš„å­åºåˆ—ï¼Œæ˜¯åˆ™ç­”æ¡ˆåŠ  $1$ã€‚åˆ¤æ–­é€»è¾‘å¦‚ä¸‹ï¼š

1. å®šä¹‰æŒ‡é’ˆ $i$ è¡¨ç¤ºå½“å‰æŒ‡å‘å­—ç¬¦ä¸² $s$ çš„ç¬¬ $i$ ä¸ªå­—ç¬¦ï¼Œåˆå§‹åŒ–ä¸º $-1$ã€‚
1. éåŽ†å­—ç¬¦ä¸² $w$ ä¸­çš„æ¯ä¸ªå­—ç¬¦ $c$ï¼Œåœ¨ $d[c]$ ä¸­äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºŽ $i$ çš„ä½ç½® $j$ï¼Œå¦‚æžœä¸å­˜åœ¨ï¼Œåˆ™è¯´æ˜Ž $w$ ä¸æ˜¯ $s$ çš„å­åºåˆ—ï¼Œç›´æŽ¥è·³å‡ºå¾ªçŽ¯ï¼›å¦åˆ™ï¼Œå°† $i$ æ›´æ–°ä¸º $d[c][j]$ï¼Œç»§ç»­éåŽ†ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚
1. å¦‚æžœéåŽ†å®Œ $w$ ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼Œè¯´æ˜Ž $w$ æ˜¯ $s$ çš„å­åºåˆ—ã€‚

```python  [sol3-Python3]
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        def check(w):
            i = -1
            for c in w:
                j = bisect_right(d[c], i)
                if j == len(d[c]):
                    return False
                i = d[c][j]
            return True

        d = defaultdict(list)
        for i, c in enumerate(s):
            d[c].append(i)
        return sum(check(w) for w in words)
```


```java  [sol3-Java]
class Solution {
    private List<Integer>[] d = new List[26];

    public int numMatchingSubseq(String s, String[] words) {
        for (int i = 0; i < 26; ++i) {
            d[i] = new ArrayList<>();
        }
        for (int i = 0; i < s.length(); ++i) {
            d[s.charAt(i) - 'a'].add(i);
        }
        int ans = 0;
        for (String w : words) {
            if (check(w)) {
                ++ans;
            }
        }
        return ans;
    }

    private boolean check(String w) {
        int i = -1;
        for (int k = 0; k < w.length(); ++k) {
            int c = w.charAt(k) - 'a';
            int j = search(d[c], i);
            if (j == d[c].size()) {
                return false;
            }
            i = d[c].get(j);
        }
        return true;
    }

    private int search(List<Integer> t, int x) {
        int left = 0, right = t.size();
        while (left < right) {
            int mid = (left + right) >> 1;
            if (t.get(mid) > x) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```


```cpp  [sol3-C++]
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        vector<vector<int>> d(26);
        for (int i = 0; i < s.size(); ++i) d[s[i] - 'a'].emplace_back(i);
        int ans = 0;
        auto check = [&](string& w) {
            int i = -1;
            for (char& c : w) {
                auto& t = d[c - 'a'];
                int j = upper_bound(t.begin(), t.end(), i) - t.begin();
                if (j == t.size()) return false;
                i = t[j];
            }
            return true;
        };
        for (auto& w : words) ans += check(w);
        return ans;
    }
};
```


```go  [sol3-Go]
func numMatchingSubseq(s string, words []string) (ans int) {
	d := [26][]int{}
	for i, c := range s {
		d[c-'a'] = append(d[c-'a'], i)
	}
	check := func(w string) bool {
		i := -1
		for _, c := range w {
			t := d[c-'a']
			j := sort.SearchInts(t, i+1)
			if j == len(t) {
				return false
			}
			i = t[j]
		}
		return true
	}
	for _, w := range words {
		if check(w) {
			ans++
		}
	}
	return
}
```

æ—¶é—´å¤æ‚åº¦ $O(\sum_{i=0}^{m-1} |w_i| \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m)$ã€‚å…¶ä¸­ $n$ å’Œ $m$ åˆ†åˆ«ä¸º $s$ å’Œ $words$ çš„é•¿åº¦ï¼Œè€Œ $|w_i|$ ä¸º $words[i]$ çš„é•¿åº¦ã€‚



---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~

