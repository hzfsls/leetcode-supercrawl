## [373.æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­— ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/100000/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5)

ä½œè€…ï¼š[AC_OIer](https://leetcode.cn/u/AC_OIer)
## åŸºæœ¬åˆ†æ 

è¿™é“é¢˜å’Œ [(é¢˜è§£) 786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•°](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/) å‡ ä¹æ˜¯ä¸€æ¨¡ä¸€æ ·ï¼Œå…ˆåšå“ªä¸€é“éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéš¾åº¦ä¸Šæ²¡æœ‰åŒºåˆ« ğŸ¤£ 

æœ€å¸¸è§„çš„åšæ³•æ˜¯ä½¿ç”¨ã€Œå¤šè·¯å½’å¹¶ã€ï¼Œè¿˜ä¸ç†Ÿæ‚‰ã€Œå¤šè·¯å½’å¹¶ã€çš„åŒå­¦ï¼Œå»ºè®®å…ˆå­¦ä¹ å‰ç½®ğŸ§€ï¼š[å¤šè·¯å½’å¹¶å…¥é—¨](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490029&idx=1&sn=bba9ddff88d247db310406ee418d5a15&chksm=fd9cb2f2caeb3be4b1f84962677337dcb5884374e5b6b80340834eaff79298d11151da2dd5f7&token=252055586&lang=zh_CN#rd)ï¼Œé‡Œé¢è®²è¿°äº†å¦‚ä½•ä»ã€Œæœ´ç´ ä¼˜å…ˆé˜Ÿåˆ—ã€å¾€ã€Œå¤šè·¯å½’å¹¶ã€è¿›è¡Œè½¬æ¢ã€‚

---

## å¤šè·¯å½’å¹¶

ä»¤ $nums1$ çš„é•¿åº¦ä¸º $n$ï¼Œ$nums2$ çš„é•¿åº¦ä¸º $m$ï¼Œæ‰€æœ‰çš„ç‚¹å¯¹æ•°é‡ä¸º $n * m$ã€‚

å…¶ä¸­æ¯ä¸ª $nums1[i]$ å‚ä¸æ‰€ç»„æˆçš„ç‚¹åºåˆ—ä¸ºï¼š

$$
[(nums1[0], nums2[0]), (nums1[0], nums2[1]), ..., (nums1[0], nums2[m - 1])]\\
[(nums1[1], nums2[0]), (nums1[1], nums2[1]), ..., (nums1[1], nums2[m - 1])]\\
...\\
[(nums1[n - 1], nums2[0]), (nums1[n - 1], nums2[1]), ..., (nums1[n - 1], nums2[m - 1])]\\
$$

ç”±äº $nums1$ å’Œ $nums2$ å‡å·²æŒ‰å‡åºæ’åºï¼Œå› æ­¤æ¯ä¸ª $nums1[i]$ å‚ä¸æ„æˆçš„ç‚¹åºåˆ—ä¹Ÿä¸ºå‡åºæ’åºï¼Œè¿™å¼•å¯¼æˆ‘ä»¬ä½¿ç”¨ã€Œå¤šè·¯å½’å¹¶ã€æ¥è¿›è¡Œæ±‚è§£ã€‚

å…·ä½“çš„ï¼Œèµ·å§‹æˆ‘ä»¬å°†è¿™ $n$ ä¸ªåºåˆ—çš„é¦–ä½å…ƒç´ ï¼ˆç‚¹å¯¹ï¼‰ä»¥äºŒå…ƒç»„ $(i, j)$ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰ï¼Œå…¶ä¸­ $i$ ä¸ºè¯¥ç‚¹å¯¹ä¸­ $nums1[i]$ çš„ä¸‹æ ‡ï¼Œ$j$ ä¸ºè¯¥ç‚¹å¯¹ä¸­ $nums2[j]$ çš„ä¸‹æ ‡ï¼Œè¿™æ­¥æ“ä½œçš„å¤æ‚åº¦ä¸º $O(n\log{n})$ã€‚è¿™é‡Œä¹Ÿå¯ä»¥å¾—å‡ºä¸€ä¸ªå°ä¼˜åŒ–æ˜¯ï¼šæˆ‘ä»¬å§‹ç»ˆç¡®ä¿ $nums1$ ä¸ºä¸¤æ•°ç»„ä¸­é•¿åº¦è¾ƒå°‘çš„é‚£ä¸ªï¼Œç„¶åé€šè¿‡æ ‡è¯†ä½æ¥è®°å½•æ˜¯å¦å‘ç”Ÿè¿‡äº¤æ¢ï¼Œç¡®ä¿ç­”æ¡ˆçš„ç‚¹é¡ºåºçš„æ­£ç¡®æ€§ã€‚

æ¯æ¬¡ä»ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­å–å‡ºå †é¡¶å…ƒç´ ï¼ˆå«ä¹‰ä¸ºå½“å‰æœªè¢«åŠ å…¥åˆ°ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹ä¸­çš„æœ€å°å€¼ï¼‰ï¼ŒåŠ å…¥ç­”æ¡ˆï¼Œå¹¶å°†è¯¥ç‚¹å¯¹æ‰€åœ¨åºåˆ—çš„ä¸‹ä¸€ä½ï¼ˆå¦‚æœæœ‰ï¼‰åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚

ä¸¾ä¸ª ğŸŒ°ï¼Œé¦–æ¬¡å–å‡ºçš„äºŒå…ƒç»„ä¸º $(0, 0)$ï¼Œå³ç‚¹å¯¹ $(nums1[0], nums2[0])$ï¼Œå–å®Œåå°†åºåˆ—çš„ä¸‹ä¸€ä½ç‚¹å¯¹ $(nums1[0], nums2[1])$ ä»¥äºŒå…ƒç»„ $(0, 1)$ å½¢å¼æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ã€‚

å¯é€šè¿‡ã€Œåè¯æ³•ã€è¯æ˜ï¼Œæ¯æ¬¡è¿™æ ·çš„ã€Œå–å½“å‰ï¼Œæ”¾å…¥ä¸‹ä¸€ä½ã€çš„æ“ä½œï¼Œå¯ä»¥ç¡®ä¿å½“å‰æœªè¢«åŠ å…¥ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹çš„æœ€å°å€¼å¿…ç„¶åœ¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­ï¼Œå³å‰ $k$ ä¸ªå‡ºå †çš„å…ƒç´ å¿…ç„¶æ˜¯æ‰€æœ‰ç‚¹å¯¹çš„å‰ $k$ å°çš„å€¼ã€‚

**ä»£ç ï¼ˆæ„Ÿè°¢ [@Benhao](/u/himymben/) å’Œ [@ğŸ­å¯ä¹å¯ä¹å—](/u/littletime_cc/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    boolean flag = true;
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        int n = nums1.length, m = nums2.length;
        if (n > m && !(flag = false)) return kSmallestPairs(nums2, nums1, k);
        List<List<Integer>> ans = new ArrayList<>();
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(nums1[a[0]]+nums2[a[1]])-(nums1[b[0]]+nums2[b[1]]));
        for (int i = 0; i < Math.min(n, k); i++) q.add(new int[]{i, 0});
        while (ans.size() < k && !q.isEmpty()) {
            int[] poll = q.poll();
            int a = poll[0], b = poll[1];
            ans.add(new ArrayList<>(){{
                add(flag ? nums1[a] : nums2[b]);
                add(flag ? nums2[b] : nums1[a]);
            }});
            if (b + 1 < m) q.add(new int[]{a, b + 1});
        }
        return ans;
    }
}
```
```C++ []
class Solution {
public:
    bool flag = true;
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<vector<int>> ans;
        int n = nums1.size(), m = nums2.size();
        if(n > m) { //å§‹ç»ˆç¡®ä¿nums1ä¸ºä¸¤æ•°ç»„ä¸­é•¿åº¦è¾ƒå°‘çš„é‚£ä¸ª
            swap(nums1, nums2);
            swap(m,n);
            flag = false;
        }
        //å®šä¹‰æ¯”è¾ƒè§„åˆ™
        auto cmp = [&](const auto& a, const auto& b){
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };
        priority_queue< pair<int,int>, vector<pair<int,int>>, decltype(cmp) > q(cmp);
        for(int i = 0; i < min(n,k); i++){
            q.push( {i, 0} );
        }
        while(ans.size() < k and q.size()){
            auto [a,b] = q.top();
            q.pop();
            flag ? ans.push_back( {nums1[a], nums2[b]}) : ans.push_back( {nums2[b], nums1[a]});
            if(b + 1 < m) q.push( {a, b + 1} );
        }
        return ans;
    }
};
```
```Python3 []
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        flag, ans = (n := len(nums1)) > (m := len(nums2)), []
        if flag:
            n, m, nums1, nums2 = m, n, nums2, nums1
        pq = []
        for i in range(min(n, k)):
            heapq.heappush(pq, (nums1[i] + nums2[0], i, 0))
        while len(ans) < k and pq:
            _, a, b = heapq.heappop(pq)
            ans.append([nums2[b], nums1[a]] if flag else [nums1[a], nums2[b]])
            if b + 1 < m:
                heapq.heappush(pq, (nums1[a] + nums2[b + 1], a, b + 1))
        return ans
```
```Golang []
func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {
    n, m, ans := len(nums1), len(nums2), [][]int{}
    flag := n > m
    if flag {
        n, m, nums1, nums2 = m, n, nums2, nums1
    }
    if n > k {
        n = k
    }
    pq := make(hp, n)
    for i := 0; i < n; i++ {
        pq[i] = []int{nums1[i] + nums2[0], i, 0}
    }
    heap.Init(&pq)
    for pq.Len() > 0 && len(ans) < k {
        poll := heap.Pop(&pq).([]int)
        a, b := poll[1], poll[2] 
        if flag{
            ans = append(ans, []int{nums2[b], nums1[a]})
        }else{
            ans = append(ans, []int{nums1[a], nums2[b]})
        }
        if b < m - 1 {
            heap.Push(&pq, []int{nums1[a] + nums2[b + 1], a, b + 1})
        }
    }
    return ans
}
// æœ€å°å †æ¨¡æ¿
type hp [][]int
func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { return h[i][0] < h[j][0] }
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.([]int)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }
```
* æ—¶é—´å¤æ‚åº¦ï¼šä»¤ $M$ ä¸º $n$ã€$m$ å’Œ $k$ ä¸‰è€…ä¸­çš„æœ€å°å€¼ï¼Œå¤æ‚åº¦ä¸º $O(M + k) * \log{M})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(M)$

---

## äºŒåˆ†

æˆ‘ä»¬è¿˜èƒ½å¤Ÿä½¿ç”¨å¤šæ¬¡ã€ŒäºŒåˆ†ã€æ¥åšã€‚

å‡è®¾æˆ‘ä»¬å°†æ‰€æœ‰ã€Œæ•°å¯¹å’Œã€æŒ‰ç…§å‡åºæ’åºï¼Œä¸¤ç«¯çš„å€¼åˆ†åˆ«ä¸º $l = nums1[0] + nums2[0]$ å’Œ $r = nums1[n - 1] + nums2[m - 1]$ã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨å€¼åŸŸ $[l, r]$ ä¸Šè¿›è¡ŒäºŒåˆ†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³ã€Œç‚¹å¯¹å’Œå°äºç­‰äº $x$ çš„ï¼Œä¸”æ•°é‡è¶…è¿‡ $k$ çš„å€¼ $x$ã€ã€‚

ä¹‹æ‰€ä»¥èƒ½å¤ŸäºŒåˆ†ï¼Œæ˜¯å› ä¸º $x$ æ‰€åœ¨çš„ç‚¹å¯¹å’Œæ•°è½´ä¸Šå…·æœ‰äºŒæ®µæ€§ï¼š

* ç‚¹å¯¹å’Œå°äº $x$ çš„ç‚¹å¯¹æ•°é‡å°‘äº $k$ ä¸ªï¼›
* ç‚¹å¯¹å’Œå¤§äºç­‰äº $x$ çš„ç‚¹å¯¹æ•°é‡å¤§äºç­‰äº $k$ ä¸ªã€‚

åˆ¤å®šå°äºç­‰äº $x$ çš„ç‚¹å¯¹æ•°é‡æ˜¯å¦å¤§äºç­‰äº $k$ ä¸ªè¿™ä¸€æ­¥å¯ç›´æ¥ä½¿ç”¨å¾ªç¯æ¥åšï¼Œç”±äºäºŒåˆ†æ˜¯ä»ä¸­é—´å€¼å¼€å§‹ï¼Œè¿™ä¸€æ­¥ä¸ä¼šå‡ºç°è·‘æ»¡ä¸¤å±‚å¾ªç¯çš„æƒ…å†µã€‚

å½“äºŒåˆ†å‡ºç¬¬ $k$ å°çš„å€¼ä¸º $x$ åï¼Œç”±äºå­˜åœ¨ä¸åŒç‚¹å¯¹çš„ç‚¹å¯¹å’Œå€¼ç›¸ç­‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå°†æ‰€æœ‰ç‚¹å¯¹å’Œå°äºç­‰äº $x$ çš„å€¼åŠ å…¥ç­”æ¡ˆï¼Œç„¶åé…Œæƒ…æŠŠå€¼ç­‰äº $x$ çš„ç‚¹å¯¹åŠ å…¥ç­”æ¡ˆï¼ŒçŸ¥é“æ»¡è¶³ç­”æ¡ˆæ•°é‡ä¸º $k$ã€‚

æ‰¾å€¼ä¸º $x$ çš„æ‰€æœ‰ç‚¹å¯¹è¿™ä¸€æ­¥ï¼Œå¯ä»¥é€šè¿‡æšä¸¾ $nums1[i]$ï¼Œç„¶ååœ¨ $nums2$ ä¸ŠäºŒåˆ†ç›®æ ‡å€¼ $x - nums1[i]$ çš„å·¦å³ç«¯ç‚¹æ¥åšã€‚

æœ€åï¼Œåœ¨æ‰€æœ‰å¤„ç†è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åˆ©ç”¨ç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ $k$ çš„å…³ç³»åšå‰ªæã€‚

**ä»£ç ï¼ˆæ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—](/u/littletime_cc/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    int[] nums1, nums2;
    int n, m;
    public List<List<Integer>> kSmallestPairs(int[] n1, int[] n2, int k) {
        nums1 = n1; nums2 = n2;
        n = nums1.length; m = nums2.length;
        List<List<Integer>> ans = new ArrayList<>();
        int l = nums1[0] + nums2[0], r = nums1[n - 1] + nums2[m - 1];
        while (l < r) {
            int mid = (int)(0L + l + r >> 1);
            if (check(mid, k)) r = mid;
            else l = mid + 1;
        }
        int x = r;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (nums1[i] + nums2[j] < x) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums1[i]); temp.add(nums2[j]);
                    ans.add(temp);
                } else break;
            }
        }
        for (int i = 0; i < n && ans.size() < k; i++) {
            int a = nums1[i], b = x - a;
            int c = -1, d = -1;
            l = 0; r = m - 1;
            while (l < r) {
                int mid = (int)(0L + l + r >> 1);
                if (nums2[mid] >= b) r = mid;
                else l = mid + 1;
            }
            if (nums2[r] != b) continue;
            c = r;
            l = 0; r = m - 1;
            while (l < r) {
                int mid = (int)(0L + l + r + 1) >> 1;
                if (nums2[mid] <= b) l = mid;
                else r = mid - 1;
            }
            d = r;
            for (int p = c; p <= d && ans.size() < k; p++) {
                List<Integer> temp = new ArrayList<>();
                temp.add(a); temp.add(b);
                ans.add(temp);
            }
        }
        return ans;
    }
    boolean check(int x, int k) {
        int ans = 0;
        for (int i = 0; i < n && ans < k; i++) {
            for (int j = 0; j < m && ans < k; j++) {
                if (nums1[i] + nums2[j] <= x) ans++;
                else break;
            }
        }
        return ans >= k;
    }
}
```
```C++ []
class Solution {
public:
    vector<int> nums1, nums2;
    int n, m;
    vector<vector<int>> kSmallestPairs(vector<int>& n1, vector<int>& n2, int k) {
        nums1 = n1;
        nums2 = n2;
        n = nums1.size(), m = nums2.size();
        vector<vector<int>> ans;
        int L = nums1[0] + nums2[0], R = nums1[n - 1] + nums2[m - 1];
        while(L < R){
            int mid = (0LL + L + R) >> 1;
            if(check(mid, k)) R = mid;
            else L = mid + 1;
        }
        int x = R;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(nums1[i] + nums2[j] < x){
                    ans.push_back( {nums1[i], nums2[j]} );
                }
                else break;
            }
        }
        for(int i = 0; i < n and ans.size() < k; i++){
            int a = nums1[i], b = x - a;
            L = 0, R = m - 1;
            while(L < R){
                int mid = (0LL + L + R) >> 1;
                if(nums2[mid] >= b) R = mid;
                else L = mid + 1;
            }
            if(nums2[R] != b) continue;
            int c = R;
            L = 0, R = m - 1;
            while(L < R){
                int mid = (0LL + L + R + 1) >> 1;
                if(nums2[mid] <= b) L = mid;
                else R = mid - 1;
            }
            int d = R;
            for(int p = c; p <= d and ans.size() < k; p++){
                ans.push_back( {a, b} );
            }
        }
        return ans;
    }
    bool check(int x, int k){
        int ans = 0;
        for(int i = 0; i < n && ans < k; i++){
            for(int j = 0; j < m and ans < k; j++){
                if(nums1[i] + nums2[j] <= x) ans++;
                else break;
            }
        }
        return ans >= k;
    }
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šå‡è®¾ç‚¹å¯¹å’Œçš„å€¼åŸŸå¤§å°èŒƒå›´ä¸º $M$ï¼Œç¬¬ä¸€æ¬¡äºŒåˆ†çš„å¤æ‚åº¦ä¸º $O((n * m) * \log{M})$ï¼›ç»Ÿè®¡ç‚¹å¯¹å’Œå€¼å°äºç›®æ ‡å€¼ $x$ çš„å¤æ‚åº¦ä¸º $O(n * m)$ï¼›ç»Ÿè®¡æ‰€æœ‰ç‚¹å¯¹å’Œç­‰äºç›®æ ‡å€¼çš„å¤æ‚åº¦ä¸º $O(\max(n * \log{m}, k))$ï¼ˆæ•´ä¸ªå¤„ç†è¿‡ç¨‹ä¸­åˆ©ç”¨äº†å¤§å°å…³ç³»åšäº†å‰ªæï¼Œå¤§å¤šå¾ªç¯éƒ½ä¸ä¼šè·‘æ»¡ï¼Œå®é™…è®¡ç®—é‡ä¼šæ¯”ç†è®ºåˆ†æçš„è¦ä½ï¼‰
* ç©ºé—´å¤æ‚åº¦ï¼š$O(k)$

---


## æœ€å

**å¦‚æœæœ‰å¸®åŠ©åˆ°ä½ ï¼Œè¯·ç»™é¢˜è§£ç‚¹ä¸ªèµå’Œæ”¶è—ï¼Œè®©æ›´å¤šçš„äººçœ‹åˆ° ~ ("â–”â–¡â–”)/**

ä¹Ÿæ¬¢è¿ä½  [å…³æ³¨æˆ‘](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) å’Œ åŠ å…¥æˆ‘ä»¬çš„[ã€Œç»„é˜Ÿæ‰“å¡ã€](https://leetcode-cn.com/u/ac_oier/)å°ç¾¤ ï¼Œæä¾›å†™ã€Œè¯æ˜ã€&ã€Œæ€è·¯ã€çš„é«˜è´¨é‡é¢˜è§£ã€‚

æ‰€æœ‰é¢˜è§£å·²ç»åŠ å…¥ [åˆ·é¢˜æŒ‡å—](https://github.com/SharingSource/LogicStack-LeetCode/wiki)ï¼Œæ¬¢è¿ star å“¦ ~ 