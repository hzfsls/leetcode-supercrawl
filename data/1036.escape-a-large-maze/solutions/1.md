## [1036.é€ƒç¦»å¤§è¿·å®« ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/escape-a-large-maze/solutions/100000/gong-shui-san-xie-bfs-gei-ding-zhang-ai-8w63o)

ä½œè€…ï¼š[AC_OIer](https://leetcode.cn/u/AC_OIer)
## BFS + ç»™å®šéšœç¢ç‰©æ‰€èƒ½å›´æˆçš„æœ€å¤§é¢ç§¯

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ç”¨ $s$ ä»£æŒ‡ $source$ï¼Œç”¨ $t$ ä»£æŒ‡ $target$ï¼Œç”¨ $n$ æ¥ä»£æŒ‡ $blocked$ å¤§å°ã€‚

æ•´ç†é¢˜æ„ä¸ºï¼šåœ¨ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºé—´é‡Œï¼Œæœ‰å°‘æ•°çš„éšœç¢ç‰©ï¼Œé—®ä¸¤ç‚¹æ˜¯å¦è¿é€šã€‚

å½“ä¸¤ç‚¹ç›¸éš”è¾ƒè¿œæ—¶ï¼Œå¸¸è§„çš„ `BFS` åšæ³•å¯èƒ½ä¼šæœå®Œæ•´ä¸ªæ£‹ç›˜ï¼Œè€Œæ£‹ç›˜å¤§å°ä¸º $10^6 * 10^6$ï¼Œä¼š `TLE`ã€‚

è€ƒè™‘ä»€ä¹ˆæƒ…å†µä¸‹ä¸¤ç‚¹ä¼šä¸è¿é€šï¼Ÿ

å½“ä¸¤ä¸ªç‚¹ä¸­çš„ä»»æ„ä¸€ç‚¹è¢«éšœç¢ç‰©å›´ä½æ—¶ï¼Œä¸¤ç‚¹å°†æ— æ³•è¿é€šã€‚

ä¸€ä¸ªå¾ˆå®¹æ˜“æƒ³åˆ°çš„æ€è·¯æ˜¯ï¼š**ä» $s$ è·‘ä¸€é `BFS`ï¼Œç„¶åä» $t$ è·‘ä¸€é `BFS`ï¼ŒåŒæ—¶è®¾å®šä¸€ä¸ªæœ€å¤§è®¿é—®ç‚¹æ•°é‡ `MAX`ï¼Œè‹¥ä»ä¸¤è€…å‡ºå‘èƒ½å¤Ÿè®¿é—®çš„ç‚¹æ•°é‡éƒ½èƒ½è¶…è¿‡ `MAX`ï¼Œè¯´æ˜ä¸¤ç‚¹å‡æ²¡æœ‰è¢«å›´ä½ï¼Œæœ€ç»ˆå¿…ç„¶ä¼šè”é€šã€‚**

è€ƒè™‘å¦‚ä½•æ•²å®š `MAX`  çš„å–å€¼èŒƒå›´ï¼Ÿç›´è§‚æ„Ÿå—ï¼Œ`MAX` åº”è¯¥æ˜¯ä¸€ä¸ªä¸ $blocked$ å¤§å°ç›¸å…³çš„æ•°ã€‚

ä½†ç¬¬ä¸€ååº”è¿˜æ˜¯æƒ³ä»å•ç§’è®¡ç®—é‡ä¸Šç•Œè¿›è¡Œåæ¨ï¼Œä¸¤è¾¹ `BFS`  çš„å¤æ‚åº¦å‡ä¸º $O(\max)$ï¼Œå› æ­¤ç›´æ¥è®¾å®š `MAX = 1e5` åº”è¯¥æ˜¯æ¯”è¾ƒåˆé€‚çš„ã€‚

æ›´å°çš„ `MAX` éœ€è¦è¯æ˜ï¼š**åœ¨ç»™å®šæ•°é‡éšœç¢ç‰©çš„å‰æä¸‹ï¼Œéšœç¢ç‰©æ‰€èƒ½å›´æˆçš„æœ€å¤§é¢ç§¯ä¸ºå¤šå°‘ã€‚**

é¦–å…ˆï¼Œå®¹æ˜“æƒ³åˆ°ï¼š**ä»»ä½•ä¸€æ¡å°é—­å›¾å½¢çš„ç›´è¾¹éƒ½å¯ä»¥é€šè¿‡è°ƒæ•´ä¸ºæ–œè¾¹æ¥å›´æˆæ›´å¤§çš„é¢ç§¯ï¼š**

![image.png](https://pic.leetcode-cn.com/1641855571-IOaJZJ-image.png)

**å³ç»„æˆå°é—­å›¾å½¢çš„è¾¹ä¸å¯èƒ½æœ‰ç›´è¾¹ï¼ŒåŒæ—¶ç”±äºæ˜¯å°é—­å›¾å½¢ï¼Œå› æ­¤æ–œè¾¹ç›´æ¥å¿…ç„¶æ˜¯å•ç‚¹è¡”æ¥ï¼Œè€Œä¸å¯èƒ½æ˜¯å¹³è¡Œï¼ˆæ— æ³•å°é—­ï¼‰ã€‚**

åŒæ—¶ï¼Œ**æƒ³è¦è¾¾åˆ°æœ€å¤§é¢ç§¯ï¼Œåº”å½“å°½å¯èƒ½åˆ©ç”¨è¾¹ç•Œä½œä¸ºå›´æˆå›¾å½¢çš„æŸäº›è¾¹ã€‚**

åˆ©ç”¨è¾¹ç•Œæ‰€èƒ½å›´æˆçš„æœ€å¤§å°é¢å›¾å½¢ **å¯ä»¥æ˜¯**ã€Œç”±è¾¹ç•Œæä¾›ä¸¤è¾¹ï¼Œéšœç¢ç‰©æä¾›ä¸€è¾¹çš„ä¸‰è§’å½¢ã€ã€‚

å¦‚æœä¸æ˜¯è¯¥å½¢çŠ¶ï¼Œåˆ™å¯ä»¥é€šè¿‡è°ƒæ•´éšœç¢ç‰©çš„ç›´è¾¹ä¸ºä¸€æ¡å®Œæ•´çš„æ–œè¾¹ï¼Œæ¥ç»„æˆå°é—­ä¸‰è§’å½¢ï¼Œå›´æˆé¢ç§¯ä¸ä¼šå˜å°ï¼š

![image.png](https://pic.leetcode-cn.com/1641856898-BYFygs-image.png)

å³ç»™å®š $n$ çš„æƒ…å†µä¸‹ï¼Œæ ¹æ®ã€Œç­‰å·®æ•°åˆ—æ±‚å’Œã€å¯çŸ¥ï¼Œæœ€å¤§æ‰€èƒ½å›´æˆçš„é¢ç§¯ä¸º $1 + 2 + ... + n - 1 = \frac{n * (n - 1)}{2}$ã€‚

å› æ­¤å¦‚æœä» $s$ å’Œ $t$ å‡ºå‘ï¼Œèƒ½å¤Ÿè®¿é—®çš„ç‚¹æ•°è¶…è¿‡ $\frac{n * (n - 1)}{2}$ ä¸ªï¼Œé‚£ä¹ˆä¸¤ç‚¹å¹¶æ²¡æœ‰è¢«å›´ä½ï¼Œå¿…ç„¶è”é€šã€‚

æœ€åï¼Œä¸ºäº†åœ¨ `BFS` è¿‡ç¨‹ä¸­è®°å½•æŸäº›ç‚¹è¢«è®¿é—®è¿‡ï¼Œå¯ä»¥é€šè¿‡è®¡ç®—æŸä¸ªä½ç½®å“ˆå¸Œå€¼ï¼ˆæ•°å€¼ï¼‰æ¥å®ç°ã€‚

**ä»£ç ï¼ˆæ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—QAQ](/u/littletime_cc/) å’Œ [@Benhao](/u/himymben/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    int EDGE = (int)1e6, MAX = (int)1e5;
    long BASE = 131L;
    Set<Long> set = new HashSet<>();
    int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public boolean isEscapePossible(int[][] blocked, int[] s, int[] t) {
        for (int[] p : blocked) set.add(p[0] * BASE + p[1]);
        int n = blocked.length;
        MAX = n * (n - 1) / 2; // å¯ç›´æ¥ä½¿ç”¨ 1e5
        return check(s, t) && check(t, s);
    }
    boolean check(int[] a, int[] b) {
        Set<Long> vis = new HashSet<>();
        Deque<int[]> d = new ArrayDeque<>();
        d.addLast(a);
        vis.add(a[0] * BASE + a[1]);
        while (!d.isEmpty() && vis.size() <= MAX) {
            int[] poll = d.pollFirst();
            int x = poll[0], y = poll[1];
            if (x == b[0] && y == b[1]) return true;
            for (int[] di : dir) {
                int nx = x + di[0], ny = y + di[1];
                if (nx < 0 || nx >= EDGE || ny < 0 || ny >= EDGE) continue;
                long hash = nx * BASE + ny;
                if (set.contains(hash)) continue;
                if (vis.contains(hash)) continue;
                d.addLast(new int[]{nx, ny});
                vis.add(hash);
            }
        }
        return vis.size() > MAX;
    }
}
```
```C++ []
class Solution {
public:
    int EDGE = 1e6, MAX = 1e5;
    long long BASE = 13331;
    unordered_set<long long> set;
    int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& s, vector<int>& t) {
        for(auto& p : blocked) set.insert(p[0] * BASE + p[1]);
        int n = blocked.size();
        MAX = n * (n - 1) / 2; // å¯ç›´æ¥ä½¿ç”¨ 1e5
        return check(s, t) and check(t, s);
    }
    bool check(vector<int>& a, vector<int>& b){
        unordered_set<long long> vis;
        queue< pair<int,int> > q;
        q.push( {a[0], a[1]});
        vis.insert(a[0] * BASE + a[1]);
        while(q.size() and vis.size() <= MAX){
            auto t = q.front();
            q.pop();
            int x = t.first, y = t.second;
            if(x == b[0] and y == b[1]) return true;
            for(int i = 0; i < 4; i++){
                int nx = x + dir[i][0], ny = y + dir[i][1];
                if(nx < 0 or nx >= EDGE or ny < 0 or ny >= EDGE) continue;
                if(set.count(nx * BASE + ny)) continue;
                if(vis.count(nx * BASE + ny)) continue;
                q.push( {nx, ny} );
                vis.insert(nx * BASE + ny);
            }
        }
        return vis.size() > MAX;
    }
};
```
```Python3 []
EDGE, MAX, BASE, DIR = int(1e6), int(1e5), 131, [(1, 0), (-1, 0), (0, 1), (0, -1)]
class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        block = {p[0] * BASE + p[1] for p in blocked}
        n = len(blocked)
        MAX = n * (n-1)//2 # å¯ç›´æ¥ä½¿ç”¨ 1e5
        def check(a, b):
            vis = {a[0] * BASE + a[1]}
            d = deque([a])
            while len(d) and len(vis) <= MAX:
                x, y = d.popleft()
                if x == b[0] and y == b[1]:
                    return True
                for dx, dy in DIR:
                    nx, ny = x + dx, y + dy
                    if nx < 0 or nx >= EDGE or ny < 0 or ny >= EDGE:
                        continue
                    h = nx * BASE + ny
                    if h in block or h in vis:
                        continue
                    d.append((nx, ny))
                    vis.add(h)
            return len(vis) > MAX
        return check(source, target) and check(target, source)
```
* æ—¶é—´å¤æ‚åº¦ï¼šä»¤ $n$ ä¸º $blocked$ å¤§å°ï¼Œä¸¤æ¬¡ `BFS` çš„æœ€å¤§è®¿é—®ç‚¹æ•°ä¸º $\frac{n * (n - 1)}{2}$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼šä¸¤æ¬¡ `BFS` çš„æœ€å¤§è®¿é—®ç‚¹æ•°ä¸º $\frac{n * (n - 1)}{2}$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2)$

---

## ç¦»æ•£åŒ– + BFS

åˆ©ç”¨éšœç¢ç‰©åªæœ‰ $200$ ä¸ªï¼Œå¯ä»¥å¯¹å¤§æ£‹ç›˜è¿›è¡Œç¦»æ•£åŒ–ï¼Œå†è¿›è¡Œå¸¸è§„çš„ `BFS`ã€‚

ä»£ç ï¼š
```Java []
class Solution {
    int N = 500, EDGE = (int)1e6;
    boolean[][] vis = new boolean[N][N];
    boolean[][] block = new boolean[N][N];
    public boolean isEscapePossible(int[][] blocked, int[] s, int[] t) {
        List<int[]> list = new ArrayList<>();
        list.add(new int[]{-1, -1, 0});
        list.add(new int[]{EDGE, EDGE, 0});
        for (int[] p : blocked) list.add(new int[]{p[0], p[1], 0});
        list.add(new int[]{s[0], s[1], 1});
        list.add(new int[]{t[0], t[1], 2});
        Collections.sort(list, (a,b)->a[0]-b[0]);
        int n = list.size();
        for (int i = 0, idx = 1; i < n; ) {
            int j = i, cur = list.get(i)[0];
            while (j < n && cur == list.get(j)[0]) j++;
            for (int k = i; k < j; k++) list.get(k)[0] = idx;
            if (j < n && list.get(j)[0] - cur == 1) idx++;
            else idx += 2;
            i = j;
        }
        Collections.sort(list, (a,b)->a[1]-b[1]);
        for (int i = 0, idx = 1; i < n; ) {
            int j = i, cur = list.get(i)[1];
            while (j < n && cur == list.get(j)[1]) j++;
            for (int k = i; k < j; k++) list.get(k)[1] = idx;
            if (j < n && list.get(j)[1] - cur == 1) idx++;
            else idx += 2;
            i = j;
        }
        int mr = 0, mc = 0;
        int a = 0, b = 0, c = 0, d = 0;
        for (int[] info : list) {
            int x = info[0], y = info[1], state = info[2];
            if (state == 1) {
                a = x; b = y;
            } else if (state == 2) {
                c = x; d = y;
            } else {
                block[x][y] = true;
            }
            mr = Math.max(mr, x);
            mc = Math.max(mc, y);
        }
        int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
        Deque<int[]> de = new ArrayDeque<>();
        de.addLast(new int[]{a, b});
        vis[a][b] = true;
        while (!de.isEmpty()) {
            int[] poll = de.pollFirst();
            int x = poll[0], y = poll[1];
            if (x == c && y == d) return true;
            for (int[] di : dir) {
                int nx = x + di[0], ny = y + di[1];
                if (nx <= 1 || nx >= mr || ny <= 1 || ny >= mc) continue;
                if (vis[nx][ny] || block[nx][ny]) continue;
                de.addLast(new int[]{nx, ny});
                vis[nx][ny] = true;
            }
        }
        return false;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$

---

## ç­”ç–‘

#### çœ‹åˆ°è¯„è®ºåŒºå¥½å¤šåŒå­¦æé—® `BASE = 131` ä»¥åŠ `x * BASE + y` æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

ç›®çš„å°±æ˜¯ä¸ºäº†å°†äºŒç»´åæ ‡ $(x, y)$ æ˜ å°„æˆä¸€ä¸ªå”¯ä¸€å€¼è€Œå·²ï¼Œå®ç°çš„æ•ˆæœå’Œå¸¸è§„çš„ $i * col + j$ ç±»ä¼¼ã€‚

å› è€Œ `BASE` å–ä»€ä¹ˆå…³ç³»éƒ½ä¸å¤§ï¼Œåªè¦ç¡®ä¿æœ‰é™çš„æµ‹è¯•æ ·ä¾‹ä¸­ä¸ä¼šå› ä¸ºå†²çªå¯¼è‡´ç­”æ¡ˆé”™è¯¯å³å¯ï¼ˆé”™äº†çš„è¯ï¼Œé‚£å°±å†æ¢ä¸€ä¸ª `BASE`ï¼›å†é”™ï¼Œæ¢æˆå€¼åŸŸæ›´å¤§çš„ `long`ï¼›è¿˜æ˜¯é”™ï¼Œå°±æ‰‹åŠ¨å–æ¨¡ã€åŒå“ˆå¸Œç­‰ç­‰ ... ï¼‰ã€‚

å½“ç„¶æ›´åŠ ç¨³å¦¥çš„åšæ³•å¯ä»¥æ˜¯ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥çš„æ–¹å¼ï¼Œè¿™æ ·èƒ½å®Œå…¨ç¡®ä¿ä¸åŒçš„ $(x, y)$ å¯¹åº”çš„å“ˆå¸Œå€¼å¿…ç„¶ä¸åŒï¼Œä½†æ˜¯è¯¥åšæ³•å¸¸æ•°è¾ƒå¤§ï¼Œä¼°è®¡è·‘ $1e5$ çš„ `MAX` ä¼šå‡ºç°å•ç”¨ä¾‹ `TLE` çš„æƒ…å†µã€‚

è´´ä¸€ä¸ªå­—ç¬¦ä¸²æ‹¼æ¥çš„ä»£ç ï¼š
```Java []
class Solution {
    int EDGE = (int)1e6, MAX = (int)1e5;
    Set<String> set = new HashSet<>();
    int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public boolean isEscapePossible(int[][] blocked, int[] s, int[] t) {
        for (int[] p : blocked) set.add(p[0] + "_" + p[1]);
        int n = blocked.length;
        MAX = n * (n - 1) / 2; // å­—ç¬¦ä¸²æ‹¼æ¥çš„å“ˆå¸Œæ–¹å¼å¸¸æ•°è¾ƒå¤§ï¼Œä¸èƒ½ç›´æ¥ç”¨ 1e5
        return check(s, t) && check(t, s);
    }
    boolean check(int[] a, int[] b) {
        Set<String> vis = new HashSet<>();
        Deque<int[]> d = new ArrayDeque<>();
        d.addLast(a);
        vis.add(a[0] + "_" + a[1]);
        while (!d.isEmpty() && vis.size() <= MAX) {
            int[] poll = d.pollFirst();
            int x = poll[0], y = poll[1];
            if (x == b[0] && y == b[1]) return true;
            for (int[] di : dir) {
                int nx = x + di[0], ny = y + di[1];
                if (nx < 0 || nx >= EDGE || ny < 0 || ny >= EDGE) continue;
                if (set.contains(nx + "_" + ny)) continue;
                if (vis.contains(nx + "_" + ny)) continue;
                d.addLast(new int[]{nx, ny});
                vis.add(nx + "_" + ny);
            }
        }
        return vis.size() > MAX;
    }
}
```

---

## æœ€å

**å¦‚æœæœ‰å¸®åŠ©åˆ°ä½ ï¼Œè¯·ç»™é¢˜è§£ç‚¹ä¸ªèµå’Œæ”¶è—ï¼Œè®©æ›´å¤šçš„äººçœ‹åˆ° ~ ("â–”â–¡â–”)/**

ä¹Ÿæ¬¢è¿ä½  [å…³æ³¨æˆ‘](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png)ï¼ˆå…¬ä¸»å·åå°å›å¤ã€Œé€ä¹¦ã€å³å¯å‚ä¸é•¿æœŸçœ‹é¢˜è§£å­¦ç®—æ³•é€å®ä½“ä¹¦æ´»åŠ¨ï¼‰æˆ– åŠ å…¥[ã€Œç»„é˜Ÿæ‰“å¡ã€](https://leetcode-cn.com/u/ac_oier/)å°ç¾¤ ï¼Œæä¾›å†™ã€Œè¯æ˜ã€&ã€Œæ€è·¯ã€çš„é«˜è´¨é‡é¢˜è§£ã€‚

æ‰€æœ‰é¢˜è§£å·²ç»åŠ å…¥ [åˆ·é¢˜æŒ‡å—](https://github.com/SharingSource/LogicStack-LeetCode/wiki)ï¼Œæ¬¢è¿ star å“¦ ~ 