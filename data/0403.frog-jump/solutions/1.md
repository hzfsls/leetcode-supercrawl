## [403.é’è›™è¿‡æ²³ ä¸­æ–‡çƒ­é—¨é¢˜è§£1](https://leetcode.cn/problems/frog-jump/solutions/100000/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw)

ä½œè€…ï¼š[AC_OIer](https://leetcode.cn/u/AC_OIer)

## DFSï¼ˆTLEï¼‰

æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `DFS` æ¥æ¨¡æ‹Ÿ/çˆ†æœä¸€éï¼Œæ£€æŸ¥æ‰€æœ‰çš„å¯èƒ½æ€§ä¸­æ˜¯å¦æœ‰èƒ½åˆ°è¾¾æœ€åä¸€å—çŸ³å­çš„ã€‚

é€šå¸¸è®¾è®¡ `DFS` å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸å¤±ä¸€èˆ¬æ€§çš„è€ƒè™‘å®Œæˆç¬¬ $i$ å—çŸ³å­çš„è·³è·ƒéœ€è¦äº›ä»€ä¹ˆä¿¡æ¯å³å¯ï¼š

* éœ€è¦çŸ¥é“å½“å‰æ‰€åœ¨ä½ç½®åœ¨å“ªï¼Œä¹Ÿå°±æ˜¯éœ€è¦çŸ¥é“å½“å‰çŸ³å­æ‰€åœ¨åˆ—è¡¨ä¸­çš„ä¸‹æ ‡ $u$ã€‚
* éœ€è¦çŸ¥é“å½“å‰æ‰€åœ¨ä½ç½®æ˜¯ç»è¿‡å¤šå°‘æ­¥è€Œæ¥çš„ï¼Œä¹Ÿå°±æ˜¯éœ€è¦çŸ¥é“ä¸Šä¸€æ­¥çš„è·³è·ƒæ­¥é•¿ $k$ã€‚

ä»£ç ï¼š
```Java []
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public boolean canCross(int[] ss) {
        int n = ss.length;
        // å°†çŸ³å­ä¿¡æ¯å­˜å…¥å“ˆå¸Œè¡¨
        // ä¸ºäº†å¿«é€Ÿåˆ¤æ–­æ˜¯å¦å­˜åœ¨æŸå—çŸ³å­ï¼Œä»¥åŠå¿«é€ŸæŸ¥æ‰¾æŸå—çŸ³å­æ‰€åœ¨ä¸‹æ ‡
        for (int i = 0; i < n; i++) {
            map.put(ss[i], i);
        }
        // check first step
        // æ ¹æ®é¢˜æ„ï¼Œç¬¬ä¸€æ­¥æ˜¯å›ºå®šç»è¿‡æ­¥é•¿ 1 åˆ°è¾¾ç¬¬ä¸€å—çŸ³å­ï¼ˆä¸‹æ ‡ä¸º 1ï¼‰
        if (!map.containsKey(1)) return false;
        return dfs(ss, ss.length, 1, 1);
    }

    /**
     * åˆ¤å®šæ˜¯å¦èƒ½å¤Ÿè·³åˆ°æœ€åä¸€å—çŸ³å­
     * @param ss çŸ³å­åˆ—è¡¨ã€ä¸å˜ã€‘
     * @param n  çŸ³å­åˆ—è¡¨é•¿åº¦ã€ä¸å˜ã€‘
     * @param u  å½“å‰æ‰€åœ¨çš„çŸ³å­çš„ä¸‹æ ‡
     * @param k  ä¸Šä¸€æ¬¡æ˜¯ç»è¿‡å¤šå°‘æ­¥è·³åˆ°å½“å‰ä½ç½®çš„
     * @return æ˜¯å¦èƒ½è·³åˆ°æœ€åä¸€å—çŸ³å­
     */
    boolean dfs(int[] ss, int n, int u, int k) {
        if (u == n - 1) return true;
        for (int i = -1; i <= 1; i++) {
            // å¦‚æœæ˜¯åŸåœ°è¸æ­¥çš„è¯ï¼Œç›´æ¥è·³è¿‡
            if (k + i == 0) continue;
            // ä¸‹ä¸€æ­¥çš„çŸ³å­ç†è®ºç¼–å·
            int next = ss[u] + k + i;
            // å¦‚æœå­˜åœ¨ä¸‹ä¸€æ­¥çš„çŸ³å­ï¼Œåˆ™è·³è½¬åˆ°ä¸‹ä¸€æ­¥çŸ³å­ï¼Œå¹¶ DFS ä¸‹å»
            if (map.containsKey(next)) {
                boolean cur = dfs(ss, n, map.get(next), k + i);
                if (cur) return true;
            }
        }
        return false;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(3^n)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(3^n)$

ä½†æ•°æ®èŒƒå›´ä¸º $10^3$ï¼Œç›´æ¥ä½¿ç”¨ DFS è‚¯å®šä¼šè¶…æ—¶ã€‚

**æˆ‘ä»¬éœ€è¦è€ƒè™‘åŠ å…¥ã€Œè®°å¿†åŒ–ã€åŠŸèƒ½ï¼Œæˆ–è€…æ”¹ä¸ºä½¿ç”¨å¸¦æ ‡è®°çš„ `BFS`ã€‚**

***

## è®°å¿†åŒ–æœç´¢

**åœ¨è€ƒè™‘åŠ å…¥ã€Œè®°å¿†åŒ–ã€æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦å°† `DFS` æ–¹æ³•ç­¾åä¸­çš„ã€å¯å˜ã€‘å‚æ•°ä½œä¸ºç»´åº¦ï¼Œ`DFS` æ–¹æ³•ä¸­çš„è¿”å›å€¼ä½œä¸ºå­˜å‚¨å€¼å³å¯ã€‚**

é€šå¸¸æˆ‘ä»¬ä¼šä½¿ç”¨ã€Œæ•°ç»„ã€æ¥ä½œä¸ºæˆ‘ä»¬ç¼“å­˜ä¸­é—´ç»“æœçš„å®¹å™¨ï¼Œ

å¯¹åº”åˆ°æœ¬é¢˜ï¼Œå°±æ˜¯éœ€è¦ä¸€ä¸ª `boolean[çŸ³å­åˆ—è¡¨ä¸‹æ ‡][è·³è·ƒæ­¥æ•°]` è¿™æ ·çš„æ•°ç»„ï¼Œä½†ä½¿ç”¨å¸ƒå°”æ•°ç»„ä½œä¸ºè®°å¿†åŒ–å®¹å™¨å¾€å¾€æ— æ³•åŒºåˆ†ã€ŒçŠ¶æ€å°šæœªè®¡ç®—ã€å’Œã€ŒçŠ¶æ€å·²ç»è®¡ç®—ï¼Œå¹¶ä¸”ç»“æœä¸º `false`ã€ä¸¤ç§æƒ…å†µã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦è½¬ä¸ºä½¿ç”¨ `int[çŸ³å­åˆ—è¡¨ä¸‹æ ‡][è·³è·ƒæ­¥æ•°]`ï¼Œé»˜è®¤å€¼ $0$ ä»£è¡¨çŠ¶æ€å°šæœªè®¡ç®—ï¼Œ$-1$ ä»£è¡¨è®¡ç®—çŠ¶æ€ä¸º `false`ï¼Œ$1$ ä»£è¡¨è®¡ç®—çŠ¶æ€ä¸º `true`ã€‚

æ¥ä¸‹æ¥éœ€è¦ä¼°ç®—æ•°ç»„çš„å®¹é‡ï¼Œå¯ä»¥ä»ã€Œæ•°æ®èŒƒå›´ã€å…¥æ‰‹åˆ†æã€‚

æ ¹æ® `2 <= stones.length <= 2000`ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šç¬¬ä¸€ç»´ï¼ˆæ•°ç»„ä¸‹æ ‡ï¼‰çš„é•¿åº¦ä¸º $2009$ï¼Œè€Œå¦å¤–ä¸€ç»´ï¼ˆè·³è·ƒæ­¥æ•°ï¼‰æ˜¯ä¸è·³è½¬è¿‡ç¨‹ç›¸å…³çš„ï¼Œæ— æ³•ç›´æ¥ç¡®å®šä¸€ä¸ªç²¾ç¡®è¾¹ç•Œï¼Œä½†æ˜¯ä¸€ä¸ªæ˜¾è€Œæ˜“è§çš„äº‹å®æ˜¯ï¼Œè·³åˆ°æœ€åä¸€å—çŸ³å­ä¹‹åçš„ä½ç½®æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå› æ­¤æˆ‘ä»¬ä¸ä¼šæœ‰ã€Œè·³è·ƒæ­¥é•¿ã€å¤§äºã€ŒçŸ³å­åˆ—è¡¨é•¿åº¦ã€çš„æƒ…å†µï¼Œå› æ­¤ä¹Ÿå¯ä»¥å®šä¸º $2009$ï¼ˆè¿™é‡Œæ˜¯åˆ©ç”¨äº†ç”±ä¸‹æ ‡ä¸º $i$ çš„ä½ç½®å‘èµ·çš„è·³è·ƒä¸ä¼šè¶…è¿‡ $i + 1$ çš„æ€§è´¨ï¼‰ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å®šä¸‹æ¥äº†è®°å¿†åŒ–å®¹å™¨ä¸º `int[][] cache = new int[2009][2009]`ã€‚

ä½†æ˜¯å¯ä»¥çœ‹å‡ºï¼Œä¸Šè¿°ç¡®å®šå®¹å™¨å¤§å°çš„è¿‡ç¨‹è¿˜æ˜¯éœ€è¦ä¸€ç‚¹ç‚¹åˆ†æ & ç»éªŒçš„ã€‚

é‚£ä¹ˆæ˜¯å¦æœ‰æ€ç»´éš¾åº¦å†ä½ç‚¹çš„æ–¹æ³•å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯æœ‰çš„ï¼Œç›´æ¥ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€ä½œä¸ºè®°å¿†åŒ–å®¹å™¨ã€‚ã€Œå“ˆå¸Œè¡¨ã€æœ¬èº«å±äºéå®šé•¿å®¹å™¨é›†åˆï¼Œæˆ‘ä»¬ä¸éœ€è¦åˆ†æä¸¤ä¸ªç»´åº¦çš„ä¸Šé™åˆ°åº•æ˜¯å¤šå°‘ã€‚

**å¦å¤–ï¼Œå½“å®¹å™¨ç»´åº¦è¾ƒå¤šä¸”ä¸Šç•Œè¾ƒå¤§æ—¶ï¼ˆä¾‹å¦‚ä¸Šè¿°çš„ `int[2009][2009]`ï¼‰ï¼Œç›´æ¥ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€å¯ä»¥æœ‰æ•ˆé™ä½ã€Œçˆ†ç©ºé—´/æ—¶é—´ã€çš„é£é™©ï¼ˆä¸éœ€è¦æ¯è·‘ä¸€ä¸ªæ ·ä¾‹éƒ½åˆ›å»ºä¸€ä¸ªç™¾ä¸‡çº§çš„æ•°ç»„ï¼‰ã€‚**

**ä»£ç ï¼ˆæ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—QAQ](/u/littletime_cc/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    // int[][] cache = new int[2009][2009];
    Map<String, Boolean> cache = new HashMap<>();
    public boolean canCross(int[] ss) {
        int n = ss.length;
        for (int i = 0; i < n; i++) {
            map.put(ss[i], i);
        }
        // check first step
        if (!map.containsKey(1)) return false;
        return dfs(ss, ss.length, 1, 1);
    }
    boolean dfs(int[] ss, int n, int u, int k) {
        String key = u + "_" + k;
        // if (cache[u][k] != 0) return cache[u][k] == 1;
        if (cache.containsKey(key)) return cache.get(key);
        if (u == n - 1) return true;
        for (int i = -1; i <= 1; i++) {
            if (k + i == 0) continue;
            int next = ss[u] + k + i;
            if (map.containsKey(next)) {
                boolean cur = dfs(ss, n, map.get(next), k + i);
                // cache[u][k] = cur ? 1 : -1;
                cache.put(key, cur);
                if (cur) return true;
            }
        }
        // cache[u][k] = -1;
        cache.put(key, false);
        return false;
    }
}
```
```C++ []
class Solution {
public:
    bool canCross(vector<int>& stones) {
        int n = stones.size();
        if(stones[1] != 1) return false;
        map<int,int> mp;
        map<int,bool> f; //è®°å¿†åŒ–cache
        for(int i = 0; i < n; i++) mp[stones[i]] = i;

        std::function<bool(int,int)> dfs = [&](int idx,int k){
            auto key = idx * 10000 + k; //keyå€¼å¯ä»¥è¿™æ ·æ˜ å°„
            if(f.count(key)) return f[key];
            if(idx == n - 1) return true;
            for(int i = -1; i <= 1; i++){
                if(k + i == 0) continue;
                int next = stones[idx] + k + i;
                if(mp.count(next)){
                    bool cur = dfs(mp[next],k + i);
                    f[key] = cur; 
                    if(cur) return true;
                }
            }
            f[key] = false;
            return false;
        };
        
        return dfs(1,1);
    }
};
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$

***

## åŠ¨æ€è§„åˆ’

æœ‰äº†ã€Œè®°å¿†åŒ–æœç´¢ã€çš„åŸºç¡€ï¼Œè¦å†™å†™å‡ºæ¥åŠ¨æ€è§„åˆ’å°±å˜å¾—ç›¸å¯¹ç®€å•äº†ã€‚

**æˆ‘ä»¬å¯ä»¥ä» `DFS` å‡½æ•°å‡ºå‘ï¼Œå†™å‡ºã€ŒåŠ¨æ€è§„åˆ’ã€è§£æ³•ã€‚**

æˆ‘ä»¬çš„ `DFS` å‡½æ•°ç­¾åä¸ºï¼š

```Java []
boolean dfs(int[] ss, int n, int u, int k);
```

å…¶ä¸­å‰ä¸¤ä¸ªå‚æ•°ä¸ºä¸å˜å‚æ•°ï¼Œåä¸¤ä¸ªä¸ºå¯å˜å‚æ•°ï¼Œè¿”å›å€¼æ˜¯æˆ‘ä»¬çš„ç­”æ¡ˆã€‚

å› æ­¤å¯ä»¥è®¾å®šä¸º $f[][]$ ä½œä¸ºåŠ¨è§„æ•°ç»„ï¼š
1. ç¬¬ä¸€ç»´ä¸ºå¯å˜å‚æ•° $u$ï¼Œä»£è¡¨çŸ³å­åˆ—è¡¨çš„ä¸‹æ ‡ï¼ŒèŒƒå›´ä¸ºæ•°ç»„ `stones` é•¿åº¦ï¼›
2. ç¬¬äºŒç»´ä¸ºå¯å˜å‚æ•° $k$ï¼Œä»£è¡¨ä¸Šä¸€æ­¥çš„çš„è·³è·ƒæ­¥é•¿ï¼Œå‰é¢ä¹Ÿåˆ†æè¿‡äº†ï¼Œæœ€å¤šä¸è¶…è¿‡æ•°ç»„ `stones` é•¿åº¦ã€‚

**è¿™æ ·çš„ã€ŒçŠ¶æ€å®šä¹‰ã€æ‰€ä»£è¡¨çš„å«ä¹‰ï¼šå½“å‰åœ¨ç¬¬ $i$ ä¸ªä½ç½®ï¼Œå¹¶ä¸”æ˜¯ä»¥æ­¥é•¿ $k$ è·³åˆ°ä½ç½® $i$ æ—¶ï¼Œæ˜¯å¦åˆ°è¾¾æœ€åä¸€å—çŸ³å­ã€‚**

é‚£ä¹ˆå¯¹äº $f[i][k]$ æ˜¯å¦ä¸ºçœŸï¼Œåˆ™å–å†³äºä¸Šä¸€ä½ç½® $j$ çš„çŠ¶æ€å€¼ï¼Œç»“åˆæ¯æ¬¡æ­¥é•¿çš„å˜åŒ–ä¸º `[-1,0,1]` å¯çŸ¥ï¼š

* å¯ä» $f[j][k - 1]$ çŠ¶æ€è€Œæ¥ï¼šå…ˆæ˜¯ç»è¿‡ $k - 1$ çš„è·³è·ƒåˆ°è¾¾ä½ç½® $j$ï¼Œå†åœ¨åŸæ­¥é•¿çš„åŸºç¡€ä¸Š `+1`ï¼Œè·³åˆ°äº†ä½ç½® $i$ã€‚
* å¯ä» $f[j][k]$ çŠ¶æ€è€Œæ¥ï¼šå…ˆæ˜¯ç»è¿‡ $k$ çš„è·³è·ƒåˆ°è¾¾ä½ç½® $j$ï¼Œç»´æŒåŸæ­¥é•¿ä¸å˜ï¼Œè·³åˆ°äº†ä½ç½® $i$ã€‚
* å¯ä» $f[j][k + 1]$ çŠ¶æ€è€Œæ¥ï¼šå…ˆæ˜¯ç»è¿‡ $k + 1$ çš„è·³è·ƒåˆ°è¾¾ä½ç½® $j$ï¼Œå†åœ¨åŸæ­¥é•¿çš„åŸºç¡€ä¸Š `-1`ï¼Œè·³åˆ°äº†ä½ç½® $i$ã€‚

åªè¦ä¸Šè¿°ä¸‰ç§æƒ…å†µå…¶ä¸­ä¸€ç§ä¸ºçœŸï¼Œåˆ™ $f[i][j]$ ä¸ºçœŸã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬è§£å†³äº†åŠ¨æ€è§„åˆ’çš„ã€ŒçŠ¶æ€å®šä¹‰ã€&ã€ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€éƒ¨åˆ†ã€‚

ä½†è¿™å°±ç»“æŸäº†å—ï¼Ÿè¿˜æ²¡æœ‰ã€‚

æˆ‘ä»¬è¿˜ç¼ºå°‘å¯è®©çŠ¶æ€é€’æ¨ä¸‹å»çš„ã€Œæœ‰æ•ˆå€¼ã€ï¼Œæˆ–è€…è¯´ç¼ºå°‘åˆå§‹åŒ–ç¯èŠ‚ã€‚

å› ä¸ºæˆ‘ä»¬çš„ $f[i][k]$ ä¾èµ–äºä¹‹å‰çš„çŠ¶æ€è¿›è¡Œâ€œæˆ–è¿ç®—â€è€Œæ¥ï¼Œè½¬ç§»æ–¹ç¨‹æœ¬èº«ä¸ä¼šäº§ç”Ÿ $true$ å€¼ã€‚å› æ­¤ä¸ºäº†è®©æ•´ä¸ªã€Œé€’æ¨ã€è¿‡ç¨‹å¯æ»šåŠ¨ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæœ‰ä¸€ä¸ªä¸º $true$ çš„çŠ¶æ€å€¼ã€‚

è¿™æ—¶å€™å†å›çœ‹æˆ‘ä»¬çš„çŠ¶æ€å®šä¹‰ï¼š**å½“å‰åœ¨ç¬¬ $i$ ä¸ªä½ç½®ï¼Œå¹¶ä¸”æ˜¯ä»¥æ­¥é•¿ $k$ è·³åˆ°ä½ç½® $i$ æ—¶ï¼Œæ˜¯å¦åˆ°è¾¾æœ€åä¸€å—çŸ³å­ã€‚**

æ˜¾ç„¶ï¼Œæˆ‘ä»¬äº‹å…ˆæ˜¯ä¸å¯èƒ½çŸ¥é“ç»è¿‡ã€Œå¤šå¤§çš„æ­¥é•¿ã€è·³åˆ°ã€Œå“ªäº›ä½ç½®ã€ï¼Œæœ€ç»ˆå¯ä»¥åˆ°è¾¾æœ€åä¸€å—çŸ³å­ã€‚

**è¿™æ—¶å€™éœ€è¦åˆ©ç”¨ã€Œå¯¹å¶æ€§ã€å°†è·³è·ƒè¿‡ç¨‹ã€Œç¿»è½¬ã€è¿‡æ¥åˆ†æï¼š**

**æˆ‘ä»¬çŸ¥é“èµ·å§‹çŠ¶æ€æ˜¯ã€Œç»è¿‡æ­¥é•¿ä¸º 1ã€çš„è·³è·ƒåˆ°è¾¾ã€Œä½ç½® 1ã€ï¼Œå¦‚æœä»èµ·å§‹çŠ¶æ€å‡ºå‘ï¼Œå­˜åœ¨ä¸€ç§æ–¹æ¡ˆåˆ°è¾¾æœ€åä¸€å—çŸ³å­çš„è¯ï¼Œé‚£ä¹ˆå¿…ç„¶å­˜åœ¨ä¸€æ¡åå‘è·¯å¾„ï¼Œå®ƒæ˜¯ä»¥ä»ã€Œæœ€åä¸€å—çŸ³å­ã€å¼€å§‹ï¼Œå¹¶ä»¥ã€ŒæŸä¸ªæ­¥é•¿ $k$ã€å¼€å§‹è·³è·ƒï¼Œæœ€ç»ˆä»¥å›åˆ°ä½ç½® 1ã€‚**

å› æ­¤æˆ‘ä»¬å¯ä»¥è®¾ $f[1][1] = true$ï¼Œä½œä¸ºæˆ‘ä»¬çš„èµ·å§‹å€¼ã€‚

**è¿™é‡Œæœ¬è´¨æ˜¯åˆ©ç”¨ã€Œè·¯å¾„å¯é€†ã€çš„æ€§è´¨ï¼Œå°†é—®é¢˜è¿›è¡Œäº†ã€Œç­‰æ•ˆå¯¹å¶ã€ã€‚è¡¨é¢ä¸Šæˆ‘ä»¬æ˜¯è¿›è¡Œã€Œæ­£å‘é€’æ¨ã€ï¼Œä½†äº‹å®ä¸Šæˆ‘ä»¬æ˜¯åœ¨éªŒè¯æ˜¯å¦å­˜åœ¨æŸæ¡ã€Œåå‘è·¯å¾„ã€åˆ°è¾¾ä½ç½® $1$ã€‚**

å»ºè®®å¤§å®¶åŠ å¼ºç†è§£ ~ 

**ä»£ç ï¼ˆæ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—QAQ](/u/littletime_cc/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    public boolean canCross(int[] ss) {
        int n = ss.length;
        // check first step
        if (ss[1] != 1) return false;
        boolean[][] f = new boolean[n + 1][n + 1];
        f[1][1] = true;
        for (int i = 2; i < n; i++) {
            for (int j = 1; j < i; j++) {
                int k = ss[i] - ss[j];
                // æˆ‘ä»¬çŸ¥é“ä»ä½ç½® j åˆ°ä½ç½® i æ˜¯éœ€è¦æ­¥é•¿ä¸º k çš„è·³è·ƒ

                // è€Œä»ä½ç½® j å‘èµ·çš„è·³è·ƒæœ€å¤šä¸è¶…è¿‡ j + 1
                // å› ä¸ºæ¯æ¬¡è·³è·ƒï¼Œä¸‹æ ‡è‡³å°‘å¢åŠ  1ï¼Œè€Œæ­¥é•¿æœ€å¤šå¢åŠ  1 
                if (k <= j + 1) {
                    f[i][k] = f[j][k - 1] || f[j][k] || f[j][k + 1];
                }
            }
        }
        for (int i = 1; i < n; i++) {
            if (f[n - 1][i]) return true;
        }
        return false;
    }
}
```
```C++ []
bool f[2021][2021];
class Solution {
public:
    bool canCross(vector<int>& stones) {
        memset(f,false,sizeof f);
        int n = stones.size();
        if(stones[1] != 1) return false;
        f[1][1] = true;
        for(int i = 2;i < n; i++){
            for(int j = 1; j < i; j++){
                int k = stones[i] - stones[j];
                if(k <= j + 1) f[i][k] = f[j][k - 1] || f[j][k] || f[j][k + 1];
            }
        }
        for(int i = 1; i < n; i++){
            if(f[n - 1][i]) return true;
        }
        return false;
    }
};
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$


***

## BFS

äº‹å®ä¸Šï¼Œå‰é¢æˆ‘ä»¬ä¹Ÿè¯´åˆ°ï¼Œè§£å†³è¶…æ—¶ `DFS` é—®é¢˜ï¼Œé™¤äº†å¢åŠ ã€Œè®°å¿†åŒ–ã€åŠŸèƒ½ä»¥å¤–ï¼Œè¿˜èƒ½ä½¿ç”¨å¸¦æ ‡è®°çš„ `BFS`ã€‚

**å› ä¸ºä¸¤è€…éƒ½èƒ½è§£å†³ `DFS` çš„è¶…æ—¶åŸå› ï¼šå¤§é‡çš„é‡å¤è®¡ç®—ã€‚**

ä½†ä¸ºäº†ã€Œè®°å¿†åŒ–æœç´¢ã€&ã€ŒåŠ¨æ€è§„åˆ’ã€èƒ½å¤Ÿæ›´å¥½çš„è¡”æ¥ï¼Œæ‰€ä»¥æˆ‘æŠŠ `BFS` æ”¾åˆ°æœ€åã€‚

å¦‚æœä½ èƒ½å¤Ÿçœ‹åˆ°è¿™é‡Œï¼Œé‚£ä¹ˆè¿™é‡Œçš„ `BFS` åº”è¯¥çœ‹èµ·æ¥ä¼šç›¸å¯¹è½»æ¾ã€‚

å®ƒæ›´å¤šæ˜¯ä½œä¸ºã€Œè®°å¿†åŒ–æœç´¢ã€çš„å¦å¤–ä¸€ç§å®ç°å½¢å¼ã€‚

**ä»£ç ï¼ˆæ„Ÿè°¢ [@ğŸ­å¯ä¹å¯ä¹å—QAQ](/u/littletime_cc/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java []
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public boolean canCross(int[] ss) {
        int n = ss.length;
        for (int i = 0; i < n; i++) {
            map.put(ss[i], i);
        }
        // check first step
        if (!map.containsKey(1)) return false;

        boolean[][] vis = new boolean[n][n];
        Deque<int[]> d = new ArrayDeque<>();
        vis[1][1] = true;
        d.addLast(new int[]{1, 1});

        while (!d.isEmpty()) {
            int[] poll = d.pollFirst();
            int idx = poll[0], k = poll[1];
            if (idx == n - 1) return true;
            for (int i = -1; i <= 1; i++) {
                if (k + i == 0) continue;
                int next = ss[idx] + k + i;
                if (map.containsKey(next)) {
                    int nIdx = map.get(next), nK = k + i;
                    if (nIdx == n - 1) return true;
                    if (!vis[nIdx][nK]) {
                        vis[nIdx][nK] = true;
                        d.addLast(new int[]{nIdx, nK});
                    }
                }
            }
        }

        return false;
    }
}
```
```C++ []
bool st[2021][2021];
using PII = pair<int,int>;
class Solution {
public:
    bool canCross(vector<int>& stones) {
        int n = stones.size();
        if(stones[1] != 1) return false;
        map<int,int> mp;
        for(int i = 0; i < n; i++) mp[stones[i]] = i;
        memset(st,false,sizeof st);
        queue<PII> q;
        st[1][1] = true;
        q.push( {1,1} );
        while(q.size()){
            auto t = q.front(); q.pop();
            int idx = t.first, k = t.second;
            if(idx == n - 1) return true;
            for(int i = -1; i <= 1; i++){
                if(k + i == 0) continue;
                int next = stones[idx] + k + i;
                if(mp.count(next)){
                    int t_idx = mp[next], t_k = k + i;
                    if(t_idx == n - 1) return true;
                    if(!st[t_idx][t_k]){
                        st[t_idx][t_k] = true;
                        q.push( {t_idx, t_k} );
                    }
                }
            }
        }
        return false;
    }
};
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$

---

## æœ€å

**å¦‚æœæœ‰å¸®åŠ©åˆ°ä½ ï¼Œè¯·ç»™é¢˜è§£ç‚¹ä¸ªèµå’Œæ”¶è—ï¼Œè®©æ›´å¤šçš„äººçœ‹åˆ° ~ ("â–”â–¡â–”)/**

ä¹Ÿæ¬¢è¿ä½  [å…³æ³¨æˆ‘](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) å’Œ åŠ å…¥æˆ‘ä»¬çš„[ã€Œç»„é˜Ÿæ‰“å¡ã€](https://leetcode-cn.com/u/ac_oier/)å°ç¾¤ ï¼Œæä¾›å†™ã€Œè¯æ˜ã€&ã€Œæ€è·¯ã€çš„é«˜è´¨é‡é¢˜è§£ã€‚

æ‰€æœ‰é¢˜è§£å·²ç»åŠ å…¥ [åˆ·é¢˜æŒ‡å—](https://github.com/SharingSource/LogicStack-LeetCode/wiki)ï¼Œæ¬¢è¿ star å“¦ ~